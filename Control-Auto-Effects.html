<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Auto.Effects</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Auto-Effects.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Control.Auto.Effects.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">auto-0.4.3.0: Denotative, locally stateful programming DSL &amp; platform</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Justin Le 2015</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>justin@jle.im</td></tr><tr><th>Stability</th><td>unstable</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Auto.Effects</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Running effects</a><ul><li><a href="#g:2">Continually</a></li><li><a href="#g:3">From inputs</a></li><li><a href="#g:4">On <code>Blip</code>s</a></li><li><a href="#g:5">One-time effects</a></li></ul></li><li><a href="#g:6">Hoists</a></li><li><a href="#g:7">Specific underlying monads</a><ul><li><a href="#g:8"><code>ReaderT</code></a><ul><li><a href="#g:9">Sealing from sources</a></li></ul></li><li><a href="#g:10"><code>WriterT</code></a></li><li><a href="#g:11"><code>StateT</code></a></li><li><a href="#g:12"><code>Traversable</code></a></li><li><a href="#g:13"><code>IO</code></a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module exports the preferred ways of interacting with the
 underlying <code><a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a></code> of the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> type, including accessing, executing,
 and manipulating such effects.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:arrM">arrM</a> :: (a -&gt; m b) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:effect">effect</a> :: m b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:effects">effects</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (m a) a</li><li class="src short"><a href="#v:arrMB">arrMB</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> b)</li><li class="src short"><a href="#v:effectB">effectB</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> b)</li><li class="src short"><a href="#v:execB">execB</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> a)</li><li class="src short"><a href="#v:cache">cache</a> :: (<a href="../cereal-0.5.1.0/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m) =&gt; m b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:execOnce">execOnce</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a ()</li><li class="src short"><a href="#v:cache_">cache_</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:execOnce_">execOnce_</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a ()</li><li class="src short"><a href="#v:hoistA">hoistA</a> :: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m') =&gt; (<span class="keyword">forall</span> c. m c -&gt; m' c) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m' a b</li><li class="src short"><a href="#v:generalizeA">generalizeA</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:runReaderA">runReaderA</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (a, r) b</li><li class="src short"><a href="#v:sealReader">sealReader</a> :: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../cereal-0.5.1.0/Data-Serialize.html#t:Serialize">Serialize</a> r) =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b -&gt; r -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:sealReader_">sealReader_</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b -&gt; r -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:readerA">readerA</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (a, r) b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b</li><li class="src short"><a href="#v:sealReaderMVar">sealReaderMVar</a> :: <a href="../base-4.9.0.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b -&gt; <a href="../base-4.9.0.0/Control-Concurrent-MVar.html#t:MVar">MVar</a> r -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:sealReaderM">sealReaderM</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b -&gt; m r -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:writerA">writerA</a> :: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../base-4.9.0.0/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a (b, w) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a> w m) a b</li><li class="src short"><a href="#v:runWriterA">runWriterA</a> :: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../base-4.9.0.0/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a> w m) a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a (b, w)</li><li class="src short"><a href="#v:sealState">sealState</a> :: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../cereal-0.5.1.0/Data-Serialize.html#t:Serialize">Serialize</a> s) =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m) a b -&gt; s -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:sealState_">sealState_</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m) a b -&gt; s -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:runStateA">runStateA</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m) a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (a, s) (b, s)</li><li class="src short"><a href="#v:stateA">stateA</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (a, s) (b, s) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m) a b</li><li class="src short"><a href="#v:accumA">accumA</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (a, s) s -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m) a s</li><li class="src short"><a href="#v:runTraversableA">runTraversableA</a> :: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> f, <a href="../base-4.9.0.0/Data-Traversable.html#t:Traversable">Traversable</a> f) =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> f a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a (f b)</li><li class="src short"><a href="#v:catchA">catchA</a> :: <a href="../base-4.9.0.0/Control-Exception-Base.html#t:Exception">Exception</a> e =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> <a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a> a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> <a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a> a (<a href="../base-4.9.0.0/Data-Either.html#t:Either">Either</a> e b)</li></ul></div><div id="interface"><h1 id="g:1">Running effects</h1><h2 id="g:2">Continually</h2><div class="top"><p class="src"><a id="v:arrM" class="def">arrM</a> <a href="src/Control.Auto.Effects.html#arrM" class="link">Source</a> <a href="#v:arrM" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; m b)</td><td class="doc"><p>monadic function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Applies the given &quot;monadic function&quot; (function returning a monadic
 action) to every incoming item; the result is the result of executing
 the action returned.</p><p>Note that this essentially lifts a &quot;Kleisli arrow&quot;; it's like <code>arr</code>, but
 for &quot;monadic functions&quot; instead of normal functions:</p><pre>arr  :: (a -&gt; b)   -&gt; Auto m a b
arrM :: (a -&gt; m b) -&gt; Auto m a b
</pre><pre>arrM f . arrM g == arrM (f &lt;=&lt; g)</pre><p>One neat trick you can do is that you can &quot;tag on effects&quot; to a normal
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code> by using <code><a href="../base-4.9.0.0/Control-Applicative.html#v:-42--62-">*&gt;</a></code> from <a href="../base-4.9.0.0/Control-Applicative.html">Control.Applicative</a>.  For example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = arrM print *&gt; sumFrom 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys &lt;- streamAuto a [1..5]
</code></strong>1                -- IO output
2
3
4
5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys
</code></strong>[1,3,6,10,15]    -- the result
</pre><p>Here, <code>a</code> behaves &quot;just like&quot; <code><code>sumFrom</code> 0</code>...except, when you step it,
 it prints out to stdout as a side-effect.  We just gave automatic
 stdout logging behavior!</p></div></div><div class="top"><p class="src"><a id="v:effect" class="def">effect</a> <a href="src/Control.Auto.Generate.html#effect" class="link">Source</a> <a href="#v:effect" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: m b</td><td class="doc"><p>monadic action to contually execute.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>To get every output, executes the monadic action and returns the
 result as the output.  Always ignores input.</p><p>This is basically like an &quot;effectful&quot; <code><a href="Control-Auto-Generate.html#v:pure">pure</a></code>:</p><pre><code><a href="Control-Auto-Generate.html#v:pure">pure</a></code>   :: b   -&gt; <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b
<code><a href="Control-Auto-Effects.html#v:effect">effect</a></code> :: m b -&gt; <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b
</pre><p>The output of <code><a href="Control-Auto-Generate.html#v:pure">pure</a></code> is always the same, and the output of <code><a href="Control-Auto-Effects.html#v:effect">effect</a></code> is
 always the result of the same monadic action.  Both ignore their inputs.</p><p>Fun times when the underling <code><a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a></code> is, for instance, <code>Reader</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = effect ask    :: Auto (Reader b) a b
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let r = evalAuto a () :: Reader b b
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runReader r &quot;hello&quot;
</code></strong>&quot;hello&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runReader r 100
</code></strong>100
</pre><p>If your underling monad has effects (<code><a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a></code>, <code>State</code>, <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code>, <code>Writer</code>,
 etc.), then it might be fun to take advantage of <code><a href="../base-4.9.0.0/Control-Applicative.html#v:-42--62-">*&gt;</a></code> from
 <a href="../base-4.9.0.0/Control-Applicative.html">Control.Applicative</a> to &quot;tack on&quot; an effect to a normal <code><a href="Control-Auto.html#t:Auto">Auto</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = effect (modify (+1)) *&gt; sumFrom 0 :: Auto (State Int) Int Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let st = streamAuto a [1..10]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (ys, s') = runState st 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys
</code></strong>[1,3,6,10,15,21,28,36,45,55]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s'
</code></strong>10
</pre><p>Our <code><a href="Control-Auto.html#t:Auto">Auto</a></code> <code>a</code> behaves exactly like <code><code>sumFrom</code> 0</code>, except at each step,
 it also increments the underlying/global state by one.  It is <code><code>sumFrom</code>
 0</code> with an &quot;attached effect&quot;.</p></div></div><h2 id="g:3">From inputs</h2><div class="top"><p class="src"><a id="v:effects" class="def">effects</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (m a) a <a href="src/Control.Auto.Effects.html#effects" class="link">Source</a> <a href="#v:effects" class="selflink">#</a></p><div class="doc"><p>The input stream is a stream of monadic actions, and the output stream
 is the result of their executions, through executing them.</p></div></div><h2 id="g:4">On <code><a href="Control-Auto-Blip.html#t:Blip">Blip</a></code>s</h2><div class="top"><p class="src"><a id="v:arrMB" class="def">arrMB</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> b) <a href="src/Control.Auto.Effects.html#arrMB" class="link">Source</a> <a href="#v:arrMB" class="selflink">#</a></p><div class="doc"><p>Maps one blip stream to another; replaces every emitted value with the
 result of the monadic function, executing it to get the result.</p></div></div><div class="top"><p class="src"><a id="v:effectB" class="def">effectB</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> b) <a href="src/Control.Auto.Effects.html#effectB" class="link">Source</a> <a href="#v:effectB" class="selflink">#</a></p><div class="doc"><p>Maps one blip stream to another; replaces every emitted value with the
 result of a fixed monadic action, run every time an emitted value is
 received.</p></div></div><div class="top"><p class="src"><a id="v:execB" class="def">execB</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip.html#t:Blip">Blip</a> a) <a href="src/Control.Auto.Effects.html#execB" class="link">Source</a> <a href="#v:execB" class="selflink">#</a></p><div class="doc"><p>Outputs the identical blip stream that is received; however, every
 time it sees an emitted value, executes the given monadic action on the
 side.</p></div></div><h2 id="g:5">One-time effects</h2><div class="top"><p class="src"><a id="v:cache" class="def">cache</a> <a href="src/Control.Auto.Effects.html#cache" class="link">Source</a> <a href="#v:cache" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../cereal-0.5.1.0/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m b</td><td class="doc"><p>monadic action to execute and use the result of</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The very first output executes a monadic action and uses the result as
 the output, ignoring all input.  From then on, it persistently outputs
 that first result.</p><p>Like <code><a href="Control-Auto-Effects.html#v:execOnce">execOnce</a></code>, except outputs the result of the action instead of
 ignoring it.</p><p>Useful for loading resources in IO on the &quot;first step&quot;, like
 a word list:</p><pre>dictionary :: Auto IO a [String]
dictionary = cache (lines <a href="$">$</a> readFile &quot;wordlist.txt&quot;)
</pre></div></div><div class="top"><p class="src"><a id="v:execOnce" class="def">execOnce</a> <a href="src/Control.Auto.Effects.html#execOnce" class="link">Source</a> <a href="#v:execOnce" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m b</td><td class="doc"><p>monadic action to execute; result discared</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Always outputs '()', but when asked for the first output, executes the
 given monadic action.</p><p>Pretty much like <code><a href="Control-Auto-Effects.html#v:cache">cache</a></code>, but always outputs '()'.</p></div></div><div class="top"><p class="src"><a id="v:cache_" class="def">cache_</a> <a href="src/Control.Auto.Effects.html#cache_" class="link">Source</a> <a href="#v:cache_" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m b</td><td class="doc"><p>monadic action to execute and use the result of</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resumable/non-serializable version of <code><a href="Control-Auto-Effects.html#v:cache">cache</a></code>.  Every time the
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code> is deserialized/reloaded, it re-executes the action to retrieve
 the result again.</p><p>Useful in cases where you want to &quot;re-load&quot; an expensive resource on
 every startup, instead of saving it to in the save states.</p><pre>dictionary :: Auto IO a [String]
dictionary = cache_ (lines <a href="$">$</a> readFile &quot;dictionary.txt&quot;)
</pre></div></div><div class="top"><p class="src"><a id="v:execOnce_" class="def">execOnce_</a> <a href="src/Control.Auto.Effects.html#execOnce_" class="link">Source</a> <a href="#v:execOnce_" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m b</td><td class="doc"><p>monadic action to execute; result discared</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resumable/non-serializable version of <code><a href="Control-Auto-Effects.html#v:execOnce">execOnce</a></code>.  Every time
 the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> is deserialized/reloaded, the action is re-executed again.</p></div></div><h1 id="g:6">Hoists</h1><div class="top"><p class="src"><a id="v:hoistA" class="def">hoistA</a> <a href="src/Control.Auto.Core.html#hoistA" class="link">Source</a> <a href="#v:hoistA" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m')</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> c. m c -&gt; m' c)</td><td class="doc"><p>monad morphism;
     the natural transformation</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m' a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Swaps out the underlying <code><a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a></code> of an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> using the given monad
 morphism &quot;transforming function&quot;, a natural transformation.</p><p>Basically, given a function to &quot;swap out&quot; any <code>m a</code> with an <code>m' a</code>, it
 swaps out the underlying monad of the <code><a href="Control-Auto.html#t:Auto">Auto</a></code>.</p><p>This forms a functor, so you rest assured in things like this:</p><pre>hoistA id == id
hoistA f a1 . hoistA f a2 == hoistA f (a1 . a2)
</pre></div></div><div class="top"><p class="src"><a id="v:generalizeA" class="def">generalizeA</a> :: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b <a href="src/Control.Auto.Core.html#generalizeA" class="link">Source</a> <a href="#v:generalizeA" class="selflink">#</a></p><div class="doc"><p>Generalizes an <code><code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a b</code> to an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b'</code> for any <code><a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a></code>
 <code>m</code>, using <code>hoist</code>.</p><p>You generally should be able to avoid using this if you never directly
 write any <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code>s and always write 'Auto m' parameterized over all
 <code><a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a></code>s, but...in case you import one from a library or something, you
 can use this.</p></div></div><h1 id="g:7">Specific underlying monads</h1><div class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code>s can be run in the context of an underlying monad; this means
 that, instead of just being a straight-up <code>[a] -&gt; [b]</code>, pairing up each
 <code>a</code> with a <code>b</code>, you can actually attach a &quot;context&quot; to the <code>b</code>-making
 process, in order to enrich your streaming logic with things like
 a global read-only environment, a global sink, or global mutable state.
 The main benefit is that these things all <em>compose</em> like any other
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code>...they compose with <code><a href="../base-4.9.0.0/Control-Category.html#v:.">.</a></code>, you can use <code><a href="../base-4.9.0.0/Control-Applicative.html#t:Applicative">Applicative</a></code>, <code>Arrow</code>,
 etc., and they'll combine properly.</p><p>For the most part, a good general philosophy is to only have a &quot;small
 part&quot; of your program over a monad.  You might have a small region of
 your program that would benefit from having a global environment, a
 small region of your program that would benefit from having a sink, or
 a small program that would benefit from global mutable state.  Exercise
 good style and write maintainable code by limiting the effectful parts
 to the bare minimum essential, then using <code><a href="Control-Auto-Effects.html#v:runReaderA">runReaderA</a></code>, <code><a href="Control-Auto-Effects.html#v:sealReader">sealReader</a></code>,
 <code><a href="Control-Auto-Effects.html#v:runWriterA">runWriterA</a></code>, <code>sealStateA</code>, etc. to &quot;close off&quot; or seal the effects, and
 use the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> like a normal one without effects.</p><p>In this section are combinators for working with specific underlying
 monads...and a little description on how each might be useful.  Remember
 to use them wisely!  Adding any underlying monad causes the complexity
 of reasoning with your code to go up (depending on which monad), so make
 sure that you get a real gain before using these!</p></div><h2 id="g:8"><code><a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a></code></h2><div class="doc"><p><code>Reader</code>, or <code><a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a></code> is probably one of the most useful underlying
 monads to work with.  Basically, instead of <code>[a] -&gt; [b]</code>, you have <code>[a]
 -&gt; r -&gt; [b]</code>.  Generate <code>b</code>'s, but with an <code>r</code> parameter you can always
 access.  In practice, you can use <code>Reader</code> to hide a lot of boilerplate
 threading, add an extra &quot;side input&quot; channel, or compose <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s with
 a <em>static guarantee</em> that all <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s composed will use the <em>same</em> <code>r</code>
 environment.</p><p>Using <code><a href="Control-Auto-Effects.html#v:effect">effect</a></code>, you have access to the environment:</p><pre><code><a href="Control-Auto-Effects.html#v:effect">effect</a></code> <code>ask</code> :: <code>MonadReader</code> r m =&gt; <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a r
</pre><p>Which is an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> where the only thing it does is continually output
 the environment <code>r</code>.  You can throw this into any <em>proc</em> block over
 <code>Reader</code>, and you have a way to bring your environment &quot;into scope&quot;:</p><pre>env &lt;- <code><a href="Control-Auto-Effects.html#v:effect">effect</a></code> <code>ask</code> -&lt; ()
</pre><p>For a use case example, you might have:</p><pre>foo :: Auto m (Int, Database) Bool
bar :: Auto m (Bool, Database) Int
baz :: Auto m (Bool, Database) String
</pre><p>Where every <code><a href="Control-Auto.html#t:Auto">Auto</a></code> use a <code>Database</code> parameter to do their job...and it
 only makes sense when all of them are composed under the same
 <code>Database</code>.  You can use normal proc notation:</p><pre>full :: Auto m (Int, Database) String
full = proc (inp, db) -&gt; do
    fo &lt;- foo -&lt; (inp, db)
    br &lt;- bar -&lt; (fo, db)
    bz &lt;- baz -&lt; (fo, db)
    id -&lt; replicate br bz
</pre><p>Or, you can put them all under <code>Reader</code> and have the parameters pass
 implicitly:</p><pre>fullR :: Auto (ReaderT Database m) Int String
fullR = proc inp -&gt; do
    fo &lt;- readerA foo -&lt; inp
    br &lt;- readerA bar -&lt; fo
    bz &lt;- readerA baz -&lt; fo
    id -&lt; replicate br bz
</pre><p>You can recover the original behavior of <code>full</code> by using <code><a href="Control-Auto-Effects.html#v:runReaderA">runReaderA</a></code> to
 &quot;unroll&quot; the implicit argument:</p><pre>full' :: Auto m (Int, Database) String
full' = runReaderA fullR
</pre><p>You can also &quot;seal&quot; <code>fullR</code> so that it always runs with the same
 <code>Database</code> at every step using <code><a href="Control-Auto-Effects.html#v:sealReader">sealReader</a></code>:</p><pre>fullSealed :: Database -&gt; Auto m Int String
fullSealed = sealReader fullR
</pre><p><code>fullSealed db</code> will now assume that <code>foo</code>, <code>bar</code>, and <code>baz</code> all get the
 same environment forever when they are stepped/streamed.</p></div><div class="top"><p class="src"><a id="v:runReaderA" class="def">runReaderA</a> <a href="src/Control.Auto.Effects.html#runReaderA" class="link">Source</a> <a href="#v:runReaderA" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over global environment</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (a, r) b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> receiving environments</p></td></tr></table></div><div class="doc"><p><a href="Unrolls.html">Unrolls</a> the underlying <code><a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a></code> of an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> into an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that
 takes in the input &quot;environment&quot; every turn in addition to the normal
 input.</p><p>So you can use any <code><code><a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a></code> r m</code> as if it were an <code>m</code>.  Useful if you
 want to compose and create some isolated <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s with access to an
 underlying environment, but not your entire program.</p><p>Also just simply useful as a convenient way to use an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> over
 <code>Reader</code> with <code><a href="Control-Auto.html#v:stepAuto">stepAuto</a></code> and friends.</p><p>When used with <code><code>Reader</code> r</code>, it turns an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> (<code>Reader</code> r) a b</code> into
 an <code><code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> (a, r) b</code>.</p></div></div><div class="top"><p class="src"><a id="v:sealReader" class="def">sealReader</a> <a href="src/Control.Auto.Effects.html#sealReader" class="link">Source</a> <a href="#v:sealReader" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../cereal-0.5.1.0/Data-Serialize.html#t:Serialize">Serialize</a> r)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over <code>Reader</code></p></td></tr><tr><td class="src">-&gt; r</td><td class="doc"><p>the perpetual environment</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Takes an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that operates under the context of a read-only
 environment, an environment value, and turns it into a normal <code><a href="Control-Auto.html#t:Auto">Auto</a></code>
 that always &quot;sees&quot; that value when it asks for one.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a   = effect ask :: Auto (Reader b) a b
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let rdr = streamAuto' a [1..5] :: Reader b [b]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runReader rdr &quot;hey&quot;
</code></strong>[&quot;hey&quot;, &quot;hey&quot;, &quot;hey&quot;, &quot;hey&quot;, &quot;hey&quot;]
</pre><p>Useful if you wanted to use it inside/composed with an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that does
 not have a global environment:</p><pre>bar :: Auto' Int String
bar = proc x -&gt; do
    hey &lt;- sealReader (effect ask) &quot;hey&quot; -&lt; ()
    id -&lt; hey ++ show x
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' bar [1..5]
</code></strong>[&quot;hey1&quot;, &quot;hey2&quot;, &quot;hey3&quot;, &quot;hey4&quot;, &quot;hey5&quot;]
</pre><p>Note that this version serializes the given <code>r</code> environment, so that
 every time the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> is reloaded/resumed, it resumes with the
 originally given <code>r</code> environment, ignoring whatever <code>r</code> is given to it
 when trying to resume it.  If this is not the behavior you want, use
 <code><a href="Control-Auto-Effects.html#v:sealReader_">sealReader_</a></code>.</p><p><code>Reader</code> is convenient because it allows you to &quot;chain&quot; and &quot;compose&quot;
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s with a common environment, instead of explicitly passing in
 values every time.  For a convenient way of generating <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s under
 <code><a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a></code>, and also for some motivating examples, see <code><a href="Control-Auto-Effects.html#v:readerA">readerA</a></code> and
 <code><a href="Control-Auto-Effects.html#v:runReaderA">runReaderA</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:sealReader_" class="def">sealReader_</a> <a href="src/Control.Auto.Effects.html#sealReader_" class="link">Source</a> <a href="#v:sealReader_" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over <code>Reader</code></p></td></tr><tr><td class="src">-&gt; r</td><td class="doc"><p>the perpetual environment</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto-Effects.html#v:sealReader">sealReader</a></code>.  Does not
 serialize/reload the <code>r</code> environment, so that whenever you &quot;resume&quot; the
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, it uses the new <code>r</code> given when you are trying to resume, instead
 of loading the originally given one.</p><p><em>DOES</em> serialize the actual <code><a href="Control-Auto.html#t:Auto">Auto</a></code>!</p></div></div><div class="top"><p class="src"><a id="v:readerA" class="def">readerA</a> <a href="src/Control.Auto.Effects.html#readerA" class="link">Source</a> <a href="#v:readerA" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (a, r) b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> receiving an environment.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over an environment.</p></td></tr></table></div><div class="doc"><p>Transforms an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> on two input streams ( a &quot;normal input&quot; stream
 <code>a</code> and an &quot;environment input stream&quot; <code>r</code>) into an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> on one input
 stream <code>a</code> with an underlying environment <code>r</code> through a <code>Reader</code> monad.</p><p>Why is this useful?  Well, if you have several <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s that all take in
 a side <code>r</code> stream, and you want to convey that every single one should
 get the <em>same</em> <code>r</code> at every step, you can instead have all of them pull
 from a common underlying global environment.</p><p>Note: Function is the inverse of <code><a href="Control-Auto-Effects.html#v:runReaderA">runReaderA</a></code>:</p><pre><code><a href="Control-Auto-Effects.html#v:readerA">readerA</a></code> . <code><a href="Control-Auto-Effects.html#v:runReaderA">runReaderA</a></code> == <code><a href="../base-4.9.0.0/Control-Category.html#v:id">id</a></code>
<code><a href="Control-Auto-Effects.html#v:runReaderA">runReaderA</a></code> . <code><a href="Control-Auto-Effects.html#v:readerA">readerA</a></code> == <code><a href="../base-4.9.0.0/Control-Category.html#v:id">id</a></code>
</pre></div></div><h3 id="g:9">Sealing from sources</h3><div class="top"><p class="src"><a id="v:sealReaderMVar" class="def">sealReaderMVar</a> <a href="src/Control.Auto.Effects.html#sealReaderMVar" class="link">Source</a> <a href="#v:sealReaderMVar" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over <code>Reader</code></p></td></tr><tr><td class="src">-&gt; <a href="../base-4.9.0.0/Control-Concurrent-MVar.html#t:MVar">MVar</a> r</td><td class="doc"><p><code><a href="../base-4.9.0.0/Control-Concurrent-MVar.html#t:MVar">MVar</a></code> containing an <code>r</code> for every step</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Takes an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that operates under the context of a read-only
 environment, an environment value, and turns it into a normal <code><a href="Control-Auto.html#t:Auto">Auto</a></code>
 that always gets its environment value from an <code><a href="../base-4.9.0.0/Control-Concurrent-MVar.html#t:MVar">MVar</a></code>.</p><p>This allows for &quot;hot swapping&quot; configurations.  If your whole program
 runs under a configuration data structure as the environment, you can
 load the configuration data to the <code><a href="../base-4.9.0.0/Control-Concurrent-MVar.html#t:MVar">MVar</a></code> and then &quot;hot swap&quot; it out by
 just changing the value in the <code><a href="../base-4.9.0.0/Control-Concurrent-MVar.html#t:MVar">MVar</a></code> from a different thread.</p><p>Note that this will block on every &quot;step&quot; until the <code><a href="../base-4.9.0.0/Control-Concurrent-MVar.html#t:MVar">MVar</a></code> is
 readable<em>full</em>has a value, if it does not.</p><p>Basically a disciplined wrapper/usage over <code><a href="Control-Auto-Effects.html#v:sealReaderM">sealReaderM</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:sealReaderM" class="def">sealReaderM</a> <a href="src/Control.Auto.Effects.html#sealReaderM" class="link">Source</a> <a href="#v:sealReaderM" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over <code>Reader</code></p></td></tr><tr><td class="src">-&gt; m r</td><td class="doc"><p>action to draw new <code>r</code> at every step</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Takes an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that operates under the context of a read-only
 environment, an environment value, and turns it into a normal <code><a href="Control-Auto.html#t:Auto">Auto</a></code>
 that always gets its environment value by executing an action every step
 in the underlying monad.</p><p>This can be abused to write unmaintainble code really fast if you don't
 use it in a disciplined way.   One possible usage is to query a database
 in <code><a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a></code> (or <code><a href="../base-4.9.0.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a></code>) for a value at every step.  If you're using
 underlying global state, you can use it to query that too, with <code><a href="../cereal-0.5.1.0/Data-Serialize.html#v:get">get</a></code> or
 <code>gets</code>.  You could even use <code><a href="../base-4.9.0.0/System-IO.html#v:getLine">getLine</a></code>, maybe, to get the result from
 standard input at every step.</p><p>One disciplined wrapper around this is <code><a href="Control-Auto-Effects.html#v:sealReaderMVar">sealReaderMVar</a></code>, where the
 environment at every step comes from reading an <code><a href="../base-4.9.0.0/Control-Concurrent-MVar.html#t:MVar">MVar</a></code>.  This can be
 used to &quot;hot swap&quot; configuration files.</p></div></div><h2 id="g:10"><code><a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a></code></h2><div class="doc"><p><code><a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a></code> gives you a shared &quot;sink&quot; to dump data into.  You can dump in
 data by using</p><pre><code><a href="Control-Auto-Effects.html#v:arrM">arrM</a></code> <code>tell</code> :: <code>MonadWriter</code> w m =&gt; <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m w ()
<code><a href="Control-Auto-Effects.html#v:effect">effect</a></code> . <code>tell</code> :: <code>MonadWriter</code> w m =&gt; w -&gt; <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a ()
</pre><pre>foo :: Auto (Writer (Sum Int)) Int Int
foo = effect (tell 1) *&gt; effect (tell 1) *&gt; sumFrom 0
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let fooWriter = streamAuto foo
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runWriter $ fooWriter [1..10]
</code></strong>([1,3,6,10,15,21,28,36,45,55], Sum 20)
</pre><p><code>foo</code> increments an underlying counter twice every time it is stepped;
 its &quot;result&quot; is just the cumulative sum of the inputs.</p><p>If you have several <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s that all output some &quot;side-channel&quot; value
 that is just all accumulated at the end, and you want to implicitly
 accumulate it all, you can just have them all dump into an underlying
 <code>Writer</code> sink instead of aggregating them explicitly.</p><p>For example:</p><pre>foo :: Auto m Int (Bool, [String])
bar :: Auto m Bool (Int, [String])
baz :: Auto m Bool (String, [String])
</pre><p>Each of these has a &quot;logging output&quot; that should be aggregated all at
 the end.</p><p>One way you can do this is by using an explicit proc block:</p><pre>full :: Auto m Int (String, [String])
full = proc inp -&gt; do
    x &lt;- sumFrom 0 -&lt; inp
    (fo, foW) &lt;- foo -&lt; inp + x
    (br, brW) &lt;- bar -&lt; fo
    (bz, bzW) &lt;- baz -&lt; fo
    id -<a href="(replicate">br bz, foW &lt;</a> brW &lt;&gt; bzW)
</pre><p>Or, you can handle the extra output implicitly using <code><a href="Control-Auto-Effects.html#v:writerA">writerA</a></code>:</p><pre>fullW :: Auto (WriterT [String] m) Int String
fullW = proc inp -&gt; do
    x  &lt;- sumFrom 0   -&lt; inp
    fo &lt;- writerA foo -&lt; inp + x
    br &lt;- writerA bar -&lt; fo
    bz &lt;- writerA baz -&lt; fo
    id -&lt; replicate br bz
</pre><p>Note that <code><code>sumFrom</code> 0</code> still works the same and doesn't interfere,
 logging nothing.</p><p>You can recover the original <code>full</code> with <code><a href="Control-Auto-Effects.html#v:runWriterA">runWriterA</a></code>, which
 &quot;unwraps&quot; the underlying <code>Writer</code>:</p><pre>full' :: Auto m Int (String, [String])
full' = runWriterA fullW
</pre></div><div class="top"><p class="src"><a id="v:writerA" class="def">writerA</a> <a href="src/Control.Auto.Effects.html#writerA" class="link">Source</a> <a href="#v:writerA" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../base-4.9.0.0/Data-Monoid.html#t:Monoid">Monoid</a> w)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a (b, w)</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> with a &quot;normal&quot; output
     stream <code>b</code>s and a &quot;logging&quot;
     stream <code>w</code>s</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a> w m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> under an underlying
     <code><a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a></code>, logging <code>w</code>s</p></td></tr></table></div><div class="doc"><p>Transforms an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> on with two output streams (a &quot;normal output
 stream&quot; <code>b</code>, and a &quot;logging output stream&quot; <code>w</code>) into an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> with just
 one output stream <code>a</code>, funneling the logging stream <code>w</code> into an
 underlying <code><a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a></code> monad.</p><p>Note: Function is the inverse of <code><a href="Control-Auto-Effects.html#v:runWriterA">runWriterA</a></code>:</p><pre><code><a href="Control-Auto-Effects.html#v:writerA">writerA</a></code> . <code><a href="Control-Auto-Effects.html#v:runWriterA">runWriterA</a></code> == <code><a href="../base-4.9.0.0/Control-Category.html#v:id">id</a></code>
<code><a href="Control-Auto-Effects.html#v:runWriterA">runWriterA</a></code> . <code><a href="Control-Auto-Effects.html#v:writerA">writerA</a></code> == <code><a href="../base-4.9.0.0/Control-Category.html#v:id">id</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:runWriterA" class="def">runWriterA</a> :: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../base-4.9.0.0/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a> w m) a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a (b, w) <a href="src/Control.Auto.Effects.html#runWriterA" class="link">Source</a> <a href="#v:runWriterA" class="selflink">#</a></p><div class="doc"><p><a href="Unrolls.html">Unrolls</a> the underlying <code><code><a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a></code> w m</code> <code><a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a></code>, so that an <code><a href="Control-Auto.html#t:Auto">Auto</a></code>
 that takes in a stream of <code>a</code> and outputs a stream of <code>b</code> will now
 output a stream <code>(b, w)</code>, where <code>w</code> is the &quot;new log&quot; of the underlying
 <code>Writer</code> at every step.</p><p>Examples:</p><pre>foo :: Auto (Writer (Sum Int)) Int Int
foo = effect (tell 1) *&gt; effect (tell 1) *&gt; sumFrom 0
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let fooWriter = streamAuto foo
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runWriter $ fooWriter [1..10]
</code></strong>([1,3,6,10,15,21,28,36,45,55], Sum 20)
</pre><p><code>foo</code> increments an underlying counter twice every time it is stepped;
 its &quot;result&quot; is just the cumulative sum of the inputs.</p><p>When we &quot;stream&quot; it, we get a <code>[Int] -&gt; <code>Writer</code> (Sum Int)
 [Int]</code>...which we can give an input list and <code>runWriter</code> it, getting
 a list of outputs and a &quot;final accumulator state&quot; of 10, for stepping it
 ten times.</p><p>However, if we use <code><a href="Control-Auto-Effects.html#v:runWriterA">runWriterA</a></code> before streaming it, we get:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let fooW = runWriterA foo
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' fooW [1..10]
</code></strong>[ (1 , Sum 2), (3 , Sum 2), (6 , Sum 2)
, (10, Sum 2), (15, Sum 2), (21, Sum 2), -- ...
</pre><p>Instead of accumulating it between steps, we get to &quot;catch&quot; the <code>Writer</code>
 output at every individual step.</p><p>We can write and compose our own <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s under <code>Writer</code>, using the
 convenience of a shared accumulator, and then &quot;use them&quot; with other
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s:</p><pre>bar :: Auto' Int Int
bar = proc x -&gt; do
  (y, w) &lt;- runWriterA foo -&lt; x
  blah &lt;- blah -&lt; w
</pre><p>And now you have access to the underlying accumulator of <code>foo</code> to
 access.  There, <code>w</code> represents the continually updating accumulator
 under <code>foo</code>, and will be different/growing at every &quot;step&quot;.</p><p>For a convenient way to <em>create</em> an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> under <code><a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a></code>, see
 <code><a href="Control-Auto-Effects.html#v:writerA">writerA</a></code>.</p></div></div><h2 id="g:11"><code><a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a></code></h2><div class="doc"><p>An underlying <code><a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a></code> gives you access to a global, mutable state.</p><p>At first this might be seem a little silly.  We went through all this
 trouble to avoid the headache of global mutable state, and now we add ti
 back in?</p><p>One nice usage is an underlying entropy generator (you can deal with
 this more explicitly with <code>sealRandom</code> in
 <a href="Control-Auto-Process-Random.html">Control.Auto.Process.Random</a>), or maybe some underlying pool that every
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code> shares that would be a big headache to thread manually.</p><p>The main benefit here is that, using tools like <code><a href="Control-Auto-Effects.html#v:sealState">sealState</a></code> and
 <code><a href="Control-Auto-Effects.html#v:runStateA">runStateA</a></code>, we can <em>isolate</em> the portion of our program that takes
 advantage of shared mutable state, and <em>seal off</em> or only give that part
 access to the state... and nobody else.</p><p>Anyways, it should go without saying that you should think really long
 and really hard before adding in global state to your program.  It is
 almost always better to use principles of local statefulness and
 denotative composition to achieve what you want.  Relying on this
 construct might lead to very unmaintainable code, and definitely code
 that is much more difficult to reason with.  I suggest trying to find
 another solution first in all cases!</p></div><div class="top"><p class="src"><a id="v:sealState" class="def">sealState</a> <a href="src/Control.Auto.Effects.html#sealState" class="link">Source</a> <a href="#v:sealState" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../cereal-0.5.1.0/Data-Serialize.html#t:Serialize">Serialize</a> s)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over <code>State</code></p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Takes an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that works with underlying global, mutable state, and
 &quot;seals off the state&quot; from the outside world.</p><p>An 'Auto (StateT s m) a b' maps a stream of <code>a</code> to a stream of <code>b</code>, but
 does so in the context of requiring an initial <code>s</code> to start, and
 outputting a modified <code>s</code>.</p><p>Consider this example <code>State</code> <code><a href="Control-Auto.html#t:Auto">Auto</a></code>:</p><pre>foo :: Auto (State Int) Int Int
foo = proc x -&gt; do
    execB (modify (+1)) . emitOn odd  -&lt; x
    execB (modify (*2)) . emitOn even -&lt; x
    st   &lt;- effect get -&lt; ()
    sumX &lt;- sumFrom 0  -&lt; x
    id    -&lt; sumX + st
</pre><p>On every output, the &quot;global&quot; state is incremented if the input is odd
 and doubled if the input is even.  The stream <code>st</code> is always the value
 of the global state at that point.  <code>sumX</code> is the cumulative sum of the
 inputs.  The final result is the sum of the value of the global state
 and the cumulative sum.</p><p>In writing like this, you lose some of the denotative properties because
 you are working with a global state that updates at every output.  You
 have some benefit of now being able to work with global state, if that's
 what you wanted I guess.</p><p>To &quot;run&quot; it, you could use <code>streamAuto</code> to get a <code><code>State</code> Int Int</code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let st = streamAuto foo [1..10] :: State Int Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runState st 5
</code></strong>([  7, 15, 19, 36, 42, 75, 83,136,156,277], 222)
</pre><p>(The starting state is 5 and the ending state after all of that is 222)</p><p>However, writing your entire program with global state is a bad bad
 idea!  So, how can you get the &quot;benefits&quot; of having small parts like
 <code>foo</code> be written using <code>State</code>, and being able to use it in a program
 with no global state?</p><p>Using <code><a href="Control-Auto-Effects.html#v:sealState">sealState</a></code>!  Write the part of your program that would like
 shared global state with <code>State</code>...and compose it with the rest as if it
 doesn't, locking it away!</p><pre>sealState       :: Auto (State s) a b -&gt; s -&gt; Auto' a b
sealState foo 5 :: Auto' Int Int
</pre><pre>bar :: Auto' Int (Int, String)
bar = proc x -&gt; do
    food &lt;- sealState foo 5 -&lt; x
    id -&lt; (food, show x)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' bar [1..10]
</code></strong>[ (7, &quot;1&quot;), (15, &quot;2&quot;), (19, &quot;3&quot;), (36, &quot;4&quot;), (42, &quot;5&quot;), (75, &quot;6&quot;) ...
</pre><p>We say that <code><code><a href="Control-Auto-Effects.html#v:sealState">sealState</a></code> f s0</code> takes an input stream, and the output
 stream is the result of running the stream through <code>f</code>, first with an
 initial state of <code>s0</code>, and afterwards with each next updated state.</p><p>If you wanted to &quot;seal&quot; the state and have it be untouchable to the
 outside world, yet still have a way to &quot;monitor&quot;/&quot;view&quot; it, you can
 modify the original <code><a href="Control-Auto.html#t:Auto">Auto</a></code> using <code>&amp;&amp;&amp;</code>, <code><a href="Control-Auto-Effects.html#v:effect">effect</a></code>, and 'get to get
 a &quot;view&quot; of the state:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sealState (foo &amp;&amp;&amp; effect get) 5) [1..10]
</code></strong>[(7,6),(15,12),(19,13),(36,26),(42,27),(75,54),(83,55),(146,110),(156,111),(277,222)]
</pre><p>Now, every output of <code><code><a href="Control-Auto-Effects.html#v:sealState">sealState</a></code> foo 5</code> is tuplied up with a peek of
 its state at that point.</p><p>For a convenient way of &quot;creating&quot; an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> under <code><a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a></code> in the first
 place, see <code><a href="Control-Auto-Effects.html#v:stateA">stateA</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:sealState_" class="def">sealState_</a> <a href="src/Control.Auto.Effects.html#sealState_" class="link">Source</a> <a href="#v:sealState_" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over <code>State</code></p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto-Effects.html#v:sealState">sealState</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:runStateA" class="def">runStateA</a> <a href="src/Control.Auto.Effects.html#runStateA" class="link">Source</a> <a href="#v:runStateA" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over a state transformer</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (a, s) (b, s)</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> whose inputs and outputs are a state transformer</p></td></tr></table></div><div class="doc"><p><a href="Unrolls.html">Unrolls</a> the underlying <code><a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a></code> of an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> into an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that
 takes in an input state every turn (in addition to the normal input) and
 outputs, along with the original result, the modified state.</p><p>So now you can use any <code><code><a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a></code> s m</code> as if it were an <code>m</code>.  Useful if
 you want to compose and create some isolated <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s with access to an
 underlying state, but not your entire program.</p><p>Also just simply useful as a convenient way to use an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> over
 <code>State</code> with <code><a href="Control-Auto.html#v:stepAuto">stepAuto</a></code> and friends.</p><p>When used with <code><code>State</code> s</code>, it turns an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> (<code>State</code> s) a b</code> into an
 <code><code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> (a, s) (b, s)</code>.</p><p>For a convenient way to &quot;generate&quot; an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> <code><a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a></code>, see <code><a href="Control-Auto-Effects.html#v:stateA">stateA</a></code></p></div></div><div class="top"><p class="src"><a id="v:stateA" class="def">stateA</a> <a href="src/Control.Auto.Effects.html#stateA" class="link">Source</a> <a href="#v:stateA" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (a, s) (b, s)</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> whose inputs and outputs are a
     state transformer</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m) a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over a state transformer</p></td></tr></table></div><div class="doc"><p>Transforms an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> with two input streams and two output streams (a
 &quot;normal&quot; input <code>a</code> output <code>b</code> stream, and a &quot;state transforming&quot;
 side-stream taking in <code>s</code> and outputting <code>s</code>), abstracts away the <code>s</code>
 stream as a modifcation to an underyling <code><a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a></code> monad.  That is, your
 normal inputs and outputs are now your <em>only</em> inputs and outputs, and
 your input <code>s</code> comes from the underlying global mutable state, and the
 output <code>s</code> goes to update the underlying global mutable state.</p><p>For example, you might have a bunch of <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s that interact with
 a global mutable state:</p><pre>foo :: Auto (StateT Double m) Int Bool
bar :: Auto (StateT Double m) Bool Int
baz :: Auto (StateT Double m) Bool String
</pre><p>Where <code>foo</code>, <code>bar</code>, and <code>baz</code> all interact with global mutable state.
 You'd use them like this:</p><pre>full :: Auto (StateT Double m) Int String
full = proc inp -&gt; do
    fo &lt;- foo -&lt; inp
    br &lt;- bar -&lt; fo
    bz &lt;- baz -&lt; fo
    id -&lt; replicae br bz
</pre><p><code><a href="Control-Auto-Effects.html#v:stateA">stateA</a></code> allows you generate a new <code>Auto</code> under <code><a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a></code>:</p><pre>thing :: Auto m (Int, Double) (Bool, Double)
stateA thing :: Auto (StateT Double m) Int Bool
</pre><p>So now the two side-channels are interpreted as working with the global
 state:</p><pre>full :: Auto (StateT Double m) Int String
full = proc inp -&gt; do
    fo &lt;- foo          -&lt; inp
    tg &lt;- stateA thing -&lt; inp
    br &lt;- bar          -&lt; fo || tg
    bz &lt;- baz          -&lt; fo &amp;&amp; tg
    id -&lt; replicae br bz
</pre><p>You can then &quot;seal it all up&quot; in the end with an initial state, that
 keeps on re-running itself with the resulting state every time:</p><pre>full' :: Double -&gt; Auto m Int String
full' = sealState full
</pre><p>Admittedly, this is a bit more esoteric and dangerous (programming with
 global state? what?) than its components <code><a href="Control-Auto-Effects.html#v:readerA">readerA</a></code> and <code><a href="Control-Auto-Effects.html#v:writerA">writerA</a></code>;
 I don't actually recommend you programming with global state unless it
 really is the best solution to your problem...it tends to encourage
 imperative code/loops, and &quot;unreasonable&quot; and manageable code.  See
 documentation for <code>sealStateA</code> for best practices.  Basically every bad
 thing that comes with global mutable state.  But, this is provided here
 for sake of completeness with <code><a href="Control-Auto-Effects.html#v:readerA">readerA</a></code> and <code><a href="Control-Auto-Effects.html#v:writerA">writerA</a></code>.</p><p>Note: function is the inverse of <code>runstateA</code>.</p><pre><code><a href="Control-Auto-Effects.html#v:stateA">stateA</a></code> . <code><a href="Control-Auto-Effects.html#v:runStateA">runStateA</a></code> == <code><a href="../base-4.9.0.0/Control-Category.html#v:id">id</a></code>
<code><a href="Control-Auto-Effects.html#v:runStateA">runStateA</a></code> . <code><a href="Control-Auto-Effects.html#v:stateA">stateA</a></code> == <code><a href="../base-4.9.0.0/Control-Category.html#v:id">id</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:accumA" class="def">accumA</a> <a href="src/Control.Auto.Effects.html#accumA" class="link">Source</a> <a href="#v:accumA" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (a, s) s</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> taking inputs and states and
     returning updated states</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m) a s</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> over a state transformer</p></td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto-Effects.html#v:stateA">stateA</a></code>, but assumes that the output is the modified state.</p></div></div><h2 id="g:12"><code><a href="../base-4.9.0.0/Data-Traversable.html#t:Traversable">Traversable</a></code></h2><div class="top"><p class="src"><a id="v:runTraversableA" class="def">runTraversableA</a> <a href="src/Control.Auto.Effects.html#runTraversableA" class="link">Source</a> <a href="#v:runTraversableA" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a> f, <a href="../base-4.9.0.0/Data-Traversable.html#t:Traversable">Traversable</a> f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> f a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> run over traversable structure</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a (f b)</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> returning traversable structure</p></td></tr></table></div><div class="doc"><p><a href="Unrolls.html">Unrolls</a> the underlying <code><a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a></code> of an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> if it happens to be
 <code><a href="../base-4.9.0.0/Data-Traversable.html#t:Traversable">Traversable</a></code> ('[]', <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code>, etc.).</p><p>It can turn, for example, an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> [] a b</code> into an <code><code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a [b]</code>; it
 collects all of the results together.  Or an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> a b</code> into
 an <code><code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a (<code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> b)</code>.</p><p>This might be useful if you want to make some sort of &quot;underlying
 inhibiting&quot; <code><a href="Control-Auto.html#t:Auto">Auto</a></code> where the entire computation might just end up being
 <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Nothing">Nothing</a></code> in the end.  With this, you can turn that
 possibly-catastrophically-failing <code><a href="Control-Auto.html#t:Auto">Auto</a></code> (with an underlying <code><a href="../base-4.9.0.0/Control-Monad.html#t:Monad">Monad</a></code> of
 <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code>) into a normal <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, and use it as a normal <code><a href="Control-Auto.html#t:Auto">Auto</a></code> in
 composition with other <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s...returning <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> if your computation
 succeeded.</p><pre><code><a href="Control-Auto-Effects.html#v:runTraversableA">runTraversableA</a></code> :: <code><a href="Control-Auto.html#t:Auto">Auto</a></code> <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> a b -&gt; <code>Interval'</code> a b
</pre><pre>foo :: Auto Maybe Int Int
foo = arrM $ x -&gt; if even x then Just (x <code><a href="../base-4.9.0.0/Prelude.html#v:div">div</a></code> 2) else Nothing

bar :: Auto Maybe Int Int
bar = arrM Just
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto foo [2,4,6,7]
</code></strong>Nothing
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (runTraversableA foo) [2,4,6,7]
</code></strong>[Just 1, Just 2, Just 3, Nothing]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto (foo &amp;&amp;&amp; bar) [2,4,6]
</code></strong>Just [(1, 2),(2, 4),(3, 6)]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto (foo &amp;&amp;&amp; bar) [2,4,6,7]
</code></strong>Nothing
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (runTraversableA foo &lt;|?&gt; runTraversableA bar) [2,4,6,7]
</code></strong>[Just 1, Just 2, Just 3, Just 7]
</pre></div></div><h2 id="g:13"><code><a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a></code></h2><div class="top"><p class="src"><a id="v:catchA" class="def">catchA</a> <a href="src/Control.Auto.Effects.html#catchA" class="link">Source</a> <a href="#v:catchA" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.9.0.0/Control-Exception-Base.html#t:Exception">Exception</a> e</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> <a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a> a b</td><td class="doc"><p>Auto over IO, expecting an
     exception of a secific type.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> <a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a> a (<a href="../base-4.9.0.0/Data-Either.html#t:Either">Either</a> e b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Wraps a &quot;try&quot; over an underlying <code><a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a></code> monad; if the Auto encounters a
 runtime exception while trying to &quot;step&quot; itself, it'll output a <code><a href="../base-4.9.0.0/Data-Either.html#v:Left">Left</a></code>
 with the <code><a href="../base-4.9.0.0/Control-Exception-Base.html#t:Exception">Exception</a></code>.  Otherwise, will output <code>left</code>.</p><p>Note that you have to explicitly specify the type of the exceptions you
 are catching; see <a href="../base-4.9.0.0/Control-Exception.html">Control.Exception</a> documentation for more details.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.2</p></div></body></html>