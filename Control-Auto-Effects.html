<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Auto.Effects</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Auto-Effects.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">auto-0.2.0.2: Denotative, locally stateful programming DSL &amp; platform</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Justin Le 2015</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>justin@jle.im</td></tr><tr><th>Stability</th><td>unstable</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Auto.Effects</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Running effects</a><ul><li><a href="#g:2">Continually</a></li><li><a href="#g:3">From inputs</a></li><li><a href="#g:4">On <code>Blip</code>s</a></li></ul></li><li><a href="#g:5">One-time effects</a></li><li><a href="#g:6">Manipulating underlying monads</a><ul><li><a href="#g:7">&quot;Sealing off&quot; monadic <code>Auto</code>s</a></li><li><a href="#g:8"><a href="Unrolling.html">Unrolling</a>/&quot;reifying&quot; monadic <code>Auto</code>s</a></li><li><a href="#g:9">Hoists</a></li><li><a href="#g:10">Working with IO</a></li><li><a href="#g:11">Constructing monadic <code>Auto</code>s from other monads</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module exports the preferred ways of interacting with the
 underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> type, including accessing, executing,
 and manipulating such effects.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:arrM">arrM</a> ::  (a -&gt; m b) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:effect">effect</a> ::  m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:effects">effects</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (m a) a</li><li class="src short"><a href="#v:arrMB">arrMB</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> b)</li><li class="src short"><a href="#v:effectB">effectB</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> b)</li><li class="src short"><a href="#v:execB">execB</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> a)</li><li class="src short"><a href="#v:cache">cache</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:execOnce">execOnce</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a ()</li><li class="src short"><a href="#v:cache_">cache_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:execOnce_">execOnce_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a ()</li><li class="src short"><a href="#v:sealState">sealState</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s) =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a b -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:sealState_">sealState_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a b -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:sealReader">sealReader</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> r) =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Reader.html#t:ReaderT">ReaderT</a> r m) a b -&gt; r -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:sealReader_">sealReader_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Reader.html#t:ReaderT">ReaderT</a> r m) a b -&gt; r -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:runStateA">runStateA</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (a, s) (b, s)</li><li class="src short"><a href="#v:runReaderA">runReaderA</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Reader.html#t:ReaderT">ReaderT</a> r m) a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (a, r) b</li><li class="src short"><a href="#v:runWriterA">runWriterA</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Writer-Lazy.html#t:WriterT">WriterT</a> w m) a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a (b, w)</li><li class="src short"><a href="#v:runTraversableA">runTraversableA</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> f, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Traversable.html#t:Traversable">Traversable</a> f) =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> f a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a (f b)</li><li class="src short"><a href="#v:hoistA">hoistA</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m') =&gt; (<span class="keyword">forall</span> c. m c -&gt; m' c) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m' a b</li><li class="src short"><a href="#v:generalizeA">generalizeA</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:catchA">catchA</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Exception-Base.html#t:Exception">Exception</a> e =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> a (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> e b)</li><li class="src short"><a href="#v:fromState">fromState</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; (a -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m b) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:fromState_">fromState_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m b) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li></ul></div><div id="interface"><h1 id="g:1">Running effects</h1><h2 id="g:2">Continually</h2><div class="top"><p class="src"><a name="v:arrM" class="def">arrM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; m b)</td><td class="doc"><p>monadic function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Applies the given &quot;monadic function&quot; (function returning a monadic
 action) to every incoming item; the result is the result of executing
 the action returned.</p><p>Note that this essentially lifts a &quot;Kleisli arrow&quot;; it's like <code>arr</code>, but
 for &quot;monadic functions&quot; instead of normal functions:</p><pre>arr  :: (a -&gt; b)   -&gt; Auto m a b
arrM :: (a -&gt; m b) -&gt; Auto m a b
</pre><pre>arrM f . arrM g == arrM (f &lt;=&lt; g)</pre><p>One neat trick you can do is that you can &quot;tag on effects&quot; to a normal
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> by using <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:-42--62-">*&gt;</a></code> from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html">Control.Applicative</a>.  For example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = arrM print *&gt; sumFrom 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys &lt;- streamAuto a [1..5]
</code></strong>1                -- IO output
2
3
4
5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys
</code></strong>[1,3,6,10,15]    -- the result
</pre><p>Here, <code>a</code> behaves &quot;just like&quot; <code><code>sumFrom</code> 0</code>...except, when you step it,
 it prints out to stdout as a side-effect.  We just gave automatic
 stdout logging behavior!</p></div></div><div class="top"><p class="src"><a name="v:effect" class="def">effect</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: m b</td><td class="doc"><p>monadic action to contually execute.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>To get every output, executes the monadic action and returns the
 result as the output.  Always ignores input.</p><p>This is basically like an &quot;effectful&quot; <code><a href="Control-Auto-Generate.html#v:pure">pure</a></code>:</p><pre><code><a href="Control-Auto-Generate.html#v:pure">pure</a></code>   :: b   -&gt; <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b
<code><a href="Control-Auto-Effects.html#v:effect">effect</a></code> :: m b -&gt; <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b
</pre><p>The output of <code><a href="Control-Auto-Generate.html#v:pure">pure</a></code> is always the same, and the output of <code><a href="Control-Auto-Effects.html#v:effect">effect</a></code> is
 always the result of the same monadic action.  Both ignore their inputs.</p><p>Fun times when the underling <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> is, for instance, <code>Reader</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = effect ask    :: Auto (Reader b) a b
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let r = evalAuto a () :: Reader b b
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runReader r &quot;hello&quot;
</code></strong>&quot;hello&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runReader r 100
</code></strong>100
</pre><p>If your underling monad has effects (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a></code>, <code>State</code>, <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code>, <code>Writer</code>,
 etc.), then it might be fun to take advantage of <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:-42--62-">*&gt;</a></code> from
 <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html">Control.Applicative</a> to &quot;tack on&quot; an effect to a normal <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = effect (modify (+1)) *&gt; sumFrom 0 :: Auto (State Int) Int Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let st = streamAuto a [1..10]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (ys, s') = runState st 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys
</code></strong>[1,3,6,10,15,21,28,36,45,55]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s'
</code></strong>10
</pre><p>Out <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> <code>a</code> behaves exactly like <code><code>sumFrom</code> 0</code>, except at each step,
 it also increments the underlying/global state by one.  It is <code><code>sumFrom</code>
 0</code> with an &quot;attached effect&quot;.</p></div></div><h2 id="g:3">From inputs</h2><div class="top"><p class="src"><a name="v:effects" class="def">effects</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (m a) a</p><div class="doc"><p>The input stream is a stream of monadic actions, and the output stream
 is the result of their executions, through executing them.</p></div></div><h2 id="g:4">On <code><a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a></code>s</h2><div class="top"><p class="src"><a name="v:arrMB" class="def">arrMB</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> b)</p><div class="doc"><p>Maps one blip stream to another; replaces every emitted value with the
 result of the monadic function, executing it to get the result.</p></div></div><div class="top"><p class="src"><a name="v:effectB" class="def">effectB</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> b)</p><div class="doc"><p>Maps one blip stream to another; replaces every emitted value with the
 result of a fixed monadic action, run every time an emitted value is
 received.</p></div></div><div class="top"><p class="src"><a name="v:execB" class="def">execB</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> a) (<a href="Control-Auto-Blip-Internal.html#t:Blip">Blip</a> a)</p><div class="doc"><p>Outputs the identical blip stream that is received; however, every
 time it sees an emitted value, executes the given monadic action on the
 side.</p></div></div><h1 id="g:5">One-time effects</h1><div class="top"><p class="src"><a name="v:cache" class="def">cache</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m b</td><td class="doc"><p>monadic action to execute and use the result of</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The very first output executes a monadic action and uses the result as
 the output, ignoring all input.  From then on, it persistently outputs
 that first result.</p><p>Like <code><a href="Control-Auto-Effects.html#v:execOnce">execOnce</a></code>, except outputs the result of the action instead of
 ignoring it.</p><p>Useful for loading resources in IO on the &quot;first step&quot;, like
 a word list:</p><pre>dictionary :: Auto IO a [String]
dictionary = cache (lines <a href="$">$</a> readFile &quot;wordlist.txt&quot;)
</pre></div></div><div class="top"><p class="src"><a name="v:execOnce" class="def">execOnce</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m b</td><td class="doc"><p>monadic action to execute; result discared</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Always outputs '()', but when asked for the first output, executes the
 given monadic action.</p><p>Pretty much like <code><a href="Control-Auto-Effects.html#v:cache">cache</a></code>, but always outputs '()'.</p></div></div><div class="top"><p class="src"><a name="v:cache_" class="def">cache_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m b</td><td class="doc"><p>monadic action to execute and use the result of</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resumable/non-serializable version of <code><a href="Control-Auto-Effects.html#v:cache">cache</a></code>.  Every time the
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> is deserialized/reloaded, it re-executes the action to retrieve
 the result again.</p><p>Useful in cases where you want to &quot;re-load&quot; an expensive resource on
 every startup, instead of saving it to in the save states.</p><pre>dictionary :: Auto IO a [String]
dictionary = cache_ (lines <a href="$">$</a> readFile &quot;dictionary.txt&quot;)
</pre></div></div><div class="top"><p class="src"><a name="v:execOnce_" class="def">execOnce_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m b</td><td class="doc"><p>monadic action to execute; result discared</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resumable/non-serializable version of <code><a href="Control-Auto-Effects.html#v:execOnce">execOnce</a></code>.  Every time
 the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> is deserialized/reloaded, the action is re-executed again.</p></div></div><h1 id="g:6">Manipulating underlying monads</h1><h2 id="g:7">&quot;Sealing off&quot; monadic <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s</h2><div class="top"><p class="src"><a name="v:sealState" class="def">sealState</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s) =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a b -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Takes an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that works with underlying global, mutable state, and
 &quot;seals off the state&quot; from the outside world.</p><p>An 'Auto (StateT s m) a b' maps a stream of <code>a</code> to a stream of <code>b</code>, but
 does so in the context of requiring an initial <code>s</code> to start, and
 outputting a modified <code>s</code>.</p><p>Consider this example <code>State</code> <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>:</p><pre>foo :: Auto (State s) Int Int
foo = proc x -&gt; do
    execB (modify (+1)) . emitOn odd  -&lt; x
    execB (modify (*2)) . emitOn even -&lt; x
    st   &lt;- effect get -&lt; ()
    sumX &lt;- sumFrom 0  -&lt; x
    id    -&lt; sumX + st
</pre><p>On every output, the &quot;global&quot; state is incremented if the input is odd
 and doubled if the input is even.  The stream <code>st</code> is always the value
 of the global state at that point.  <code>sumX</code> is the cumulative sum of the
 inputs.  The final result is the sum of the value of the global state
 and the cumulative sum.</p><p>In writing like this, you lose some of the denotative properties because
 you are working with a global state that updates at every output.  You
 have some benefit of now being able to work with global state, if that's
 what you wanted I guess.</p><p>To &quot;run&quot; it, you could use <code>streamAuto</code> to get a <code><code>State</code> Int Int</code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let st = streamAuto foo [1..10] :: State Int Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runState st 5
</code></strong>([  7, 15, 19, 36, 42, 75, 83,136,156,277], 222)
</pre><p>(The starting state is 5 and the ending state after all of that is 222)</p><p>However, writing your entire program with global state is a bad bad
 idea!  So, how can you get the &quot;benefits&quot; of having small parts like
 <code>foo</code> be written using <code>State</code>, and being able to use it in a program
 with no global state?</p><p>Using <code><a href="Control-Auto-Effects.html#v:sealState">sealState</a></code>!</p><pre>sealState       :: Auto (State s) a b -&gt; s -&gt; Auto' a b
sealState foo 5 :: Auto' Int Int
</pre><pre>bar :: Auto' Int (Int, String)
bar = proc x -&gt; do
    food &lt;- sealState foo 5 -&lt; x
    id -&lt; (food, show x)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' bar [1..10]
</code></strong>[ (7, &quot;1&quot;), (15, &quot;2&quot;), (19, &quot;3&quot;), (36, &quot;4&quot;), (42, &quot;5&quot;), (75, &quot;6&quot;) ...
</pre><p>We say that <code><code><a href="Control-Auto-Effects.html#v:sealState">sealState</a></code> f s0</code> takes an input stream, and the output
 stream is the result of running the stream through <code>f</code>, first with an
 initial state of <code>s0</code>, and afterwards with each next updated state.</p></div></div><div class="top"><p class="src"><a name="v:sealState_" class="def">sealState_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a b -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto-Effects.html#v:sealState">sealState</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:sealReader" class="def">sealReader</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> r)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Reader.html#t:ReaderT">ReaderT</a> r m) a b</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> run over <code>Reader</code></p></td></tr><tr><td class="src">-&gt; r</td><td class="doc"><p>the perpetual environment</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Takes an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that operates under the context of a read-only
 environment, an environment value, and turns it into a normal <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>
 that always &quot;sees&quot; that value when it asks for one.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a   = effect ask :: Auto (Reader b) a b
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let rdr = streamAuto' a [1..5] :: Reader b [b]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runReader rdr &quot;hey&quot;
</code></strong>[&quot;hey&quot;, &quot;hey&quot;, &quot;hey&quot;, &quot;hey&quot;, &quot;hey&quot;]
</pre><p>Useful if you wanted to use it inside/composed with an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that does
 not have a global environment:</p><pre>bar :: Auto' Int String
bar = proc x -&gt; do
    hey &lt;- sealReader (effect ask) &quot;hey&quot; -&lt; ()
    id -&lt; hey ++ show x
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' bar [1..5]
</code></strong>[&quot;hey1&quot;, &quot;hey2&quot;, &quot;hey3&quot;, &quot;hey4&quot;, &quot;hey5&quot;]
</pre><p>Note that this version serializes the given <code>r</code> environment, so that
 every time the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> is reloaded/resumed, it resumes with the
 originally given <code>r</code> environment, ignoring whatever <code>r</code> is given to it
 when trying to resume it.  If this is not the behavior you want, use
 <code><a href="Control-Auto-Effects.html#v:sealReader_">sealReader_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:sealReader_" class="def">sealReader_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Reader.html#t:ReaderT">ReaderT</a> r m) a b</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> run over <code>Reader</code></p></td></tr><tr><td class="src">-&gt; r</td><td class="doc"><p>the perpetual environment</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto-Effects.html#v:sealReader">sealReader</a></code>.  Does not
 serialize/reload the <code>r</code> environment, so that whenever you &quot;resume&quot; the
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, it uses the new <code>r</code> given when you are trying to resume, instead
 of loading the originally given one.</p></div></div><h2 id="g:8"><a href="Unrolling.html">Unrolling</a>/&quot;reifying&quot; monadic <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s</h2><div class="top"><p class="src"><a name="v:runStateA" class="def">runStateA</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a b</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> run over a state transformer</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (a, s) (b, s)</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> whose inputs and outputs are a start transformer</p></td></tr></table></div><div class="doc"><p><a href="Unrolls.html">Unrolls</a> the underlying <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a></code> of an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> into an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that
 takes in an input state every turn (in addition to the normal input) and
 outputs, along with the original result, the modified state.</p><p>So now you can use any <code><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a></code> s m</code> as if it were an <code>m</code>.  Useful if
 you want to compose and create some isolated <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s with access to an
 underlying state, but not your entire program.</p><p>Also just simply useful as a convenient way to use an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> over
 <code>State</code> with <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code> and friends.</p><p>When used with <code><code>State</code> s</code>, it turns an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> (<code>State</code> s) a b</code> into an
 <code><code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> (a, s) (b, s)</code>.</p></div></div><div class="top"><p class="src"><a name="v:runReaderA" class="def">runReaderA</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Reader.html#t:ReaderT">ReaderT</a> r m) a b</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> run over global environment</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m (a, r) b</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> receiving environments</p></td></tr></table></div><div class="doc"><p><a href="Unrolls.html">Unrolls</a> the underlying <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Reader.html#t:ReaderT">ReaderT</a></code> of an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> into an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that
 takes in the input &quot;environment&quot; every turn in addition to the normal
 input.</p><p>So you can use any <code><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Reader.html#t:ReaderT">ReaderT</a></code> r m</code> as if it were an <code>m</code>.  Useful if you
 want to compose and create some isolated <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s with access to an
 underlying environment, but not your entire program.</p><p>Also just simply useful as a convenient way to use an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> over
 <code>Reader</code> with <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code> and friends.</p><p>When used with <code><code>Reader</code> r</code>, it turns an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> (<code>Reader</code> r) a b</code> into
 an <code><code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> (a, r) b</code>.</p></div></div><div class="top"><p class="src"><a name="v:runWriterA" class="def">runWriterA</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Writer-Lazy.html#t:WriterT">WriterT</a> w m) a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a (b, w)</p><div class="doc"><p><a href="Unrolls.html">Unrolls</a> the underlying <code><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Writer-Lazy.html#t:WriterT">WriterT</a></code> w m</code> <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code>, so that an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>
 that takes in a stream of <code>a</code> and outputs a stream of <code>b</code> will now
 output a stream <code>(b, w)</code>, where <code>w</code> is the accumulated log of the
 underlying <code>Writer</code> at every step.</p><pre>foo :: Auto (Writer (Sum Int)) Int Int
foo = effect (tell 1) *&gt; effect (tell 1) *&gt; sumFrom 0
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let fooWriter = streamAuto foo
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runWriter $ fooWriter [1..10]
</code></strong>([1,3,6,10,15,21,28,36,45,55], Sum 20)
</pre><p><code>foo</code> increments an underlying counter twice every time it is stepped;
 its &quot;result&quot; is just the cumulative sum of the inputs.</p><p>When we &quot;stream&quot; it, we get a <code>[Int] -&gt; <code>Writer</code> (Sum Int)
 [Int]</code>...which we can give an input list and <code>runWriter</code> it, getting
 a list of outputs and a &quot;final accumulator state&quot; of 10, for stepping it
 ten times.</p><p>We can write and compose own <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s under <code>Writer</code>, using the
 convenience of a shared accumulator, and then &quot;use them&quot; with other
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s:</p><pre>bar :: Auto' Int Int
bar = proc x -&gt; do
  (y, w) &lt;- runWriterA foo -&lt; x
  blah &lt;- blah -&lt; w
</pre><p>And now you have access to the underlying accumulator of <code>foo</code> to
 access.  There, <code>w</code> represents the continually updating accumulator
 under <code>foo</code>, and will be different/growing at every &quot;step&quot;.</p></div></div><div class="top"><p class="src"><a name="v:runTraversableA" class="def">runTraversableA</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> f, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Traversable.html#t:Traversable">Traversable</a> f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> f a b</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> run over traversable structure</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a (f b)</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> returning traversable structure</p></td></tr></table></div><div class="doc"><p><a href="Unrolls.html">Unrolls</a> the underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> of an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> if it happens to be
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Traversable.html#t:Traversable">Traversable</a></code> ('[]', <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code>, etc.).</p><p>It can turn, for example, an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> [] a b</code> into an <code><code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a [b]</code>; it
 collects all of the results together.  Or an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code> a b</code> into
 an <code><code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code> b)</code>.</p><p>This might be useful if you want to make some sort of &quot;underyling
 inhibiting&quot; <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> where the entire computation might just end up being
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Nothing">Nothing</a></code> in the end.  With this, you can turn that
 possibly-catastrophically-failing <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> (with an underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> of
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code>) into a normal <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, and use it as a normal <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> in
 composition with other <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s...returning <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Just">Just</a></code> if your computation
 succeeded.</p></div></div><h2 id="g:9">Hoists</h2><div class="top"><p class="src"><a name="v:hoistA" class="def">hoistA</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m')</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> c. m c -&gt; m' c)</td><td class="doc"><p>monad morphism;
     the natural transformation</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m' a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Swaps out the underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> of an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> using the given monad
 morphism &quot;transforming function&quot;, a natural transformation.</p><p>Basically, given a function to &quot;swap out&quot; any <code>m a</code> with an <code>m' a</code>, it
 swaps out the underlying monad of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.</p><p>This forms a functor, so you rest assured in things like this:</p><pre>hoistA id == id
hoistA f a1 . hoistA f a2 == hoistA f (a1 . a2)
</pre></div></div><div class="top"><p class="src"><a name="v:generalizeA" class="def">generalizeA</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Generalizes an <code><code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a b</code> to an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b'</code> for any <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code>
 <code>m</code>, using <code>hoist</code>.</p></div></div><h2 id="g:10">Working with IO</h2><div class="top"><p class="src"><a name="v:catchA" class="def">catchA</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Exception-Base.html#t:Exception">Exception</a> e</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> a b</td><td class="doc"><p>Auto over IO, expecting an
     exception of a secific type.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> a (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> e b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Wraps a &quot;try&quot; over an underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a></code> monad; if the Auto encounters a
 runtime exception while trying to &quot;step&quot; itself, it'll output a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code>
 with the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Exception-Base.html#t:Exception">Exception</a></code>.  Otherwise, will output <code>left</code>.</p><p>Note that you have to explicitly specify the type of the exceptions you
 are catching; see <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Exception.html">Control.Exception</a> documentation for more details.</p><p>TODO: Possibly look into bringing in some more robust tools from
 monad-control and other industry established error handling routes?
 Also, can we modify an underlying monad with implicit cacting behavior?</p></div></div><h2 id="g:11">Constructing monadic <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s from other monads</h2><div class="top"><p class="src"><a name="v:fromState" class="def">fromState</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; (a -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m b) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Turns an <code>a -&gt; <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a></code> s m b</code> arrow into an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>, when
 given an initial state.  Will continually &quot;run the function&quot;, using the
 state returned from the last run.</p></div></div><div class="top"><p class="src"><a name="v:fromState_" class="def">fromState_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m b) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Non-seralizing/non-resuming version of <code><a href="Control-Auto-Effects.html#v:fromState">fromState</a></code>.  The state isn't
 serialized/resumed, so every time the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> is resumed, it starts over
 with the given initial state.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>