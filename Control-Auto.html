<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Auto</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Auto.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">auto-0.4.1.0: Denotative, locally stateful programming DSL &amp; platform</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Justin Le 2015</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>justin@jle.im</td></tr><tr><th>Stability</th><td>unstable</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Auto</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Types</a><ul><li><a href="#g:2">Auto</a></li><li><a href="#g:3">Misc</a></li></ul></li><li><a href="#g:4">Working with <code>Auto</code></a><ul><li><a href="#g:5">Running</a></li><li><a href="#g:6">Serializing</a></li><li><a href="#g:7">Strictness</a></li><li><a href="#g:8">Internal monad</a></li></ul></li><li><a href="#g:9">Auto constructors</a><ul><li><a href="#g:10">from Accumulators</a><ul><li><a href="#g:11">Result-first</a></li><li><a href="#g:12">Initial accumulator-first</a></li></ul></li><li><a href="#g:13">from State transformers</a></li><li><a href="#g:14">Generators</a><ul><li><a href="#g:15">Effects</a></li><li><a href="#g:16">Iterators</a></li></ul></li></ul></li><li><a href="#g:17">Common <code>Auto</code>s and combinators</a><ul><li><a href="#g:18">Processes</a></li><li><a href="#g:19">Switches</a></li><li><a href="#g:20">Blips</a></li><li><a href="#g:21">Intervals</a></li></ul></li><li><a href="#g:22">Running</a></li><li><a href="#g:23">Re-exports</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module serves as the main entry point for the library; these are
 all basically re-exports.  The re-exports are chosen so you can start
 doing &quot;normal things&quot; off the bat, including all of the types used in
 this library.</p><p>Conspicuously missing are the most of the tools for working with
 <code><a href="Control-Auto.html#t:Interval">Interval</a></code>, <code><a href="Control-Auto.html#t:Blip">Blip</a></code> streams, switches, and the &quot;collection&quot; autos; those
 are all pretty heavy, and if you do end up working with any of those
 tools, simply importing the appropriate module should give you all you
 need.</p><p>See the <a href="https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md">tutorial</a>
 if you need help getting started!</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Auto">Auto</a> m a b</li><li class="src short"><span class="keyword">type</span> <a href="#t:Auto-39-">Auto'</a> = <a href="Control-Auto.html#t:Auto">Auto</a> <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Blip">Blip</a> a</li><li class="src short"><span class="keyword">type</span> <a href="#t:Interval">Interval</a> m a b = <a href="Control-Auto.html#t:Auto">Auto</a> m a (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> b)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Interval-39-">Interval'</a> a b = <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:stepAuto">stepAuto</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; a -&gt; m (b, <a href="Control-Auto.html#t:Auto">Auto</a> m a b)</li><li class="src short"><a href="#v:stepAuto-39-">stepAuto'</a> ::  <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b -&gt; a -&gt; (b, <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b)</li><li class="src short"><a href="#v:evalAuto">evalAuto</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; a -&gt; m b</li><li class="src short"><a href="#v:evalAuto-39-">evalAuto'</a> ::  <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b -&gt; a -&gt; b</li><li class="src short"><a href="#v:streamAuto">streamAuto</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; [a] -&gt; m [b]</li><li class="src short"><a href="#v:streamAuto-39-">streamAuto'</a> ::  <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b -&gt; [a] -&gt; [b]</li><li class="src short"><a href="#v:stepAutoN">stepAutoN</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; a -&gt; m ([b], <a href="Control-Auto.html#t:Auto">Auto</a> m a b)</li><li class="src short"><a href="#v:stepAutoN-39-">stepAutoN'</a> ::  <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b -&gt; a -&gt; ([b], <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b)</li><li class="src short"><a href="#v:encodeAuto">encodeAuto</a> ::  <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:decodeAuto">decodeAuto</a> ::  <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a b)</li><li class="src short"><a href="#v:readAuto">readAuto</a> ::  <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:FilePath">FilePath</a> -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a b))</li><li class="src short"><a href="#v:writeAuto">writeAuto</a> ::  <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:FilePath">FilePath</a> -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:unserialize">unserialize</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:forcer">forcer</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/deepseq-1.3.0.2/Control-DeepSeq.html#t:NFData">NFData</a> a =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:seqer">seqer</a> ::  <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:hoistA">hoistA</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m') =&gt; (<span class="keyword">forall</span> c. m c -&gt; m' c) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m' a b</li><li class="src short"><a href="#v:generalizeA">generalizeA</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:arrM">arrM</a> ::  (a -&gt; m b) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:arrD">arrD</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b =&gt; (a -&gt; b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accum">accum</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accum_">accum_</a> ::  (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumM">accumM</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumM_">accumM_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumD">accumD</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumD_">accumD_</a> ::  (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumMD">accumMD</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumMD_">accumMD_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkState">mkState</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s =&gt; (a -&gt; s -&gt; (b, s)) -&gt; s -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkStateM">mkStateM</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s =&gt; (a -&gt; s -&gt; m (b, s)) -&gt; s -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkState_">mkState_</a> ::  (a -&gt; s -&gt; (b, s)) -&gt; s -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkStateM_">mkStateM_</a> ::  (a -&gt; s -&gt; m (b, s)) -&gt; s -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:effect">effect</a> ::  m b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:iterator">iterator</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b =&gt; (b -&gt; b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:iterator_">iterator_</a> ::  (b -&gt; b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:iteratorM">iteratorM</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; (b -&gt; m b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:iteratorM_">iteratorM_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (b -&gt; m b) -&gt; b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:sumFrom">sumFrom</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a) =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:sumFrom_">sumFrom_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:sumFromD">sumFromD</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a) =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:sumFromD_">sumFromD_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:productFrom">productFrom</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a) =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:productFrom_">productFrom_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:mappender">mappender</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> a) =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:mappender_">mappender_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> a =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:mappendFrom">mappendFrom</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> a) =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:lastVal">lastVal</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:lastVal_">lastVal_</a> ::  a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:delay">delay</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:delay_">delay_</a> ::  a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:count">count</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b) =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:-45--45--62-">(--&gt;)</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:-45--63--62-">(-?&gt;)</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m a b -&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m a b -&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m a b</li><li class="src short"><a href="#v:emitJusts">emitJusts</a> ::  (a -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> b) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a (<a href="Control-Auto.html#t:Blip">Blip</a> b)</li><li class="src short"><a href="#v:emitOn">emitOn</a> ::  (a -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a (<a href="Control-Auto.html#t:Blip">Blip</a> a)</li><li class="src short"><a href="#v:fromBlips">fromBlips</a> ::  a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto.html#t:Blip">Blip</a> a) a</li><li class="src short"><a href="#v:fromBlipsWith">fromBlipsWith</a> ::  b -&gt; (a -&gt; b) -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto.html#t:Blip">Blip</a> a) b</li><li class="src short"><a href="#v:holdWith">holdWith</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto.html#t:Blip">Blip</a> a) a</li><li class="src short"><a href="#v:holdWith_">holdWith_</a> ::  a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto.html#t:Blip">Blip</a> a) a</li><li class="src short"><a href="#v:perBlip">perBlip</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto.html#t:Blip">Blip</a> a) (<a href="Control-Auto.html#t:Blip">Blip</a> b)</li><li class="src short"><a href="#v:never">never</a> ::  <a href="Control-Auto.html#t:Auto">Auto</a> m a (<a href="Control-Auto.html#t:Blip">Blip</a> b)</li><li class="src short"><a href="#v:immediately">immediately</a> ::  <a href="Control-Auto.html#t:Auto">Auto</a> m a (<a href="Control-Auto.html#t:Blip">Blip</a> a)</li><li class="src short"><a href="#v:onFor">onFor</a> ::  <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m a a</li><li class="src short"><a href="#v:during">during</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> a) b</li><li class="src short"><a href="#v:off">off</a> ::  <a href="Control-Auto.html#t:Interval">Interval</a> m a b</li><li class="src short"><a href="#v:toOn">toOn</a> ::  <a href="Control-Auto.html#t:Interval">Interval</a> m a a</li><li class="src short"><a href="#v:fromInterval">fromInterval</a> ::  a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> a) a</li><li class="src short"><a href="#v:interactAuto">interactAuto</a> :: <a href="Control-Auto.html#t:Interval-39-">Interval'</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> (<a href="Control-Auto.html#t:Interval-39-">Interval'</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a>)</li><li class="src short"><a href="#v:interactRS">interactRS</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Read.html#t:Read">Read</a> a, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> b) =&gt; <a href="Control-Auto.html#t:Interval-39-">Interval'</a> a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> (<a href="Control-Auto.html#t:Interval-39-">Interval'</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a>)</li><li class="src short"><a href="#v:streamAutoEffects">streamAutoEffects</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> t, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:MonadPlus">MonadPlus</a> (t m), <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m') =&gt; (<span class="keyword">forall</span> c. m' c -&gt; m c) -&gt; [a] -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m' a b -&gt; t m b</li><li class="src short"><a href="#v:toEffectStream">toEffectStream</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> t, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:MonadPlus">MonadPlus</a> (t m), <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m') =&gt; (<span class="keyword">forall</span> c. m' c -&gt; m c) -&gt; m a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m' a b -&gt; t m b</li><li class="src short">module <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html">Control.Applicative</a></li><li class="src short">module <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html">Control.Arrow</a></li><li class="src short">module <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html">Control.Category</a></li><li class="src short">module <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html">Data.Functor.Identity</a></li><li class="src short">module <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html">Data.Semigroup</a></li></ul></div><div id="interface"><h1 id="g:1">Types</h1><h2 id="g:2">Auto</h2><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Auto" class="def">Auto</a> m a b</p><div class="doc"><p>The <code><a href="Control-Auto.html#t:Auto">Auto</a></code> type.  For this library, an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> semantically
 represents<em>denotes a </em>a relationship/ between an input and an
 output that is preserved over multiple steps, where that relationship is
 (optionally) maintained within the context of a monad.</p><p>A lot of fancy words, I know...but you can think of an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> as nothing
 more than a &quot;stream transformer&quot; of value streams.  A stream of
 sequential input values come in one at a time, and a stream of outputs
 pop out one at a time, as well.</p><p>Using the <code>streamAuto</code> function, you can &quot;unwrap&quot; the inner value stream
 transformer from any <code><a href="Control-Auto.html#t:Auto">Auto</a></code>: if <code>a :: <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code>, <code>streamAuto</code> lets
 you turn it into an <code>[a] -&gt; m [b]</code>.  &quot;Give me a stream of <code>a</code>s, one at
 a time, and I'll give you a list of <code>b</code>s, matching a relationship to
 your stream of <code>a</code>s.&quot;</p><pre>-- unwrap your inner [a] -&gt; m [b]!
<code>streamAuto</code> :: Monad m =&gt; <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b -&gt; ([a] -&gt; m [b])
</pre><p>You can also turn an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code> into an <em>effects stream</em> that
 executes effects sequentially with <code>toEffectStream</code> and
 <code>streamAutoEffects</code>, so you can run it with a ListT-compatible library
 like <em>pipes</em>.</p><p>There's a handy type synonym <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> for relationships that don't really
 need a monadic context; the <code>m</code> is just <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></code>:</p><pre>type Auto' = Auto Identity
</pre><p>So if you had an <code>a :: <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a b</code>, you can use <code>streamAuto'</code> to
 &quot;unwrap&quot; the inner stream transformer, <code>[a] -&gt; [b]</code>.</p><pre>-- unwrap your inner [a] -&gt; [b]!
<code>streamAuto'</code> :: <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a b -&gt; ([a] -&gt; [b])
</pre><p>All of the <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s given in this library maintain some sort of semantic
 relationship between streams --- for some, the outputs might be the
 inputs with a function applied; for others, the outputs might be the
 cumulative sum of the inputs.</p><p>See the
 <a href="https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md">tutorial</a>
 for more information!</p><p>Operationally, an  <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code> is implemented as a &quot;stateful
 function&quot;.  A function from an <code>a</code> where, every time you &quot;apply&quot; it, you
 get a <code>b</code> and an &quot;updated <code><a href="Control-Auto.html#t:Auto">Auto</a></code>&quot;/function with updated state.</p><p>You can get this function using <code><a href="Control-Auto.html#v:stepAuto">stepAuto</a></code>:</p><pre><code><a href="Control-Auto.html#v:stepAuto">stepAuto</a></code> :: <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b -&gt; (a -&gt; m (b, <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b))
</pre><p>Or, for <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code>, <code><a href="Control-Auto.html#v:stepAuto-39-">stepAuto'</a></code>:</p><pre><code><a href="Control-Auto.html#v:stepAuto-39-">stepAuto'</a></code> :: <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a b -&gt; (a -&gt; (b, <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a b))
</pre><p>&quot;Give me an <code>a</code> and I'll give you a <code>b</code> and your &quot;updated&quot; <code><a href="Control-Auto.html#t:Auto">Auto</a></code>&quot;.</p><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code>s really are mostly useful because they can be composed, chained,
 and modified using their various typeclass instances, like <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#t:Category">Category</a></code>,
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a></code>, <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a></code>, <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:Arrow">Arrow</a></code>, etc., and also with the combinators
 in this library.  You can build complex programs as a complex <code><a href="Control-Auto.html#t:Auto">Auto</a></code> by
 building up smaller and smaller components.  See the tutorial for more
 information on this.</p><p>This type also contains information on its own serialization, so you can
 serialize and re-load the internal state to binary or disk.  See the
 &quot;serialization&quot; section in the documentation for <a href="Control-Auto-Core.html">Control.Auto.Core</a>, or
 the documentation for <code><a href="Control-Auto-Core.html#v:mkAutoM">mkAutoM</a></code> for more details.</p></div><div class="subs instances"><p id="control.i:Auto" class="caption collapser" onclick="toggleSection('i:Auto')">Instances</p><div id="section.i:Auto" class="show"><table><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#t:Category">Category</a> * (<a href="Control-Auto.html#t:Auto">Auto</a> m)</td><td class="doc"><p>Gives the ability to &quot;compose&quot; two <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s; feeds the input stream
 into the first, feeds that output stream into the second, and returns as
 a result the output stream of the second.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:Arrow">Arrow</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m)</td><td class="doc"><p>Gives us <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#v:arr">arr</a></code>, which is a &quot;stateless&quot; <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that behaves just like
 a function; its outputs are the function applied the corresponding
 inputs.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (arr negate) [1..10]
</code></strong>[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
</pre><p>Also allows you to have an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> run on only the &quot;first&quot; or &quot;second&quot;
 field in an input stream that is tuples...and also allows <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s to run
 side-by-side on an input stream of tuples (run each on either tuple
 field).</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [4,6,8,7]
</code></strong>[4,10,18,25]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (first (sumFrom 0)) [(4,True),(6,False),(8,False),(7,True)]
</code></strong>[(4,True),(10,False),(18,False),(25,True)]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (productFrom 1) [1,3,5,2]
</code></strong>[1,3,15,30]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0 *** productFrom 1) [(4,1),(6,3),(8,5),(7,2)]
</code></strong>[(4,1),(10,3),(18,15),(25,30)]
</pre><p>Most importantly, however, allows for &quot;proc&quot; notation; see the
 <a href="https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md">tutorial</a>!
 for more details.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:ArrowChoice">ArrowChoice</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m)</td><td class="doc"><p>Allows you to have an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> only act on &quot;some&quot; inputs (only on
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code>s, for example), and be &quot;paused&quot; otherwise.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [1,4,2,5]
</code></strong>[1,5,7,12]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (left (sumFrom 0)) [Left 1, Right 'a', Left 4, Left 2, Right 'b', Left 5]
</code></strong>[Left 1, Right 'a', Left 5, Left 6, Right 'b', Left 12]
</pre><p>Again mostly useful for &quot;proc&quot; notation, with branching.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad-Fix.html#t:MonadFix">MonadFix</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:ArrowLoop">ArrowLoop</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m)</td><td class="doc"><p>Finds the fixed point of self-referential <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s (for example,
 feeding the output stream of an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> to itself).  Mostly used with
 proc notation to allow recursive bindings.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor.html#t:Strong">Strong</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m)</td><td class="doc"><p>See <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:Arrow">Arrow</a></code> instance.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor.html#t:Choice">Choice</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m)</td><td class="doc"><p>See <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:ArrowChoice">ArrowChoice</a></code> instance</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad-Fix.html#t:MonadFix">MonadFix</a> m =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor.html#t:Costrong">Costrong</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m)</td><td class="doc"><p>See <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:ArrowLoop">ArrowLoop</a></code> instance</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#t:Profunctor">Profunctor</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m)</td><td class="doc"><p><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#v:lmap">lmap</a></code> lets you map over the <em>input</em> stream, and <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#v:rmap">rmap</a></code> lets you map
 over the <em>output</em> stream.  Note that, as with all <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#t:Profunctor">Profunctor</a></code>s, <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#v:rmap">rmap</a></code>
 is <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:fmap">fmap</a></code>.</p></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a> m) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a)</td><td class="doc"><p>When the underlying 'Monad'/'Applicative' <code>m</code> is an <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a></code>,
 fork the input through each one and &quot;squish&quot; their results together
 inside the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a></code> context.  Somewhat rarely used, because who
 uses an <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a></code> <code>m</code>?</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto (arrM (mfilter even . Just)) [1..10]
</code></strong>Nothing
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto (arrM (Just . negate)) [1..10]
</code></strong>Just [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto (arrM (mfilter even . Just)) &lt;|&gt; arrM (Just . negate)) [1..10]
</code></strong>Just [-1,2,-3,4,-5,6,-7,8,-9,10]
</pre></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a)</td><td class="doc"><p>Maps over the output stream of the <code><a href="Control-Auto.html#t:Auto">Auto</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [1..10]
</code></strong>[1,3,6,10,15,21,28,36,45,55]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (show &lt;$&gt; sumFrom 0) [1..10]
</code></strong>[&quot;1&quot;,&quot;3&quot;,&quot;6&quot;,&quot;10&quot;,&quot;15&quot;,&quot;21&quot;,&quot;28&quot;,&quot;36&quot;,&quot;45&quot;,&quot;55&quot;]
</pre></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a)</td><td class="doc"><p><code><a href="Control-Auto-Generate.html#v:pure">pure</a></code> creates the &quot;constant&quot; <code><a href="Control-Auto.html#t:Auto">Auto</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (pure &quot;foo&quot;) [1..5]
</code></strong>[&quot;foo&quot;,&quot;foo&quot;,&quot;foo&quot;,&quot;foo&quot;,&quot;foo&quot;]
</pre><p><code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> and <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:liftA2">liftA2</a></code> etc. give you the ability to fork the input stream
 over many <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s, and recombine the results:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [1..10]
</code></strong>[ 1, 3,  6, 10,  15]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (productFrom 1) [1..10]
</code></strong>[ 1, 2,  6, 24, 120]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (liftA2 (+) (sumFrom 0) (productFrom 1)) [1..5]
</code></strong>[ 2, 5, 12, 34, 135]
</pre><p>For effectful <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, you can imagine <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:-42--62-">*&gt;</a></code> as &quot;forking&quot; the input stream
 through both, and only keeping the result of the second:</p><pre><code>effect</code> <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#v:print">print</a></code> *&gt; <code>sumFrom</code> 0
</pre><p>would, for example, behave just like <code><code>sumFrom</code> 0</code>, except printing the
 input to <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a></code> at every step.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Typeable-Internal.html#t:Typeable">Typeable</a> ((* -&gt; *) -&gt; * -&gt; * -&gt; *) <a href="Control-Auto.html#t:Auto">Auto</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Floating">Floating</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Floating">Floating</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>A bunch of constant producers, mappers-of-output-streams, and
 forks-and-recombiners.</p></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Fractional">Fractional</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Fractional">Fractional</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>Fork the input stream and divide the outputs.  <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:recip">recip</a></code> maps <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:recip">recip</a></code> to
 the output stream; <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:fromRational">fromRational</a></code> will be a constant stream of that
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Rational">Rational</a></code>, so you can write <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s using numerical literals in code;
 see <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a></code> instance.</p></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>Fork the input stream and add, multiply, etc. the outputs.  <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:negate">negate</a></code>
 will negate the ouptput stream.  <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:fromInteger">fromInteger</a></code> will be a constant stream
 of that <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Integer">Integer</a></code>, so you can write <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s using numerical literals in
 code:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [1..10]
</code></strong>[1,3,6,10,15,21,28,36,45,55]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (4 + sumFrom 0) [1..10]
</code></strong>[5,7,10,14,19,25,32,40,49,59]
</pre></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:IsString">IsString</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:IsString">IsString</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>String literals in code will be <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s that constanty produce that
 string.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 6 . streamAuto' (onFor 2 . &quot;hello&quot; --&gt; &quot;world&quot;) $ repeat ()
</code></strong>[&quot;hello&quot;,&quot;hello&quot;,&quot;world&quot;,&quot;world&quot;,&quot;world&quot;,&quot;world&quot;]
</pre></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>Fork the input stream and mappend the outputs.  <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#v:mempty">mempty</a></code> is a constant
 stream of <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#v:mempty">mempty</a></code>s, ignoring its input.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (mconcat [arr (take 3), accum (++) &quot;&quot;]) [&quot;hello&quot;,&quot;world&quot;,&quot;good&quot;,&quot;bye&quot;]
</code></strong>[&quot;helhello&quot;,&quot;worhelloworld&quot;,&quot;goohelloworldgood&quot;,&quot;byehelloworldgoodbye&quot;]
</pre></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> b) =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>Fork the input stream and <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#v:-60--62-">&lt;&gt;</a></code> the outputs.  See the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a></code>
 instance.</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Auto-39-" class="def">Auto'</a> = <a href="Control-Auto.html#t:Auto">Auto</a> <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></p><div class="doc"><p>Special case of <code><a href="Control-Auto.html#t:Auto">Auto</a></code> where the underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> is <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></code>.</p><p>Instead of &quot;wrapping&quot; an <code>[a] -&gt; m [b]</code>, it &quot;wraps&quot; an <code>[a] -&gt; [b]</code>.</p></div></div><h2 id="g:3">Misc</h2><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Blip" class="def">Blip</a> a</p><div class="doc"><p>When used in the context of an input or output of an <code>Auto</code>, a <code><code><a href="Control-Auto.html#t:Blip">Blip</a></code>
 a</code> represents a stream that occasionally, at &quot;independent&quot; or &quot;discrete&quot;
 points, emits a value of type <code>a</code>.</p><p>Contrast this to <code>Interval</code>, where things are meant to be &quot;on&quot; or &quot;off&quot;
 for contiguous chunks at a time; blip streams are &quot;blippy&quot;, and
 <code>Interval</code>s are &quot;chunky&quot;.</p><p>It's here mainly because it's a pretty useful abstraction in the context
 of the many combinators found in various modules of this library.  If
 you think of an <code><code>Auto</code> m a (<code><a href="Control-Auto.html#t:Blip">Blip</a></code> b)</code> as producing a &quot;blip stream&quot;,
 then there are various combinators and functions that are specifically
 designed to manipulate blip streams.</p><p>For the purposes of the semantics of what <code><a href="Control-Auto.html#t:Blip">Blip</a></code> is supposed to
 represent, its constructors are hidden.  (Almost) all of the various
 <code><a href="Control-Auto.html#t:Blip">Blip</a></code> combinators (and its very useful <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a></code> instance) &quot;preserve
 <code><a href="Control-Auto.html#t:Blip">Blip</a></code>ness&quot; --- one-at-a-time occurrences remain one-at-a-time under all
 of these combinators, and you should have enough so that direct access
 to the constructor is not needed.</p><p>If you are creating a framework, library, or backend, you might want to
 manually create blip stream-producing <code>Auto</code>s for your users to
 access.  In this case, you can import the constructors and useful
 internal (and, of course, semantically unsafe) functions from
 <a href="Control-Auto-Blip-Internal.html">Control.Auto.Blip.Internal</a>.</p></div><div class="subs instances"><p id="control.i:Blip" class="caption collapser" onclick="toggleSection('i:Blip')">Instances</p><div id="section.i:Blip" class="show"><table><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> <a href="Control-Auto.html#t:Blip">Blip</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> a =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> (<a href="Control-Auto.html#t:Blip">Blip</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/GHC-Generics.html#t:Generic">Generic</a> (<a href="Control-Auto.html#t:Blip">Blip</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> a =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Control-Auto.html#t:Blip">Blip</a> a)</td><td class="doc"><p>Merge two blip streams together; the result emits with <em>either</em> of the
 two merged streams emit.  When both emit at the same time, emit the
 result of <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#v:-60--62-">&lt;&gt;</a></code>-ing the values together.</p></td></tr><tr><td class="src"><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> (<a href="Control-Auto.html#t:Blip">Blip</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/deepseq-1.3.0.2/Control-DeepSeq.html#t:NFData">NFData</a> a =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/deepseq-1.3.0.2/Control-DeepSeq.html#t:NFData">NFData</a> (<a href="Control-Auto.html#t:Blip">Blip</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> a =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Control-Auto.html#t:Blip">Blip</a> a)</td><td class="doc"><p>Merge two blip streams together; the result emits with <em>either</em> of the
 two merged streams emit.  When both emit at the same time, emit the
 result of <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#v:-60--62-">&lt;&gt;</a></code>-ing the values together.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Typeable-Internal.html#t:Typeable">Typeable</a> (* -&gt; *) <a href="Control-Auto.html#t:Blip">Blip</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/GHC-Generics.html#t:Rep">Rep</a> (<a href="Control-Auto.html#t:Blip">Blip</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Interval" class="def">Interval</a> m a b = <a href="Control-Auto.html#t:Auto">Auto</a> m a (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> b)</p><div class="doc"><p>Represents a relationship between an input and an output, where the
 output can be &quot;on&quot; or &quot;off&quot; (using <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Just">Just</a></code> and <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Nothing">Nothing</a></code>) for contiguous
 chunks of time.</p><p><a href="Just.html">Just</a> a type alias for <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code> b)</code>.  If you ended up here
 with a link...no worries!  If you see <code><code><a href="Control-Auto.html#t:Interval">Interval</a></code> m a b</code>, just think
 <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code> b)</code> for type inference/type checking purposes.</p><p>If you see something of type <code><a href="Control-Auto.html#t:Interval">Interval</a></code>, you can rest assured that it
 has &quot;interval semantics&quot; --- it is on and off for meaningfully
 contiguous chunks of time, instead of just on and off willy nilly.  If
 you have a function that expects an <code><a href="Control-Auto.html#t:Interval">Interval</a></code>, then the function
 expects its argument to behave in this way.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Interval-39-" class="def">Interval'</a> a b = <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> b)</p><div class="doc"><p><code><a href="Control-Auto.html#t:Interval">Interval</a></code>, specialized with <code>Identity</code> as its underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code>.
 Analogous to <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> for <code><a href="Control-Auto.html#t:Auto">Auto</a></code>.</p></div></div><h1 id="g:4">Working with <code><a href="Control-Auto.html#t:Auto">Auto</a></code></h1><h2 id="g:5">Running</h2><div class="top"><p class="src"><a name="v:stepAuto" class="def">stepAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc"><p>the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> to step</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>the input</p></td></tr><tr><td class="src">-&gt; m (b, <a href="Control-Auto.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>the output, and the updated <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code>.</p></td></tr></table></div><div class="doc"><p><a href="Runs.html">Runs</a> the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> through one step.</p><p>That is, given an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code>, returns a function that takes an <code>a</code>
 and returns a <code>b</code> and an &quot;updated&quot;/&quot;next&quot; <code><a href="Control-Auto.html#t:Auto">Auto</a></code>; an <code>a -&gt; m (b, <code><a href="Control-Auto.html#t:Auto">Auto</a></code>
 m a b)</code>.</p><p>This is the main way of running an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> &quot;step by step&quot;, so if you have
 some sort of game loop that updates everything every &quot;tick&quot;, this is
 what you're looking for.  At every loop, gather input <code>a</code>, feed it into
 the <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, &quot;render&quot; the result <code>b</code>, and get your new <code><a href="Control-Auto.html#t:Auto">Auto</a></code> to run the
 next time.</p><p>Here is an example with <code><code>sumFrom</code> 0</code>, the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> whose output is the
 cumulative sum of the inputs, and an underying monad of <code>Identity</code>.
 Here,</p><pre>stepAuto :: Auto Identity Int Int
         -&gt; (Int -&gt; Identity (Int, Auto Identity Int Int))
</pre><p>Every time you &quot;step&quot;, you give it an <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></code> and get a resulting <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></code>
 (the cumulative sum) and the &quot;updated <code><a href="Control-Auto.html#t:Auto">Auto</a></code>&quot;, with the updated
 accumulator.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a0 :: Auto Identity Int Int
</code></strong>        a0 = sumFrom 0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Identity (res1, a1) = stepAuto a0 4      -- run with 4
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res1
</code></strong>4                -- the cumulative sum, 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Identity (res2, a2) = stepAuto a1 5      -- run with 5
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res2
</code></strong>9                -- the cumulative sum, 4 + 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Identity (res3, _ ) = stepAuto a2 3      -- run with 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res3
</code></strong>12               -- the cumulative sum, 4 + 5 + 3
</pre><p>By the way, for the case where your <code><a href="Control-Auto.html#t:Auto">Auto</a></code> is under <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></code>, we have
 a type synomym <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code>...and a convenience function to make &quot;running&quot; it
 more streamlined:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a0 :: Auto' Int Int
</code></strong>        a0 = sumFrom 0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res1, a1) = stepAuto' a0 4          -- run with 4
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res1
</code></strong>4                -- the cumulative sum, 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res2, a2) = stepAuto' a1 5          -- run with 5
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res2
</code></strong>9                -- the cumulative sum, 4 + 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res3, _ ) = stepAuto' a2 3          -- run with 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res3
</code></strong>12               -- the cumulative sum, 4 + 5 + 3
</pre><p>But, if your <code><a href="Control-Auto.html#t:Auto">Auto</a></code> actaully has effects when being stepped, <code><a href="Control-Auto.html#v:stepAuto">stepAuto</a></code>
 will execute them:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a0 :: Auto IO Int Int
</code></strong>        a0 = effect (putStrLn &quot;hey!&quot;) *&gt; sumFrom 0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(res1, a1) &lt;- stepAuto a0 4              -- run with 4
</code></strong>hey!         -- IO effect
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res1
</code></strong>4                -- the cumulative sum, 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(res2, a2) &lt;- stepAuto a1 5              -- run with 5
</code></strong>hey!         -- IO effect
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res2
</code></strong>9                -- the cumulative sum, 4 + 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(res3, _ ) &lt;- stepAuto a2 3              -- run with 3
</code></strong>hey!         -- IO effect
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res3
</code></strong>12               -- the cumulative sum, 4 + 5 + 3
</pre><p>(Here, <code><code>effect</code> (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#v:putStrLn">putStrLn</a></code> &quot;hey&quot;)</code> is an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> IO Int ()</code>, which
 ignores its input and just executes <code><code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#v:putStrLn">putStrLn</a></code> &quot;hey&quot;</code> every time it is
 run.  When we use <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:-42--62-">*&gt;</a></code> from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html">Control.Applicative</a>, we &quot;combine&quot; the two
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s together and run them <em>both</em> on each input (4, 5, 3...)...but
 for the &quot;final&quot; output at the end, we only return the output of the
 second one, <code><code>sumFrom</code> 0</code> (5, 9, 12...))</p><p>If you think of an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code> as a &quot;stateful function&quot; <code>a -&gt; m b</code>,
 then <code><a href="Control-Auto.html#v:stepAuto">stepAuto</a></code> lets you &quot;run&quot; it.</p><p>In order to directly run an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> on a stream, an <code>[a]</code>, use
 <code>streamAuto</code>.  That gives you an <code>[a] -&gt; m [b]</code>.</p></div></div><div class="top"><p class="src"><a name="v:stepAuto-39-" class="def">stepAuto'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b</td><td class="doc"><p>the <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> to step</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>the input</p></td></tr><tr><td class="src">-&gt; (b, <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b)</td><td class="doc"><p>the output, and the updated <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code></p></td></tr></table></div><div class="doc"><p><a href="Runs.html">Runs</a> an <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> through one step.</p><p>That is, given an <code><code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a b</code>, returns a function that takes an <code>a</code>
 and returns a <code>b</code> and an &quot;updated&quot;/&quot;next&quot; <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code>; an <code>a -&gt; (b, <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code>
 a b)</code>.</p><p>See <code><a href="Control-Auto.html#v:stepAuto">stepAuto</a></code> documentation for motivations, use cases, and more
 details.  You can use this instead of <code><a href="Control-Auto.html#v:stepAuto">stepAuto</a></code> when your underyling
 monad is <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></code>, and your <code><a href="Control-Auto.html#t:Auto">Auto</a></code> doesn't produce any effects.</p><p>Here is an example with <code><code>sumFrom</code> 0</code>, the <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> whose output is the
 cumulative sum of the inputs</p><pre>stepAuto' :: Auto' Int Int
          -&gt; (Int -&gt; (Int, Auto' Int Int))
</pre><p>Every time you &quot;step&quot;, you give it an <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></code> and get a resulting <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></code>
 (the cumulative sum) and the &quot;updated <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code>&quot;, with the updated
 accumulator.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a0 :: Auto' Int Int
</code></strong>        a0 = sumFrom 0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res1, a1) = stepAuto' a0 4          -- run with 4
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res1
</code></strong>4                -- the cumulative sum, 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res2, a2) = stepAuto' a1 5          -- run with 5
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res2
</code></strong>9                -- the cumulative sum, 4 + 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res3, _ ) = stepAuto' a2 3          -- run with 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res3
</code></strong>12               -- the cumulative sum, 4 + 5 + 3
</pre><p>If you think of an <code><code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a b</code> as a &quot;stateful function&quot; <code>a -&gt; b</code>,
 then <code><a href="Control-Auto.html#v:stepAuto-39-">stepAuto'</a></code> lets you &quot;run&quot; it.</p><p>In order to directly run an <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> on a stream, an <code>[a]</code>, use
 <code>streamAuto'</code>.  That gives you an <code>[a] -&gt; [b]</code>.</p></div></div><div class="top"><p class="src"><a name="v:evalAuto" class="def">evalAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> to run</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>input</p></td></tr><tr><td class="src">-&gt; m b</td><td class="doc"><p>output</p></td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto.html#v:stepAuto">stepAuto</a></code>, but drops the &quot;next <code><a href="Control-Auto.html#t:Auto">Auto</a></code>&quot; and just gives the
 result.</p></div></div><div class="top"><p class="src"><a name="v:evalAuto-39-" class="def">evalAuto'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> to run</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>input</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>output</p></td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto.html#v:stepAuto-39-">stepAuto'</a></code>, but drops the &quot;next <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code>&quot; and just gives the
 result.  <code><a href="Control-Auto.html#v:evalAuto">evalAuto</a></code> for <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:streamAuto" class="def">streamAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> to stream</p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p>input stream</p></td></tr><tr><td class="src">-&gt; m [b]</td><td class="doc"><p>output stream</p></td></tr></table></div><div class="doc"><p>Stream an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> over a list, returning the list of results.  Does
 this &quot;lazily&quot; (over the Monad), so with most Monads, this should work
 fine with infinite lists.  (That is, <code><code><a href="Control-Auto.html#v:streamAuto">streamAuto</a></code> (<code>arrM</code> f)</code> behaves
 exactly like <code><code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Traversable.html#v:mapM">mapM</a></code> f</code>, and you can reason with <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s as if you'd
 reason with <code>mapM</code> on an infinite list)</p><p>Note that, conceptually, this turns an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code> into an <code>[a] -&gt;
 m [b]</code>.</p><p>See <code><a href="Control-Auto.html#v:streamAuto-39-">streamAuto'</a></code> for a simpler example; here is one taking advantage of
 monadic effects:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = arrM print *&gt; sumFrom 0 :: Auto IO Int Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys &lt;- streamAuto a [1..5]
</code></strong>1                -- IO effects
2
3
4
5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys
</code></strong>[1,3,6,10,15]    -- the result
</pre><p><code>a</code> here is like <code><code>sumFrom</code> 0</code>, except at every step, prints the input
 item to stdout as a side-effect.</p><p>Note that we use &quot;stream&quot; here slightly differently than in libraries
 like <em>pipes</em> or <em>conduit</em>.  We don't stream over the <code>m</code> Monad (like
 <code>IO</code>)...we stream over the <strong>input elements</strong>.  Using <code><a href="Control-Auto.html#v:streamAuto">streamAuto</a></code> on an
 infinite list allows you to &quot;stop&quot;, for example, to find the
 result...but it will still sequence all the *effects*.</p><p>For example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 10 &lt;$&gt; streamAuto (arrM print *&gt; id) [1..]
</code></strong></pre><p>Will execute <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#v:print">print</a></code> on every element before &quot;returning&quot; with [1..10].</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>flip runState 0 $ take 10 &lt;$&gt; streamAuto (arrM (modify . (+)) *&gt; id) [1..]
</code></strong>([1,2,3,4,5,6,7,8,9,10], .... (never terminates)
</pre><p>This will immediately return the &quot;result&quot;, and you can bind to the
 result with `(&gt;&gt;=)`, but it'll never return a &quot;final state&quot;, because the
 final state involves executing all of the <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-State-Strict.html#v:modify">modify</a></code>s.</p><p>In other words, we stream <em>values</em>, not <em>effects</em>.  You would analyze
 this behavior the same way you would look at something like <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Traversable.html#v:mapM">mapM</a></code>.</p><p>If you want to stream effects, you can use <code><a href="Control-Auto.html#v:streamAutoEffects">streamAutoEffects</a></code> or
 <code><a href="Control-Auto.html#v:toEffectStream">toEffectStream</a></code>, and use an effects streaming library like <em>pipes</em> (or
 anything with <em>ListT</em>)...this will give the proper streaming of effects
 with resource handling, handling infinite streams in finite space with
 finite effects, etc.</p></div></div><div class="top"><p class="src"><a name="v:streamAuto-39-" class="def">streamAuto'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> to stream</p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p>input stream</p></td></tr><tr><td class="src">-&gt; [b]</td><td class="doc"><p>output stream</p></td></tr></table></div><div class="doc"><p>Stream an <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> over a list, returning the list of results.  Does
 this lazily, so this should work fine with (and is actually somewhat
 designed for) infinite lists.</p><p>Note that conceptually this turns an <code><code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a b</code> into an <code>[a] -&gt; [b]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (arr (+3)) [1..10]
</code></strong>[4,5,6,7,8,9,10,11,12,13]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [1..5]
</code></strong>[1,3,6,10,15]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (productFrom 1) . streamAuto' (sumFrom 0) $ [1..5]
</code></strong>[1,3,18,180,2700]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (productFrom 1 . sumFrom 0) $ [1..5]
</code></strong>[1,3,18,180,2700]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' id [1..5]
</code></strong>[1,2,3,4,5]
</pre></div></div><div class="top"><p class="src"><a name="v:stepAutoN" class="def">stepAutoN</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>number of times to step the <code><a href="Control-Auto.html#t:Auto">Auto</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc"><p>the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> to run</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>the repeated input</p></td></tr><tr><td class="src">-&gt; m ([b], <a href="Control-Auto.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>list of outputs and the updated <code><a href="Control-Auto.html#t:Auto">Auto</a></code></p></td></tr></table></div><div class="doc"><p>Streams (in the context of the underlying monad) the given <code><a href="Control-Auto.html#t:Auto">Auto</a></code> with
 a stream of constant values as input, a given number of times.  After
 the given number of inputs, returns the list of results and the
 next/updated <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, in the context of the underlying monad.</p><pre>stepAutoN n a0 x = overList a0 (replicate n x)</pre><p>See <code><a href="Control-Auto.html#v:stepAutoN-39-">stepAutoN'</a></code> for a simpler example; here is one taking advantage of
 monadic effects:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = arrM print *&gt; sumFrom 0 :: Auto IO Int Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(ys, a') &lt;- stepAutoN 5 a 3
</code></strong>3                -- IO effects
3
3
3
3
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys
</code></strong>[3,6,9,12,15]    -- the result
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(ys'', _) &lt;- stepAutoN 5 a' 5
</code></strong>5                -- IO effects
5
5
5
5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys''
</code></strong>[20,25,30,35,50] -- the result
</pre><p><code>a</code> here is like <code><code>sumFrom</code> 0</code>, except at every step, prints the input
 item to stdout as a side-effect.</p></div></div><div class="top"><p class="src"><a name="v:stepAutoN-39-" class="def">stepAutoN'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>number of times to step the <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b</td><td class="doc"><p>the <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> to run</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>the repeated input</p></td></tr><tr><td class="src">-&gt; ([b], <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b)</td><td class="doc"><p>list of outputs and the updated <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code></p></td></tr></table></div><div class="doc"><p>Streams the given <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> with a stream of constant values as input,
 a given number of times.  After the given number of inputs, returns the
 list of results and the next/updated <code><a href="Control-Auto.html#t:Auto">Auto</a></code>.</p><pre>stepAutoN' n a0 x = overList' a0 (replicate n x)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (ys, a') = stepAutoN' 5 (sumFrom 0) 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys
</code></strong>[3,6,9,12,15]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (ys', _) = stepAutoN' 5 a' 5
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys'
</code></strong>[20,25,30,35,40]
</pre></div></div><h2 id="g:6">Serializing</h2><div class="doc"><p>See the header of the &quot;serializing&quot; section of <a href="Control-Auto-Core.html">Control.Auto.Core</a>
 for more detail on how these work.</p></div><div class="top"><p class="src"><a name="v:encodeAuto" class="def">encodeAuto</a> ::  <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Encode an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> and its internal state into a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:decodeAuto" class="def">decodeAuto</a> ::  <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a b)</p><div class="doc"><p><a href="Resume.html">Resume</a> an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> from its <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> serialization, giving
 a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> if the deserialization is not possible.</p></div></div><div class="top"><p class="src"><a name="v:readAuto" class="def">readAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:FilePath">FilePath</a></td><td class="doc"><p>filepath to read from</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> to resume</p></td></tr><tr><td class="src">-&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Control-Auto.html#t:Auto">Auto</a> m a b))</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Give a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:FilePath">FilePath</a></code> and an <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, and <code><a href="Control-Auto.html#v:readAuto">readAuto</a></code> will attempt to resume
 the saved state of the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> from disk, reading from the given
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:FilePath">FilePath</a></code>.  Will return <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> upon a decoding error, with the error,
 and <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Right">Right</a></code> if the decoding is succesful.</p></div></div><div class="top"><p class="src"><a name="v:writeAuto" class="def">writeAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:FilePath">FilePath</a></td><td class="doc"><p>filepath to write to</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> to serialize</p></td></tr><tr><td class="src">-&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Given a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:FilePath">FilePath</a></code> and an <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, serialize and freeze the state of
 the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> as binary to that <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:FilePath">FilePath</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:unserialize" class="def">unserialize</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Takes an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that is serializable/resumable and returns an <code><a href="Control-Auto.html#t:Auto">Auto</a></code>
 that is not.  That is, when it is &quot;saved&quot;, saves no data, and when it is
 &quot;resumed&quot;, resets itself back to the initial configuration every time;
 in other words, <code><code><a href="Control-Auto.html#v:decodeAuto">decodeAuto</a></code> (unserialize a) bs = Right (unserialize
 a)</code>.  Trying to &quot;resume&quot; it will just always give itself, unchanged.</p></div></div><h2 id="g:7">Strictness</h2><div class="top"><p class="src"><a name="v:forcer" class="def">forcer</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/deepseq-1.3.0.2/Control-DeepSeq.html#t:NFData">NFData</a> a =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</p><div class="doc"><p>A special <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that acts like the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#v:id">id</a></code> <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, but forces results as
 they come through to be fully evaluated, when composed with other
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s.</p><p>TODO: Test if this really works</p></div></div><div class="top"><p class="src"><a name="v:seqer" class="def">seqer</a> ::  <a href="Control-Auto.html#t:Auto">Auto</a> m a a</p><div class="doc"><p>A special <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that acts like the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#v:id">id</a></code> <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, but forces results as
 they come through to be evaluated to Weak Head Normal Form, with <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:seq">seq</a></code>,
 when composed with other <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s.</p><p>TODO: Test if this really works</p></div></div><h2 id="g:8">Internal monad</h2><div class="top"><p class="src"><a name="v:hoistA" class="def">hoistA</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m')</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> c. m c -&gt; m' c)</td><td class="doc"><p>monad morphism;
     the natural transformation</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m' a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Swaps out the underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> of an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> using the given monad
 morphism &quot;transforming function&quot;, a natural transformation.</p><p>Basically, given a function to &quot;swap out&quot; any <code>m a</code> with an <code>m' a</code>, it
 swaps out the underlying monad of the <code><a href="Control-Auto.html#t:Auto">Auto</a></code>.</p><p>This forms a functor, so you rest assured in things like this:</p><pre>hoistA id == id
hoistA f a1 . hoistA f a2 == hoistA f (a1 . a2)
</pre></div></div><div class="top"><p class="src"><a name="v:generalizeA" class="def">generalizeA</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto-39-">Auto'</a> a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Generalizes an <code><code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> a b</code> to an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b'</code> for any <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code>
 <code>m</code>, using <code>hoist</code>.</p><p>You generally should be able to avoid using this if you never directly
 write any <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code>s and always write 'Auto m' parameterized over all
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code>s, but...in case you import one from a library or something, you
 can use this.</p></div></div><h1 id="g:9">Auto constructors</h1><div class="top"><p class="src"><a name="v:arrM" class="def">arrM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; m b)</td><td class="doc"><p>monadic function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Applies the given &quot;monadic function&quot; (function returning a monadic
 action) to every incoming item; the result is the result of executing
 the action returned.</p><p>Note that this essentially lifts a &quot;Kleisli arrow&quot;; it's like <code>arr</code>, but
 for &quot;monadic functions&quot; instead of normal functions:</p><pre>arr  :: (a -&gt; b)   -&gt; Auto m a b
arrM :: (a -&gt; m b) -&gt; Auto m a b
</pre><pre>arrM f . arrM g == arrM (f &lt;=&lt; g)</pre><p>One neat trick you can do is that you can &quot;tag on effects&quot; to a normal
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code> by using <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:-42--62-">*&gt;</a></code> from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html">Control.Applicative</a>.  For example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = arrM print *&gt; sumFrom 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys &lt;- streamAuto a [1..5]
</code></strong>1                -- IO output
2
3
4
5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys
</code></strong>[1,3,6,10,15]    -- the result
</pre><p>Here, <code>a</code> behaves &quot;just like&quot; <code><code>sumFrom</code> 0</code>...except, when you step it,
 it prints out to stdout as a side-effect.  We just gave automatic
 stdout logging behavior!</p></div></div><div class="top"><p class="src"><a name="v:arrD" class="def">arrD</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; b)</td><td class="doc"><p>function to apply</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#v:arr">arr</a></code>, but applies the function to the <em>previous value</em> of the
 input, instead of the current value.  Used for the same purposes as
 <code><a href="Control-Auto.html#v:lastVal">lastVal</a></code>: to manage recursive bindings.</p><p>Warning: Don't use this to do imperative programming!</p><pre>arrD id == lastVal</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (arrD negate 100) [1..10]
</code></strong>[100,-1,-2,-3,-4,-5,-6,-7,-8,-9]
</pre></div></div><h2 id="g:10">from Accumulators</h2><h3 id="g:11">Result-first</h3><div class="top"><p class="src"><a name="v:accum" class="def">accum</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> from a &quot;folding&quot; function: <code>b -&gt; a -&gt; b</code> yields an
 <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code>.  Basically acts like a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-List.html#v:foldl">foldl</a></code> or a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-List.html#v:scanl">scanl</a></code>.  There is
 an internal accumulator that is &quot;updated&quot; with an <code>a</code> at every step.
 Must be given an initial accumulator.</p><p>Example: an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that sums up all of its input.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let summer = accum (+) 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (sum1, summer')  = stepAuto' summer 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sum1
</code></strong>3
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (sum2, summer'') = stepAuto' summer' 10
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sum2
</code></strong>13
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto'  summer'' [1..10]
</code></strong>[14,16,19,23,28,34,41,49,58,68]
</pre><p>If your accumulator <code>b</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you
 should either write a meaningful one, or throw away serializability and
 use <code><a href="Control-Auto.html#v:accum_">accum_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:accum_" class="def">accum_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>intial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto.html#v:accum">accum</a></code>, where the internal accumulator isn't
 serialized. It can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the
 process.</p><p>See <code><a href="Control-Auto.html#v:accum">accum</a></code> for more details.</p><p>Useful if your accumulator <code>b</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code>
 instance.</p></div></div><div class="top"><p class="src"><a name="v:accumM" class="def">accumM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> from a &quot;monadic&quot; &quot;folding&quot; function: <code>b -&gt; a -&gt;
 m b</code> yields an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code>.  Basically acts like a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:foldM">foldM</a></code> or <code>scanM</code>
 (if it existed).  here is an internal accumulator that is &quot;updated&quot; with
 an input <code>a</code> with the result of the executed <code>m b</code> at every step.  Must
 be given an initial accumulator.</p><p>See <code><a href="Control-Auto.html#v:accum">accum</a></code> for more details.</p><p>If your accumulator <code>b</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you
 should either write a meaningful one, or throw away serializability and
 use <code><a href="Control-Auto.html#v:accumM_">accumM_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:accumM_" class="def">accumM_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of 'accumM_, where the internal accumulator isn't
 serialized. It can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the
 process.</p><p>See <code><a href="Control-Auto.html#v:accumM">accumM</a></code> for more details.</p><p>Useful if your accumulator <code>b</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code>
 instance.</p></div></div><h3 id="g:12">Initial accumulator-first</h3><div class="top"><p class="src"><a name="v:accumD" class="def">accumD</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A &quot;delayed&quot; version of <code><a href="Control-Auto.html#v:accum">accum</a></code>, where the first output is the initial
 state of the accumulator, before applying the folding function. Useful
 in recursive bindings.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let summerD = accumD (+) 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (sum1, summerD')  = stepAuto' summerD 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sum1
</code></strong>0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (sum2, summerD'') = stepAuto' summerD' 10
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sum2
</code></strong>3
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto'  summerD'' [1..10]
</code></strong>[13,14,16,19,23,28,34,41,49,58]
</pre><p>(Compare with the example in <code><a href="Control-Auto.html#v:accum">accum</a></code>)</p></div></div><div class="top"><p class="src"><a name="v:accumD_" class="def">accumD_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>intial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto.html#v:accumD">accumD</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:accumMD" class="def">accumMD</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A &quot;delayed&quot; version of <code><a href="Control-Auto.html#v:accumM">accumM</a></code>, where the first output is the initial
 state of the accumulator, before applying the folding function. Useful
 in recursive bindings.</p></div></div><div class="top"><p class="src"><a name="v:accumMD_" class="def">accumMD_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto.html#v:accumMD">accumMD</a></code>.</p></div></div><h2 id="g:13">from State transformers</h2><div class="top"><p class="src"><a name="v:mkState" class="def">mkState</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; s -&gt; (b, s))</td><td class="doc"><p>state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>intial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> from a state transformer: an <code>a -&gt; s -&gt; (b, s)</code>
 gives you an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code>, for any <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> <code>m</code>.  At every step, it
 takes in the <code>a</code> input, runs the function with the stored internal
 state, returns the <code>b</code> result, and now contains the new resulting state.
 You have to intialize it with an initial state, of course.</p><p>From the &quot;stream transformer&quot; point of view, this is rougly equivalent
 to <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Traversable.html#v:mapAccumL">mapAccumL</a></code> from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-List.html">Data.List</a>, with the function's arguments and
 results in the backwards order.</p><pre>streamAuto' (mkState f s0) = snd . mapAccumL (\s x -&gt; swap (f x s))</pre><p>Try not to use this if it's ever avoidable, unless you're a framework
 developer or something.  Try make something by combining/composing the
 various <code><a href="Control-Auto.html#t:Auto">Auto</a></code> combinators.</p><p>If your state <code>s</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you should
 either write a meaningful one, provide the serialization methods
 manually with <code><a href="Control-Auto-Core.html#v:mkState-39-">mkState'</a></code>, or throw away serializability and use
 <code><a href="Control-Auto.html#v:mkState_">mkState_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mkStateM" class="def">mkStateM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; s -&gt; m (b, s))</td><td class="doc"><p>(monadic) state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> from a &quot;monadic&quot; state transformer: <code>a -&gt; s -&gt;
 m (b, s)</code> gives you an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code>.  At every step, it takes in the
 <code>a</code> input, runs the function with the stored internal state and
 &quot;executes&quot; the <code>m (b, s)</code> to get the <code>b</code> output, and stores the <code>s</code> as
 the new, updated state.  Must be initialized with an initial state.</p><p>Try not to use this if it's ever avoidable, unless you're a framework
 developer or something.  Try make something by combining/composing the
 various <code><a href="Control-Auto.html#t:Auto">Auto</a></code> combinators.</p><p>This version is a wrapper around <code><a href="Control-Auto-Core.html#v:mkAuto">mkAuto</a></code>, that keeps track of the
 serialization and re-loading of the internal state for you, so you don't
 have to deal with it explicitly.</p><p>If your state <code>s</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you should
 either write a meaningful one, provide the serialization methods
 manually with <code><a href="Control-Auto-Core.html#v:mkStateM-39-">mkStateM'</a></code>, or throw away serializability and use
 <code><a href="Control-Auto.html#v:mkStateM_">mkStateM_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mkState_" class="def">mkState_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; s -&gt; (b, s))</td><td class="doc"><p>state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto.html#v:mkState">mkState</a></code>, where the internal state isn't serialized.  It
 can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the process.</p><p>See <code><a href="Control-Auto.html#v:mkState">mkState</a></code> for more details.</p><p>Useful if your state <code>s</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance.</p></div></div><div class="top"><p class="src"><a name="v:mkStateM_" class="def">mkStateM_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; s -&gt; m (b, s))</td><td class="doc"><p>(monadic) state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto.html#v:mkStateM">mkStateM</a></code>, where the internal state isn't serialized.
 It can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the process.</p><p>See <code><a href="Control-Auto.html#v:mkStateM">mkStateM</a></code> for more details.</p><p>Useful if your state <code>s</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance.</p></div></div><h2 id="g:14">Generators</h2><h3 id="g:15">Effects</h3><div class="top"><p class="src"><a name="v:effect" class="def">effect</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: m b</td><td class="doc"><p>monadic action to contually execute.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>To get every output, executes the monadic action and returns the
 result as the output.  Always ignores input.</p><p>This is basically like an &quot;effectful&quot; <code><a href="Control-Auto-Generate.html#v:pure">pure</a></code>:</p><pre><code><a href="Control-Auto-Generate.html#v:pure">pure</a></code>   :: b   -&gt; <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b
<code><a href="Control-Auto.html#v:effect">effect</a></code> :: m b -&gt; <code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b
</pre><p>The output of <code><a href="Control-Auto-Generate.html#v:pure">pure</a></code> is always the same, and the output of <code><a href="Control-Auto.html#v:effect">effect</a></code> is
 always the result of the same monadic action.  Both ignore their inputs.</p><p>Fun times when the underling <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> is, for instance, <code>Reader</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = effect ask    :: Auto (Reader b) a b
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let r = evalAuto a () :: Reader b b
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runReader r &quot;hello&quot;
</code></strong>&quot;hello&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runReader r 100
</code></strong>100
</pre><p>If your underling monad has effects (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a></code>, <code>State</code>, <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code>, <code>Writer</code>,
 etc.), then it might be fun to take advantage of <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:-42--62-">*&gt;</a></code> from
 <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html">Control.Applicative</a> to &quot;tack on&quot; an effect to a normal <code><a href="Control-Auto.html#t:Auto">Auto</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = effect (modify (+1)) *&gt; sumFrom 0 :: Auto (State Int) Int Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let st = streamAuto a [1..10]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (ys, s') = runState st 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ys
</code></strong>[1,3,6,10,15,21,28,36,45,55]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s'
</code></strong>10
</pre><p>Out <code><a href="Control-Auto.html#t:Auto">Auto</a></code> <code>a</code> behaves exactly like <code><code>sumFrom</code> 0</code>, except at each step,
 it also increments the underlying/global state by one.  It is <code><code>sumFrom</code>
 0</code> with an &quot;attached effect&quot;.</p></div></div><h3 id="g:16">Iterators</h3><div class="top"><p class="src"><a name="v:iterator" class="def">iterator</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; b)</td><td class="doc"><p>iterating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>starting value and initial output</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Analogous to <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-List.html#v:iterate">iterate</a></code> from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html">Prelude</a>.  Keeps accumulator value and
 continually applies the function to the accumulator at every step,
 outputting the result.</p><p>The first result is the initial accumulator value.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 10 . streamAuto' (iterator (*2) 1) $ repeat ()
</code></strong>[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
</pre></div></div><div class="top"><p class="src"><a name="v:iterator_" class="def">iterator_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; b)</td><td class="doc"><p>iterating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>starting value and initial output</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto.html#v:iterator">iterator</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:iteratorM" class="def">iteratorM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; m b)</td><td class="doc"><p>(monadic) iterating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>starting value and initial output</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto.html#v:iterator">iterator</a></code>, but with a monadic function.</p></div></div><div class="top"><p class="src"><a name="v:iteratorM_" class="def">iteratorM_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; m b)</td><td class="doc"><p>(monadic) iterating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>starting value and initial output</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto.html#v:iteratorM">iteratorM</a></code>.</p></div></div><h1 id="g:17">Common <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s and combinators</h1><h2 id="g:18">Processes</h2><div class="top"><p class="src"><a name="v:sumFrom" class="def">sumFrom</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>initial count</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The stream of outputs is the cumulative/running sum of the inputs so
 far, starting with an initial count.</p><p>The first output takes into account the first input.  See <code><a href="Control-Auto.html#v:sumFromD">sumFromD</a></code> for
 a version where the first output is the initial count itself.</p><pre>sumFrom x0 = accum (+) x0</pre></div></div><div class="top"><p class="src"><a name="v:sumFrom_" class="def">sumFrom_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>initial count</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto.html#v:sumFrom">sumFrom</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:sumFromD" class="def">sumFromD</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>initial count</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto.html#v:sumFrom">sumFrom</a></code>, except the first output is the starting count.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = sumFromD 5
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (y1, a') = stepAuto' a 10
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>y1
</code></strong>5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (y2, _ ) = stepAuto' a' 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>y2
</code></strong>10
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [1..10]
</code></strong>[1,3,6,10,15,21,28,36,45,55]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFromD 0) [1..10]
</code></strong>[0,1,3,6,10,15,21,28,36,45]
</pre><p>It's <code><a href="Control-Auto.html#v:sumFrom">sumFrom</a></code>, but &quot;delayed&quot;.</p><p>Useful for recursive bindings, where you need at least one value to be
 able to produce its &quot;first output&quot; without depending on anything else.</p><pre>sumFromD x0 = sumFrom x0 . delay 0</pre><pre>sumFromD x0 = delay x0 . sumFrom x0</pre></div></div><div class="top"><p class="src"><a name="v:sumFromD_" class="def">sumFromD_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>initial count</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto.html#v:sumFromD">sumFromD</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:productFrom" class="def">productFrom</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>initial product</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The output is the running/cumulative product of all of the inputs so
 far, starting from an initial product.</p><pre>productFrom x0 = accum (*) x0</pre></div></div><div class="top"><p class="src"><a name="v:productFrom_" class="def">productFrom_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>initial product</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto.html#v:productFrom">productFrom</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mappender" class="def">mappender</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> a) =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</p><div class="doc"><p>The output is the running/cumulative <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#v:mconcat">mconcat</a></code> of all of the input
 seen so far, starting with <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#v:mempty">mempty</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamauto' mappender . map Last $ [Just 4, Nothing, Just 2, Just 3]
</code></strong>[Last (Just 4), Last (Just 4), Last (Just 2), Last (Just 3)]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' mappender [&quot;hello&quot;,&quot;world&quot;,&quot;good&quot;,&quot;bye&quot;]
</code></strong>[&quot;hello&quot;,&quot;helloworld&quot;,&quot;helloworldgood&quot;,&quot;helloworldgoodbye&quot;]
</pre><pre>mappender = accum mappend mempty</pre></div></div><div class="top"><p class="src"><a name="v:mappender_" class="def">mappender_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> a =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</p><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto.html#v:mappender">mappender</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mappendFrom" class="def">mappendFrom</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The output is the running <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#v:-60--62-">&lt;&gt;</a></code>-sum (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#v:mappend">mappend</a></code> for <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#t:Semigroup">Semigroup</a></code>) of all
 of the input values so far, starting with a given starting value.
 Basically like <code><a href="Control-Auto.html#v:mappender">mappender</a></code>, but with a starting value.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (mappendFrom (Max 0)) [Max 4, Max (-2), Max 3, Max 10]
</code></strong>[Max 4, Max 4, Max 4, Max 10]
</pre><pre>mappendFrom m0 = accum (&lt;&gt;) m0</pre></div></div><div class="top"><p class="src"><a name="v:lastVal" class="def">lastVal</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>An <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that returns the last value received by it.  Given an
 &quot;initial value&quot; to output first.</p><p>From the signal processing world, this is known as the &quot;lag operator&quot;
 <em>L</em>.</p><p>This is (potentially) a <strong>very dangerous</strong> <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, because its usage and
 its very existence opens the door to breaking denotative/declarative
 style and devolving into imperative style coding.  However, when used
 where it is supposed to be used, it is more or less invaluable, and will
 be an essential part of many programs.</p><p>Its main usage is for dealing with recursive bindings.  If you ever are
 laying out recursive bindings in a high-level/denotative way, you need
 to have at least one value be able to have a &quot;initial output&quot; without
 depending on anything else.  <code><a href="Control-Auto.html#v:lastVal">lastVal</a></code> and <code><a href="Control-Auto.html#v:delay">delay</a></code> allow you to do this.</p><p>See the <a href="https://github.com/mstksg/auto-examples/blob/master/src/Recursive.hs">recursive</a>
 example for more information on the appropriate usage of <code><a href="Control-Auto.html#v:lastVal">lastVal</a></code> and
 <code><a href="Control-Auto.html#v:delay">delay</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (lastVal 100) [1..10]
</code></strong>[100,1,2,3,4,5,6,7,8,9]
</pre></div></div><div class="top"><p class="src"><a name="v:lastVal_" class="def">lastVal_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: a</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto.html#v:lastVal">lastVal</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:delay" class="def">delay</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>An alias for <code><a href="Control-Auto.html#v:lastVal">lastVal</a></code>; used in contexts where &quot;delay&quot; is more
 a meaningful description than &quot;last value&quot;.  All of the warnings for
 <code><a href="Control-Auto.html#v:lastVal">lastVal</a></code> still apply, so you should probably read it if you haven't :)</p></div></div><div class="top"><p class="src"><a name="v:delay_" class="def">delay_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: a</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto.html#v:delay">delay</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:count" class="def">count</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b) =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>A simple <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that ignores all input; its output stream counts
 upwards from zero.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 10 . streamAuto' count $ repeat ()
</code></strong>[0,1,2,3,4,5,6,7,8,9]
</pre></div></div><h2 id="g:19">Switches</h2><div class="top"><p class="src"><a name="v:-45--45--62-" class="def">(--&gt;)</a> <span class="fixity">infixr 1</span><span class="rightedge"></span></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m a b</td><td class="doc"><p>initial behavior</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc"><p>final behavior, when the initial
   behavior turns off.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>&quot;This, then that&quot;.  Behave like the first <code><a href="Control-Auto.html#t:Interval">Interval</a></code> (and run its
 effects) as long as it is &quot;on&quot; (outputting <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Just">Just</a></code>).  As soon as it turns
 off (is 'Nothing), it'll &quot;switch over&quot; and begin behaving like the
 second <code><a href="Control-Auto.html#t:Auto">Auto</a></code> forever, running the effects of the second <code><a href="Control-Auto.html#t:Auto">Auto</a></code>, too.
 Works well if the <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s follow interval semantics from
 <a href="Control-Auto-Interval.html">Control.Auto.Interval</a>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a1 = whileI (&lt;= 4) --&gt; pure 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' a1 [1..10]
</code></strong>[1, 2, 3, 4, 0, 0, 0, 0, 0, 0]
</pre><p>(<code>whileI</code> only lets items satisfying the predicate pass through as &quot;on&quot;,
 and is &quot;off&quot; otherwise; <code><a href="Control-Auto-Generate.html#v:pure">pure</a></code> is the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that always produces the
 same output)</p><p>Association works in a way that you can &quot;chain&quot; <code><a href="Control-Auto.html#v:-45--45--62-">--&gt;</a></code>s, as long as you
 have an appropriate <code><a href="Control-Auto.html#t:Auto">Auto</a></code> (and not <code><a href="Control-Auto.html#t:Interval">Interval</a></code>) at the end:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a2 = onFor 3 . sumFrom 0
</code></strong>         --&gt; onFor 3 . sumFrom 100
         --&gt; pure 0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' a2 [1..10]
</code></strong>[1,3,6,104,109,115,0,0,0,0]
</pre><p><code>a --&gt; b --&gt; c</code> associates as <code>a --&gt; (b --&gt; c)</code></p><p>This is pretty invaluable for having <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s &quot;step&quot; through a series of
 different <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s, progressing their state from one stage to the next.
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code>s can control when they want to be &quot;moved on&quot; from by turning
 &quot;off&quot; (outputting <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Nothing">Nothing</a></code>).</p><p>Note that recursive bindings work just fine, so:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a3 = onFor 2 . pure &quot;hello&quot;
</code></strong>         --&gt; onFor 2 . pure &quot;goodbye&quot;
         --&gt; a3
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res3, _) = stepAutoN' 8 a3 ()
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res3
</code></strong>[&quot;hello&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;hello&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;world&quot;]
</pre><p>the above represents an infinite loop between outputting &quot;hello&quot; and
 outputting &quot;world&quot;.</p><p>For serialization, an extra byte cost is incurred per invocation of
 <code><a href="Control-Auto.html#v:-45--45--62-">--&gt;</a></code>.  For cyclic switches like <code>a3</code>, every time the cycle &quot;completes&quot;,
 it adds another layer of <code><a href="Control-Auto.html#v:-45--45--62-">--&gt;</a></code> byte costs.  For example, initially,
 saving <code>a3</code> incurs a cost for the two <code><a href="Control-Auto.html#v:-45--45--62-">--&gt;</a></code>s.  After <code>a3</code> loops once,
 it incurs a cost for another two <code><a href="Control-Auto.html#v:-45--45--62-">--&gt;</a></code>s, so it costs four <code><a href="Control-Auto.html#v:-45--45--62-">--&gt;</a></code>s.  After
 <code>a3</code> loops another time, it is like a cost of six <code><a href="Control-Auto.html#v:-45--45--62-">--&gt;</a></code>s.  So be aware
 that for cyclic bindings like <code>a3</code>, space for serialization grows at
 O(n).</p><p>By the way, it might be worth contrasting this with <code><a href="Control-Auto-Interval.html#v:-60--124--33--62-">&lt;|!&gt;</a></code> and <code><a href="Control-Auto-Interval.html#v:-60--124--63--62-">&lt;|?&gt;</a></code>
 from <a href="Control-Auto-Interval.html">Control.Auto.Interval</a>, which have the same type signatures.
 Those alternative-y operators always <em>feed the input to both sides</em>,
 <em>run both sides</em>, and output the first <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Just">Just</a></code>.  With <code><a href="Control-Auto-Interval.html#v:-60--124--33--62-">&lt;|!&gt;</a></code>, you can
 &quot;switch back and forth&quot; to the first <code><a href="Control-Auto.html#t:Auto">Auto</a></code> as soon as the first <code><a href="Control-Auto.html#t:Auto">Auto</a></code>
 is &quot;on&quot; (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Just">Just</a></code>) again.</p><p><code><a href="Control-Auto.html#v:-45--45--62-">--&gt;</a></code>, in contrast, runs <em>only</em> the first <code><a href="Control-Auto.html#t:Auto">Auto</a></code> until it is
 off (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Nothing">Nothing</a></code>)...then runs <em>only</em> the second <code><a href="Control-Auto.html#t:Auto">Auto</a></code>.  This transition is
 one-way, as well.</p></div></div><div class="top"><p class="src"><a name="v:-45--63--62-" class="def">(-?&gt;)</a> <span class="fixity">infixr 1</span><span class="rightedge"></span></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m a b</td><td class="doc"><p>initial behavior</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m a b</td><td class="doc"><p>final behavior, when the initial
   behavior turns off.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A variation of <code><a href="Control-Auto.html#v:-45--45--62-">--&gt;</a></code>, where the right hand side can also be an
 interval/<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code>.  The entire result is, then, a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code>.  Probably less
 useful than <code><a href="Control-Auto.html#v:-45--45--62-">--&gt;</a></code> in most situations.</p></div></div><h2 id="g:20">Blips</h2><div class="top"><p class="src"><a name="v:emitJusts" class="def">emitJusts</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> b)</td><td class="doc"><p>&quot;predicate&quot; to emit on.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a (<a href="Control-Auto.html#t:Blip">Blip</a> b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>An <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that runs every input through a <code>a -&gt; <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code> b</code> test and
 produces a blip stream that emits the value inside every <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Just">Just</a></code> result.</p><p>Particularly useful with prisms from the <em>lens</em> package, where things
 like <code>emitJusts (preview _Right)</code> will emit the <code>b</code> whenever the input
 <code>Either a b</code> stream is a <code>Right</code>.</p><p>Warning!  Carries all of the same dangers of <code><a href="Control-Auto.html#v:emitOn">emitOn</a></code>.  You can easily
 break blip semantics with this if you aren't sure what you are doing.
 Remember to only emit at discrete, separate occurences, and not for
 interval-like (on and off for chunks at a time) things.  For interval
 semantics, we have <a href="Control-Auto-Interval.html">Control.Auto.Interval</a>.</p><p>See the examples of <code><a href="Control-Auto.html#v:emitOn">emitOn</a></code> for more concrete good/bad use cases.</p></div></div><div class="top"><p class="src"><a name="v:emitOn" class="def">emitOn</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Bool.html#t:Bool">Bool</a>)</td><td class="doc"><p>predicate to emit on</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a (<a href="Control-Auto.html#t:Blip">Blip</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Produces a blip stream that emits the input value whenever the input
 satisfies a given predicate.</p><p>Warning!  This <code><a href="Control-Auto.html#t:Auto">Auto</a></code> has the capability of &quot;breaking&quot; blip semantics.
 Be sure you know what you are doing when using this.  Blip streams are
 semantically supposed to only emit at discrete, separate occurrences.
 Do not use this for interval-like (on and off for chunks at a time)
 things; each input should be dealt with as a separate thing.</p><p>For interval semantics, we have <code>Interval</code> from <a href="Control-Auto-Interval.html">Control.Auto.Interval</a>.</p><p>Good example:</p><pre>-- is only emitting at discrete blips
emitOn even . iterator (+ 1) 0</pre><p>Bad examples:</p><pre>-- is emitting for &quot;durations&quot; or &quot;intervals&quot; of time.
emitOn (&lt; 10) . iterator (+ 1) 0

emitOn (const True) . foo</pre><p>These bad examples would be good use cases of <code>Interval</code>.</p><p>Can be particularly useful with prisms from the <em>lens</em> package, where
 things like <code>emitOn (has _Right)</code> and <code>emitOn (hasn't _Right)</code> will emit
 the input <code>Either a b</code> whenever it is or isn't a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Right">Right</a></code>.  See
 <code><a href="Control-Auto.html#v:emitJusts">emitJusts</a></code> for more common uses with <em>lens</em>.</p></div></div><div class="top"><p class="src"><a name="v:fromBlips" class="def">fromBlips</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: a</td><td class="doc"><p>the &quot;default value&quot; to output when the input is not
   emitting.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto.html#t:Blip">Blip</a> a) a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><code><a href="Control-Auto.html#v:fromBlips">fromBlips</a></code> d</code> is an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that decomposes the incoming blip
 stream by constantly outputting <code>d</code> except when the stream emits, and
 outputs the emitted value when it does.</p></div></div><div class="top"><p class="src"><a name="v:fromBlipsWith" class="def">fromBlipsWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: b</td><td class="doc"><p>the 'default value&quot; to output when the input is not
   emitting.</p></td></tr><tr><td class="src">-&gt; (a -&gt; b)</td><td class="doc"><p>the function to apply to the emitted value
   whenever input is emitting.</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto.html#t:Blip">Blip</a> a) b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><code><a href="Control-Auto.html#v:fromBlipsWith">fromBlipsWith</a></code> d f</code> is an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that decomposes the incoming blip
 stream by constantly outputting <code>d</code> except when the stream emits, and
 outputs the result of applying <code>f</code> to the emitted value when it does.</p></div></div><div class="top"><p class="src"><a name="v:holdWith" class="def">holdWith</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> a =&gt; a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto.html#t:Blip">Blip</a> a) a</p><div class="doc"><p><code><code><a href="Control-Auto.html#v:holdWith">holdWith</a></code> y0</code> is an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> whose output is always the /most recently
 emitted/ value from the input blip stream.  Before anything is emitted,
 <code>y0</code> is outputted as a placeholder.</p><p>Contrast with <code>hold</code> from <a href="Control-Auto-Interval.html">Control.Auto.Interval</a>.</p></div></div><div class="top"><p class="src"><a name="v:holdWith_" class="def">holdWith_</a> ::  a -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto.html#t:Blip">Blip</a> a) a</p><div class="doc"><p>A non-serializing/non-resumable version of <code><a href="Control-Auto.html#v:holdWith">holdWith</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:perBlip" class="def">perBlip</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="Control-Auto.html#t:Blip">Blip</a> a) (<a href="Control-Auto.html#t:Blip">Blip</a> b)</p><div class="doc"><p>Takes an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code> (an <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that turns incoming <code>a</code>s into
 outputting <code>b</code>s) into an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m (<code><a href="Control-Auto.html#t:Blip">Blip</a></code> a) (<code><a href="Control-Auto.html#t:Blip">Blip</a></code> b)</code>; the original
 <code><a href="Control-Auto.html#t:Auto">Auto</a></code> is lifted to only be applied to emitted contents of a blip
 stream.</p><p>When the stream emits, the original <code><a href="Control-Auto.html#t:Auto">Auto</a></code> is &quot;stepped&quot; with the emitted
 value; when it does not, it is paused and frozen until the next
 emission.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let sums = perBlip (sumFrom 0)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let blps = eachAt 2 [1,5,2]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 8 . streamAuto' blps $ repeat ()
</code></strong>[NoBlip, Blip 1, NoBlip, Blip 5, NoBlip, Blip 2, NoBlip, NoBlip]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 8 . streamAuto' (sums . blps) $ repeat ()
</code></strong>[NoBlip, Blip 1, NoBlip, Blip 6, NoBlip, Blip 8, NoBlip, NoBlip]
</pre></div></div><div class="top"><p class="src"><a name="v:never" class="def">never</a> ::  <a href="Control-Auto.html#t:Auto">Auto</a> m a (<a href="Control-Auto.html#t:Blip">Blip</a> b)</p><div class="doc"><p>An <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that ignores its input and produces a blip stream never
 emits.</p></div></div><div class="top"><p class="src"><a name="v:immediately" class="def">immediately</a> ::  <a href="Control-Auto.html#t:Auto">Auto</a> m a (<a href="Control-Auto.html#t:Blip">Blip</a> a)</p><div class="doc"><p>Produces a blip stream that emits with the first received input value,
 and never again after that.</p><p>Often used with <code><a href="Control-Auto-Generate.html#v:pure">pure</a></code>:</p><pre>immediately . pure &quot;Emit me!&quot;</pre><p>Or, in proc notation:</p><pre>blp &lt;- immediately -&lt; &quot;Emit me!&quot;</pre><p>to get a blip stream that emits a given value (eg., &quot;Emit me!&quot;) once
 and stops emitting ever again.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (immediately . pure &quot;Emit me!&quot;) [1..5]
</code></strong>[Blip &quot;Emit Me!&quot;, NoBlip, NoBlip, NoBlip, NoBlip]
</pre></div></div><h2 id="g:21">Intervals</h2><div class="top"><p class="src"><a name="v:onFor" class="def">onFor</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>amount of steps to stay &quot;on&quot; for</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>For <code><code><a href="Control-Auto.html#v:onFor">onFor</a></code> n</code>, the first <code>n</code> items in the output stream are always
 &quot;on&quot; (passing through with exactly the value of the corresponding
 input); for the rest, the output stream is always &quot;off&quot;, suppressing all
 input values forevermore.</p><p>If a number less than 0 is passed, 0 is used.</p></div></div><div class="top"><p class="src"><a name="v:during" class="def">during</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> to lift to work over intervals</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Interval">Interval</a> m (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> a) b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><a href="Lifts.html">Lifts</a> an <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m a b</code> (transforming <code>a</code>s into <code>b</code>s) into an
 <code><code><a href="Control-Auto.html#t:Auto">Auto</a></code> m (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code> a) (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code> b)</code> (or, <code><code><a href="Control-Auto.html#t:Interval">Interval</a></code> m (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code> a) b</code>,
 transforming <em>intervals</em> of <code>a</code>s into <em>intervals</em> of <code>b</code>.</p><p>It does this by running the <code>Auuto</code> as normal when the input is &quot;on&quot;,
 and freezing it<em>being &quot;off&quot; when the input is </em>off/.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a1 = during (sumFrom 0) . onFor 2 . pure 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 5 . streamAuto' a1 $ repeat ()
</code></strong>[Just 1, Just 2, Nothing, Nothing, Nothing]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a2 = during (sumFrom 0) . offFor 2 . pure 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 5 . streamAuto' a2 $ repeat ()
</code></strong>[Nothing, Nothing, Just 1, Just 2, Just 3]
</pre><p>(Remember that <code><code><a href="Control-Auto-Generate.html#v:pure">pure</a></code> x</code> is the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> that ignores its input and
 constantly just pumps out <code>x</code> at every step)</p><p>Note the difference between putting the <code>sumFrom</code> &quot;after&quot; the
 <code><a href="Control-Auto-Interval.html#v:offFor">offFor</a></code> in the chain with <code><a href="Control-Auto.html#v:during">during</a></code> (like the previous example)
 and putting the <code>sumFrom</code> &quot;before&quot;:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a3 = offFor 2 . sumFrom 0 . pure 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 5 . streamAuto' a3 $ repeat ()
</code></strong>[Nothing, Nothing, Just 3, Just 4, Just 5]
</pre><p>In the first case (with <code>a2</code>), the output of <code><code><a href="Control-Auto-Generate.html#v:pure">pure</a></code> 1</code> was suppressed
 by <code><a href="Control-Auto-Interval.html#v:offFor">offFor</a></code>, and <code><code><a href="Control-Auto.html#v:during">during</a></code> (<code>sumFrom</code> 0)</code> was only summing on the times
 that the 1's were &quot;allowed through&quot;...so it only &quot;starts counting&quot; on
 the third step.</p><p>In the second case (with <code>a3</code>), the output of the <code><code><a href="Control-Auto-Generate.html#v:pure">pure</a></code> 1</code> is never
 suppressed, and went straight into the <code><code>sumFrom</code> 0</code>.  <code>sumFrom</code> is
 always summing, the entire time.  The final output of that <code><code>sumFrom</code> 0</code>
 is suppressed at the end with <code><code><a href="Control-Auto-Interval.html#v:offFor">offFor</a></code> 2</code>.</p></div></div><div class="top"><p class="src"><a name="v:off" class="def">off</a> ::  <a href="Control-Auto.html#t:Interval">Interval</a> m a b</p><div class="doc"><p>The output stream is alwayas off, regardless of the input.</p><p>Note that any monadic effects of the input <code><a href="Control-Auto.html#t:Auto">Auto</a></code> when composed with
 <code><a href="Control-Auto.html#v:off">off</a></code> are still executed, even though their result value is suppressed.</p><pre>off == pure Nothing</pre></div></div><div class="top"><p class="src"><a name="v:toOn" class="def">toOn</a> ::  <a href="Control-Auto.html#t:Interval">Interval</a> m a a</p><div class="doc"><p>The output stream is always on, with exactly the value of the
 corresponding input.</p><pre>toOn == arr Just</pre></div></div><div class="top"><p class="src"><a name="v:fromInterval" class="def">fromInterval</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: a</td><td class="doc"><p>value to output for &quot;off&quot; periods</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> a) a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>An &quot;interval collapsing&quot; <code><a href="Control-Auto.html#t:Auto">Auto</a></code>.  A stream of on/off values comes in;
 the output is the value of the input when the input is on, and the
 &quot;default value&quot; when the input is off.</p><p>Much like <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:fromMaybe">fromMaybe</a></code> from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html">Data.Maybe</a>.</p><pre>fromInterval d = arr (fromMaybe d)</pre></div></div><h1 id="g:22">Running</h1><div class="top"><p class="src"><a name="v:interactAuto" class="def">interactAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Auto.html#t:Interval-39-">Interval'</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></td><td class="doc"><p><code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code> to run interactively</p></td></tr><tr><td class="src">-&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> (<a href="Control-Auto.html#t:Interval-39-">Interval'</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a>)</td><td class="doc"><p>final <code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code> after it all</p></td></tr></table></div><div class="doc"><p>Run an <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> &quot;interactively&quot;.  Every step grab a string from stdin,
 and feed it to the <code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code>.  If the <code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code> is &quot;off&quot;, ends the
 session; if it is &quot;on&quot;, then prints the output value to stdout and
 repeat all over again.</p><p>If your <code><a href="Control-Auto.html#t:Auto">Auto</a></code> outputs something other than a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></code>, you can use
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:fmap">fmap</a></code> to transform the output into a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></code> en-route (like <code><code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:fmap">fmap</a></code>
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#v:show">show</a></code></code>).</p><p>If your <code><a href="Control-Auto.html#t:Auto">Auto</a></code> takes in something other than a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></code>, you can <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#v:lmap">lmap</a></code>
 a function to convert the input <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></code> to whatever intput your <code><a href="Control-Auto.html#t:Auto">Auto</a></code>
 expects.</p><p>You can use <code><a href="Control-Auto-Run.html#v:duringRead">duringRead</a></code> or <code><a href="Control-Auto-Run.html#v:bindRead">bindRead</a></code> if you have an <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> or
 <code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code> that takes something <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Read.html#v:read">read</a></code>able, to chug along until you
 find something non-readable; there's also <code><a href="Control-Auto.html#v:interactRS">interactRS</a></code> which handles
 most of that for you.</p><p>Outputs the final <code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code> when the interaction terminates.</p></div></div><div class="top"><p class="src"><a name="v:interactRS" class="def">interactRS</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Read.html#t:Read">Read</a> a, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto.html#t:Interval-39-">Interval'</a> a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code> to run interactively</p></td></tr><tr><td class="src">-&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a> (<a href="Control-Auto.html#t:Interval-39-">Interval'</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a>)</td><td class="doc"><p>final <code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code> after it all</p></td></tr></table></div><div class="doc"><p>Like <code>interact</code>, but instead of taking <code><code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code> <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></code>
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></code></code>, takes any <code><code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code> a b</code> as long as <code>a</code> is <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Read.html#t:Read">Read</a></code> and <code>b</code>
 is <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a></code>.</p><p>Will &quot;stop&quot; if either (1) the input is not <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Read.html#v:read">read</a></code>-able or (2) the
 <code><a href="Control-Auto.html#t:Interval-39-">Interval'</a></code> turns off.</p><p>Outputs the final <code><a href="Control-Auto.html#t:Auto-39-">Auto'</a></code> when the interaction terminates.</p></div></div><div class="top"><p class="src"><a name="v:streamAutoEffects" class="def">streamAutoEffects</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> t, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:MonadPlus">MonadPlus</a> (t m), <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m')</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> c. m' c -&gt; m c)</td><td class="doc"><p>function to change the underyling monad from <code>m'</code> to <code>m</code></p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p>inputs to stream on</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m' a b</td><td class="doc"><p><code><a href="Control-Auto.html#t:Auto">Auto</a></code> to stream</p></td></tr><tr><td class="src">-&gt; t m b</td><td class="doc"><p><a href="ListT.html">ListT</a>-like structure sequencing effects</p></td></tr></table></div><div class="doc"><p>Turns an <code>Auto m' a b</code> with a list of inputs into a &quot;ListT compatible
 effectful stream&quot;, as described at
 <a href="http://www.haskellforall.com/2014/11/how-to-build-library-agnostic-streaming.html">http://www.haskellforall.com/2014/11/how-to-build-library-agnostic-streaming.html</a></p><p>Any library that offers a &quot;<code>ListT</code>&quot; type can use this result...and
 usually turn it into an effectful stream.</p><p>For example, the <em>pipes</em> library offers <code>runListT</code> so you can run this,
 running the <code><a href="Control-Auto.html#t:Auto">Auto</a></code> over the input list, all with the effect stream
 manipulation tools and resource handling of <em>pipes</em>.</p><p>This is useful because <em>auto</em>, the library, mainly provides tools for
 working with transformers for <em>value</em> streams, and not effect streams or
 streams of effects.  Using this, you can potentially have the best of
 both worlds.</p></div></div><div class="top"><p class="src"><a name="v:toEffectStream" class="def">toEffectStream</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> t, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:MonadPlus">MonadPlus</a> (t m), <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m')</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> c. m' c -&gt; m c)</td><td class="doc"><p>function to change the underyling monad from <code>m'</code> to <code>m</code></p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc"><p>action to generate inputs</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto.html#t:Auto">Auto</a> m' a b</td><td class="doc"><p>Auto to run as an effectful stream</p></td></tr><tr><td class="src">-&gt; t m b</td><td class="doc"><p><code>ListT</code>-compatible type</p></td></tr></table></div><div class="doc"><p>Turns an <code>Auto m' a b</code> and an &quot;input producer&quot; <code>m a</code> into a &quot;ListT
 compatible effectful stream&quot;, as described at
 <a href="http://www.haskellforall.com/2014/11/how-to-build-library-agnostic-streaming.html">http://www.haskellforall.com/2014/11/how-to-build-library-agnostic-streaming.html</a></p><p>Any library that offers a &quot;<code>ListT</code>&quot; type can use this result...and
 usually turn it into an effectful stream.</p><p>For example, the <em>pipes</em> library offers <code>runListT</code> so you can run this,
 constantly pulling out <code>a</code>s from the stream using the <code>m a</code>, feeding
 it in, and moving forward, all with the effect stream manipulation tools
 and resource handling of <em>pipes</em>.</p><p>This is useful because <em>auto</em>, the library, mainly provides tools for
 working with transformers for <em>value</em> streams, and not effect streams or
 streams of effects.  Using this, you can potentially have the best of
 both worlds.</p></div></div><h1 id="g:23">Re-exports</h1><div class="top"><p class="src">module <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html">Control.Applicative</a></p></div><div class="top"><p class="src">module <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html">Control.Arrow</a></p></div><div class="top"><p class="src">module <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html">Control.Category</a></p></div><div class="top"><p class="src">module <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html">Data.Functor.Identity</a></p></div><div class="top"><p class="src">module <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html">Data.Semigroup</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>