-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | DSL providing denotational, compositional semantics for
discrete-step, locally stateful, interactive programs,
games & automations.
--   
--   DSL providing denotational, compositional semantics for discrete-step,
--   locally stateful, interactive programs, games &amp; automations.
@package auto
@version 0.1.0.0

module Control.Auto.Tutorial


-- | This module exposes an "unsafe" interface for working with the
--   internal representation of "<a>Blip</a> streams". If you are
--   programming at the logic level or the application level, you should
--   thoroughly be able to avoid importing this, and should be happy with
--   importing the <a>Blip</a> type from <a>Control.Auto</a> and
--   <a>Blip</a> stream manipulators from <a>Control.Auto.Blip</a>.
--   
--   If, however, you are programming a framework, library, or backend, you
--   might find it useful to manually create your own <a>Blip</a>
--   streams/sources. In this case, this module will be useful.
--   
--   It is important, as with most of this library in general, to always
--   keep in mind when you are programming at the "logic" level, and when
--   you are programming at the "backend" level. If you can justify that
--   you are at the backend level and not at the logic level of whatever
--   you are programming, then this is useful. See more on
--   <a>Control.Auto.Tutorial</a>.
--   
--   Be sure, of course, that whatever <a>Blip</a> streams you do manually
--   construct preserve "<a>Blip</a> semantics", which is further defined
--   in <a>Control.Auto.Blip</a> and <a>Control.Auto.Tutorial</a>.
--   
--   You have been warned!
module Control.Auto.Blip.Internal

-- | A type representing a "discrete" sort of event-like thing. It's
--   supposed to represent something that happens alone, and one at a time,
--   as opposed to things that are "on" or "off" for large intervals at a
--   time.
--   
--   It's here mainly because it's a pretty useful abstraction in the
--   context of the many combinators found in various modules of this
--   library. If you think of an <tt><tt>Auto</tt> m a (<a>Blip</a> b)</tt>
--   as a "<a>Blip</a> stream", then there are various combinators and
--   functions that are specifically designed to manipulate "<a>Blip</a>
--   streams".
--   
--   For the purposes of the semantics of what <a>Blip</a> is supposed to
--   represent, its constructors are hidden. (Almost) all of the various
--   <a>Blip</a> combinators (and its very useful <a>Functor</a> instance)
--   "preserve <a>Blip</a>ness" --- one-at-a-time occurrences remain
--   one-at-a-time under all of these combinators, and you should have
--   enough so that direct access to the constructor is not needed.
--   
--   If you are creating a framework, library, or backend, you might want
--   to manually create <a>Blip</a> stream-producing <tt>Auto</tt>s for
--   your users to access. In this case, you can import the constructors
--   and useful internal (and, of course, semantically unsafe) functions
--   from <a>Control.Auto.Blip.Internal</a>.
data Blip a
NoBlip :: Blip a
Blip :: !a -> Blip a

-- | Merge two <a>Blip</a>s with a merging function. Is only a occuring
--   <a>Blip</a> if *both* <a>Blip</a>s are simultaneously occuring.
merge :: (a -> a -> a) -> Blip a -> Blip a -> Blip a

-- | Destruct a <a>Blip</a> by giving a default result if the <a>Blip</a>
--   is non-occuring and a function to apply on the contents, if the
--   <a>Blip</a> is occuring.
--   
--   Try not to use if possible, unless you are a framework developer. If
--   you're just making an application, try to use the other various
--   combinators in this library. It'll help you preserve the semantics of
--   what it means to be <a>Blip</a>py.
--   
--   Analogous to <a>maybe</a> from <a>Prelude</a>.
blip :: b -> (a -> b) -> Blip a -> b
instance Typeable Blip
instance Functor Blip
instance Show a => Show (Blip a)
instance Generic (Blip a)
instance Datatype D1Blip
instance Constructor C1_0Blip
instance Constructor C1_1Blip
instance NFData a => NFData (Blip a)
instance Serialize a => Serialize (Blip a)
instance Semigroup a => Monoid (Blip a)
instance Semigroup a => Semigroup (Blip a)


-- | This module defines and provides the core types, (smart) constructors,
--   and general utilities used by the <a>Auto</a> library.
--   
--   A lot of low-level functionality is provided here which is most likely
--   unnecessary for most applications; many are mostly for internal usage
--   or advanced/fine-grained usage; it also isn't really enough to do many
--   things with, either. It's recommended that you import
--   <a>Control.Auto</a> instead, which re-organizes the more useful parts
--   of this module in addition with useful parts of others to provide a
--   nice packaged entry point.
--   
--   For information on how to actually use these types, see
--   <a>Control.Auto.Tutorial</a>.
module Control.Auto.Core

-- | The Auto type. Basically represents a function containing its own
--   localized internal state. If you have an <tt><a>Auto</a> a b</tt>, you
--   can "step" it with <a>stepAuto</a> and an <tt>a</tt>, to get a
--   <tt>b</tt> and a "next <a>Auto</a>". The <tt>a</tt> is the input, and
--   the <tt>b</tt> is the output, and the next <a>Auto</a> is the
--   <a>Auto</a> with updated internal state.
--   
--   The "stepping" process can be monadic:
--   
--   <pre>
--   stepAuto :: Auto m a b -&gt; a -&gt; m (Output m a b)
--   </pre>
--   
--   So you can have access to, say, a shared environment using
--   <tt>Reader</tt> or something like that.
--   
--   <a>Auto</a> is mostly useful because of its <a>Functor</a>,
--   <a>Applicative</a>, <a>Category</a>, and <a>Arrow</a> (and
--   Arrow-related) instances. These allow you to modify, combine, chain,
--   and side-chain Autos in expressive way, allowing you to build up
--   complex ones from combinations of simple, primitive ones.
--   
--   TODO: see tutorial
--   
--   The <a>Auto</a> also contains information on its own serialization, so
--   you can serialize and re-load the internal state without actually
--   accessing it.
data Auto m a b

-- | Special case of <a>Auto</a> where the underlying <a>Monad</a> is
--   <a>Identity</a>.
type Auto' = Auto Identity

-- | Returns a string representation of the internal constructor of the
--   <a>Auto</a>. Useful for debugging the result of compositions and
--   functions and seeing how they affect the internal structure of the
--   <a>Auto</a>.
autoConstr :: Auto m a b -> String

-- | Re-structure <a>Auto</a> internals to use the <tt>Arb</tt>
--   ("arbitrary") constructors, as recursion-based mealy machines. Almost
--   always a bad idea in every conceivable situation. Why is it even here?
toArb :: Monad m => Auto m a b -> Auto m a b

-- | <a>Runs</a> the <a>Auto</a> through one step.
--   
--   Remember that at every step for an <tt><a>Auto</a> m a b</tt>, you
--   provide an <tt>a</tt> input and receive a <tt>b</tt> output with an
--   "updated"/"next" <a>Auto</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let a = mkAccum (+) 0 :: Auto Identity Int Int
--               -- an Auto that sums all of its input.
--   
--   &gt;&gt;&gt; let Identity (Output y a') = stepAuto a 3
--   
--   &gt;&gt;&gt; y      -- the result
--   3 :: Int
--   
--   &gt;&gt;&gt; :t a'   -- the updated 'Auto'
--   a' :: Auto Identity Int Int
--   </pre>
--   
--   (<a>Identity</a>, from <a>Data.Functor.Identity</a>, is the "dumb
--   Functor": <tt>data <a>Identity</a> a = <a>Identity</a> a</tt>)
--   
--   If you think of an <tt><a>Auto</a> m a b</tt> as a "stateful function"
--   of type <tt>a -&gt; m b</tt>, then <a>stepAuto</a> lets you "run" it.
stepAuto :: Monad m => Auto m a b -> a -> m (Output m a b)

-- | <a>stepAuto</a>, but for an <a>Auto'</a> --- the underlying
--   <a>Monad</a> is <a>Identity</a>.
stepAuto' :: Auto' a b -> a -> Output' a b

-- | Encode an <a>Auto</a> and its internal state into a <a>ByteString</a>.
encodeAuto :: Auto m a b -> ByteString

-- | <a>Resume</a> an <a>Auto</a> from its <a>ByteString</a> serialization,
--   giving a <a>Left</a> if the deserialization is not possible.
decodeAuto :: Auto m a b -> ByteString -> Either String (Auto m a b)

-- | Returns a <a>Put</a> --- instructions (from <a>Data.Serialize</a>) on
--   how to "freeze" the <a>Auto</a>, with its internal state, and save it
--   to a binary encoding. It can later be reloaded and "resumed" by
--   'loadAuto'/'decodeAuto'.
saveAuto :: Auto m a b -> Put

-- | Returns a <a>Get</a> from an <a>Auto</a> --- instructions (from
--   <a>Data.Serialize</a>) on taking a ByteString and "restoring" the
--   originally saved <a>Auto</a>, in the originally saved state.
loadAuto :: Auto m a b -> Get (Auto m a b)

-- | The output of a <a>stepAuto</a>. Contains the "result" value of the
--   stepping (<a>outRes</a>), and the "next <a>Auto</a>", <a>outAuto</a>.
--   
--   An <tt><a>Auto</a> m a b</tt> will produce an <tt><a>Output</a> m a
--   b</tt>; when "stepped" with an <tt>a</tt>, the "result"
--   (<a>outRes</a>) is a <tt>b</tt>.
--   
--   Really, you can just think of this as a fancy tuple.
data Output m a b
Output :: b -> Auto m a b -> Output m a b

-- | Result value of a step
outRes :: Output m a b -> b

-- | The next <a>Auto</a>
outAuto :: Output m a b -> Auto m a b

-- | Special case of <a>Output</a> where the underlying <a>Monad</a> of
--   <a>outAuto</a> is <a>Identity</a>.
type Output' = Output Identity

-- | Map two functions onto both fields of an <a>Output</a>.
--   
--   If you want to map an <tt>a -&gt; b</tt> onto both fields (the result
--   and the result of the next Auto), you can use the <a>Functor</a>
--   instance instead.
onOutput :: (b -> b') -> (Auto m a b -> Auto m a' b') -> Output m a b -> Output m a' b'

-- | Map a function onto the <a>outRes</a> of an <a>Output</a>: the
--   "result" of a <a>stepAuto</a>.
--   
--   Useful for completely pointless and probably obfuscating point free
--   code :D
onOutRes :: (b -> b) -> Output m a b -> Output m a b

-- | Map a function onto the 'outAuto of an <a>Output</a>, the resulting
--   <a>Auto</a>. See note on <a>onOutRes</a>.
onOutAuto :: (Auto m a b -> Auto m a' b) -> Output m a b -> Output m a' b

-- | Construct the <a>Auto</a> that always yields the given value, ignoring
--   its input.
--   
--   Provided for API constency, but you should really be using <a>pure</a>
--   from the <a>Applicative</a> instance, from <a>Control.Applicative</a>,
--   which does the same thing.
mkConst :: b -> Auto m a b

-- | Construct the <a>Auto</a> that always "executes" the given monadic
--   value at every step, yielding the result and ignoring its input.
--   
--   Provided for API consistency, but you shold really be using
--   <tt>effect</tt> from <a>Control.Auto.Effects</a>, which does the same
--   thing.
mkConstM :: m b -> Auto m a b

-- | Construct a stateless <a>Auto</a> that simply applies the given (pure)
--   function to every input, yielding the output.
--   
--   This is rarely needed; you should be using <a>arr</a> from the
--   <a>Arrow</a> instance, from <a>Control.Arrow</a>.
mkFunc :: (a -> b) -> Auto m a b

-- | Construct a statelss <a>Auto</a> that simply applies and executes the
--   givne (monadic) function to every input, yielding the output.
--   
--   It's recommended that you use <tt>arrM</tt> from
--   <a>Control.Auto.Effects</a>. This is only really provided for
--   consistency.
mkFuncM :: (a -> m b) -> Auto m a b

-- | Construct an <a>Auto</a> from a state transformer: an <tt>a -&gt; s
--   -&gt; (b, s)</tt> gives you an <tt><a>Auto</a> m a b</tt>, for any
--   <a>Monad</a> <tt>m</tt>. At every step, it takes in the <tt>a</tt>
--   input, runs the function with the stored internal state, returns the
--   <tt>b</tt> result, and now contains the new resulting state. You have
--   to intialize it with an initial state, of course.
--   
--   Try not to use this if it's ever avoidable, unless you're a framework
--   developer or something. Try make something by combining/composing the
--   various <a>Auto</a> combinators.
--   
--   This version is a wrapper around <a>mkAuto</a>, that keeps track of
--   the serialization and re-loading of the internal state for you, so you
--   don't have to deal with it explicitly.
--   
--   If your state <tt>s</tt> does not have a <a>Serialize</a> instance,
--   then you should either write a meaningful one, provide the
--   serialization methods manually with <a>mkState'</a>, or throw away
--   serializability and use <a>mkState_</a>.
mkState :: Serialize s => (a -> s -> (b, s)) -> s -> Auto m a b

-- | A version of <a>mkState</a>, where the internal state isn't
--   serialized. It can be "saved" and "loaded", but the state is lost in
--   the process.
--   
--   Useful if your state <tt>s</tt> cannot have a meaningful
--   <a>Serialize</a> instance.
mkState_ :: (a -> s -> (b, s)) -> s -> Auto m a b

-- | Construct an <a>Auto</a> from a "monadic" state transformer: <tt>a
--   -&gt; s -&gt; m (b, s)</tt> gives you an <tt><a>Auto</a> m a b</tt>.
--   At every step, it takes in the <tt>a</tt> input, runs the function
--   with the stored internal state and "executes" the <tt>m (b, s)</tt> to
--   get the <tt>b</tt> output, and stores the <tt>s</tt> as the new,
--   updated state. Must be initialized with an initial state.
--   
--   Try not to use this if it's ever avoidable, unless you're a framework
--   developer or something. Try make something by combining/composing the
--   various <a>Auto</a> combinators.
--   
--   This version is a wrapper around <a>mkAuto</a>, that keeps track of
--   the serialization and re-loading of the internal state for you, so you
--   don't have to deal with it explicitly.
--   
--   If your state <tt>s</tt> does not have a <a>Serialize</a> instance,
--   then you should either write a meaningful one, provide the
--   serialization methods manually with <a>mkStateM'</a>, or throw away
--   serializability and use <a>mkStateM_</a>.
mkStateM :: Serialize s => (a -> s -> m (b, s)) -> s -> Auto m a b

-- | A version of <a>mkStateM</a>, where the internal state isn't
--   serialized. It can be "saved" and "loaded", but the state is lost in
--   the process.
--   
--   Useful if your state <tt>s</tt> cannot have a meaningful
--   <a>Serialize</a> instance.
mkStateM_ :: (a -> s -> m (b, s)) -> s -> Auto m a b

-- | A version of <a>mkState</a>, where the internal state doesn't have a
--   <a>Serialize</a> instance, so you provide your own instructions for
--   getting and putting the state.
mkState' :: Get s -> (s -> Put) -> (a -> s -> (b, s)) -> s -> Auto m a b

-- | A version of <a>mkStateM</a>, where the internal state doesn't have a
--   <a>Serialize</a> instance, so you provide your own instructions for
--   getting and putting the state.
mkStateM' :: Get s -> (s -> Put) -> (a -> s -> m (b, s)) -> s -> Auto m a b

-- | Construct an <a>Auto</a> from a "folding" function: <tt>b -&gt; a
--   -&gt; b</tt> yields an <tt><a>Auto</a> m a b</tt>. Basically acts like
--   a <a>foldl</a> or a <a>scanl</a>. There is an internal accumulator
--   that is "updated" with an <tt>a</tt> at every step. Must be given an
--   initial accumulator.
--   
--   Example: an <a>Auto</a> that sums up all of its input.
--   
--   <pre>
--   &gt;&gt;&gt; let summer = mkAccum (+) 0
--   
--   &gt;&gt;&gt; let Output sum1 summer' = stepAuto summer 3
--   
--   &gt;&gt;&gt; sum1
--   3
--   
--   &gt;&gt;&gt; let Output sum2 _       = stepAuto summer'' 10
--   
--   &gt;&gt;&gt; sum2
--   13
--   </pre>
--   
--   If your accumulator <tt>b</tt> does not have a <a>Serialize</a>
--   instance, then you should either write a meaningful one, or throw away
--   serializability and use <a>mkAccum_</a>.
mkAccum :: Serialize b => (b -> a -> b) -> b -> Auto m a b

-- | A version of 'mkAccum_, where the internal accumulator isn't
--   serialized. It can be "saved" and "loaded", but the state is lost in
--   the process.
--   
--   Useful if your accumulator <tt>b</tt> cannot have a meaningful
--   <a>Serialize</a> instance.
mkAccum_ :: (b -> a -> b) -> b -> Auto m a b

-- | Construct an <a>Auto</a> from a "monadic" "folding" function: <tt>b
--   -&gt; a -&gt; m b</tt> yields an <tt><a>Auto</a> m a b</tt>. Basically
--   acts like a <a>foldM</a> or <tt>scanM</tt> (if it existed). here is an
--   internal accumulator that is "updated" with an input <tt>a</tt> with
--   the result of the executed <tt>m b</tt> at every step. Must be given
--   an initial accumulator.
--   
--   If your accumulator <tt>b</tt> does not have a <a>Serialize</a>
--   instance, then you should either write a meaningful one, or throw away
--   serializability and use <a>mkAccumM_</a>.
mkAccumM :: (Serialize b, Monad m) => (b -> a -> m b) -> b -> Auto m a b

-- | A version of 'mkAccumM_, where the internal accumulator isn't
--   serialized. It can be "saved" and "loaded", but the state is lost in
--   the process.
--   
--   Useful if your accumulator <tt>b</tt> cannot have a meaningful
--   <a>Serialize</a> instance.
mkAccumM_ :: Monad m => (b -> a -> m b) -> b -> Auto m a b

-- | A "delayed" version of <a>mkAccum</a>, where the first output is
--   actually the initial state of the accumulator. Useful in recursive
--   bindings.
mkAccumD :: Serialize b => (b -> a -> b) -> b -> Auto m a b

-- | The non-resuming/non-serializing version of <a>mkAccumD</a>.
mkAccumD_ :: (b -> a -> b) -> b -> Auto m a b

-- | A "delayed" version of <a>mkAccumM</a>, where the first output is
--   actually the initial state of the accumulator. Useful in recursive
--   bindings.
mkAccumMD :: (Serialize b, Monad m) => (b -> a -> m b) -> b -> Auto m a b

-- | The non-resuming/non-serializing version of <a>mkAccumMD</a>.
mkAccumMD_ :: Monad m => (b -> a -> m b) -> b -> Auto m a b

-- | Construct an <a>Auto</a> by explicity giving its serialization,
--   deserialization, and the (pure) function from <tt>a</tt> to <tt>b</tt>
--   and the "next <a>Auto</a>".
--   
--   Ideally, you wouldn't have to use this unless you are making your own
--   framework. Try your best to make what you want by assembling primtives
--   together.
mkAuto :: Get (Auto m a b) -> Put -> (a -> Output m a b) -> Auto m a b

-- | Like <a>mkAuto</a>, but without any way of meaningful serializing or
--   deserializing.
--   
--   Be careful! This <a>Auto</a> can still carry arbitrary internal state,
--   but it cannot be meaningfully serialized or re-loaded/resumed. You can
--   still pretend to do so using
--   'loadAuto'/'saveAuto'/'encodeAuto'/'decodeAuto' (and the type system
--   won't stop you), but when you try to "resume"/decode it, its state
--   will be lost.
mkAuto_ :: (a -> Output m a b) -> Auto m a b

-- | Construct an <a>Auto</a> by explicitly giving its serializiation,
--   deserialization, and the (monadic) function from <tt>a</tt> to
--   <tt>b</tt> and the "next <a>Auto</a>".
--   
--   Ideally, you wouldn't have to use this unless you are making your own
--   framework. Try your best to make what you want by assembling primtives
--   together.
mkAutoM :: Get (Auto m a b) -> Put -> (a -> m (Output m a b)) -> Auto m a b

-- | Like <a>mkAutoM</a>, but without any way of meaningful serializing or
--   deserializing.
--   
--   Be careful! This <a>Auto</a> can still carry arbitrary internal state,
--   but it cannot be meaningfully serialized or re-loaded/resumed. You can
--   still pretend to do so using
--   'loadAuto'/'saveAuto'/'encodeAuto'/'decodeAuto' (and the type system
--   won't stop you), but when you try to "resume"/decode it, its state
--   will be reset.
mkAutoM_ :: (a -> m (Output m a b)) -> Auto m a b

-- | Force the serializing components of an <a>Auto</a>.
forceSerial :: Auto m a b -> Auto m a b

-- | A special <a>Auto</a> that acts like the <a>id</a> <a>Auto</a>, but
--   forces results as they come through to be fully evaluated, when
--   composed with other <a>Auto</a>s.
forcer :: NFData a => Auto m a a

-- | A special <a>Auto</a> that acts like the <a>id</a> <a>Auto</a>, but
--   forces results as they come through to be evaluated to Weak Head
--   Normal Form, with <a>seq</a>, when composed with other <a>Auto</a>s.
seqer :: Auto m a a
instance Monad m => Functor (Output m a)
instance Generic (Output m a b)
instance Datatype D1Output
instance Constructor C1_0Output
instance Selector S1_0_0Output
instance Selector S1_0_1Output
instance (Monad m, Floating b) => Floating (Output m a b)
instance (Monad m, Fractional b) => Fractional (Output m a b)
instance (Monad m, Num b) => Num (Output m a b)
instance (Monad m, Monoid b) => Monoid (Output m a b)
instance (Monad m, Semigroup b) => Semigroup (Output m a b)
instance (Monad m, Floating b) => Floating (Auto m a b)
instance (Monad m, Fractional b) => Fractional (Auto m a b)
instance (Monad m, Num b) => Num (Auto m a b)
instance (Monad m, Monoid b) => Monoid (Auto m a b)
instance (Monad m, Semigroup b) => Semigroup (Auto m a b)
instance MonadFix m => ArrowLoop (Auto m)
instance Monad m => ArrowChoice (Auto m)
instance Monad m => Arrow (Auto m)
instance Monad m => Profunctor (Auto m)
instance Monad m => Category (Auto m)
instance Monad m => Applicative (Auto m a)
instance Monad m => Functor (Auto m a)
instance Monad m => Applicative (Output m a)


-- | This module contains various <a>Auto</a>s that act as "producers",
--   ignoring their input and producing output through some source or a
--   pure/monadic function.
--   
--   <h3>Constant producers</h3>
--   
--   Are you looking for "constant producers"? <a>Auto</a>s that constantly
--   output the same thing, or repeatedly execute the same monadic action
--   and return the result? To keep things clean, they aren't re-exported
--   here. But you'll find the "constant <a>Auto</a>" as pure from the
--   <tt>Applicative</tt> interface:
--   
--   <pre>
--   <tt>pure</tt> :: <a>Monad</a> m =&gt; b -&gt; <a>Auto</a> m a b
--   </pre>
--   
--   And also the "repeatedly execute and return" <a>Auto</a> as
--   <tt>effect</tt> from <a>Control.Auto.Effects</a>:
--   
--   <pre>
--   <tt>effect</tt> :: <a>Monad</a> m =&gt; m b -&gt; <a>Auto</a> m a b
--   </pre>
module Control.Auto.Generate

-- | Construct an <a>Auto</a> that ignores its input and just continually
--   emits elements from the given list. Ouputs <a>Nothing</a> forever
--   after reaching the end of the list.
--   
--   Serializes itself by storing the entire rest of the list in binary, so
--   if your list is long, it might take up a lot of space upon storage. If
--   your list is infinite, it makes an infinite binary, so be careful!
--   
--   <ul>
--   <li>Storing: O(n) time and space on length of remaining list</li>
--   <li>Loading: O(1) time in the number of times the <a>Auto</a> has been
--   stepped + O(n) time in the length of the remaining list.</li>
--   </ul>
fromList :: Serialize b => [b] -> Auto m a (Maybe b)

-- | The non-resuming/non-serializing version of <a>fromList</a>.
fromList_ :: [b] -> Auto m a (Maybe b)

-- | A version of <a>fromList</a> that is safe for long or infinite lists,
--   or lists with unserializable elements.
--   
--   There is a small cost in the time of loading/resuming, which is
--   <tt>O(n)</tt> on the number of times the Auto had been stepped at the
--   time of saving. This is because it has to drop the <tt>n</tt> first
--   elements in the list, to "resume" to the proper position.
--   
--   <ul>
--   <li>Storing: O(1) time and space on the length of the remaining
--   list</li>
--   <li>Loading: O(n) time on the number of times the <a>Auto</a> has been
--   stepped, maxing out at O(n) on the length of the entire input
--   list.</li>
--   </ul>
fromLongList :: [b] -> Auto m a (Maybe b)

-- | Analogous to <a>iterate</a> from <a>Prelude</a>. Keeps accumulator
--   value and continually applies the function to the value at every step,
--   outputting the result.
--   
--   The first result is the initial accumulator value.
--   
--   <pre>
--   &gt;&gt;&gt; let (y, _) = stepAutoN' 10 (iterator (*2) 1) ()
--   
--   &gt;&gt;&gt; y
--   [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
--   </pre>
iterator :: Serialize b => (b -> b) -> b -> Auto m a b

-- | The non-resuming/non-serializing version of <a>iterator</a>.
iterator_ :: (b -> b) -> b -> Auto m a b

-- | Like <a>iterator</a>, but with a monadic function.
iteratorM :: (Serialize b, Monad m) => (b -> m b) -> b -> Auto m a b

-- | The non-resuming/non-serializing version of <a>iteratorM</a>.
iteratorM_ :: Monad m => (b -> m b) -> b -> Auto m a b

-- | Analogous to <tt>unfoldr</tt> from <a>Prelude</a>. "unfold" out the
--   outputs of an <a>Auto</a>; maintains an accumulator of type
--   <tt>c</tt>, and at every step, applies the unfolding function to the
--   accumulator. If the result is <a>Nothing</a>, then the rest of the
--   Auto will be <a>Nothing</a> forever. If the result is <tt><a>Just</a>
--   (y, acc)</tt>, outputs <tt>y</tt> and stores <tt>acc</tt> as the new
--   accumulator.
--   
--   Given an initial accumulator.
unfold :: Serialize c => (c -> Maybe (b, c)) -> c -> Auto m a (Maybe b)

-- | The non-resuming &amp; non-serializing version of <a>unfold</a>.
unfold_ :: (c -> Maybe (b, c)) -> c -> Auto m a (Maybe b)

-- | Like <a>unfold</a>, but the unfolding function is monadic.
unfoldM :: (Serialize c, Monad m) => (c -> m (Maybe (b, c))) -> c -> Auto m a (Maybe b)

-- | The non-resuming &amp; non-serializing version of <a>unfoldM</a>.
unfoldM_ :: Monad m => (c -> m (Maybe (b, c))) -> c -> Auto m a (Maybe b)


-- | This module contains various <a>Auto</a> transformers for manipulating
--   the flow of time/stepping rate of an <a>Auto</a>.
--   
--   Many of these are <a>Auto</a> "transformers", meaning that they take
--   in an <a>Auto</a> and return a transformed <a>Auto</a>, with new
--   stepping behavior.
--   
--   For example, there is <a>accelerate</a>:
--   
--   <pre>
--   <a>accelerate</a> :: <a>Monad</a> m =&gt; <a>Int</a> -&gt; <a>Auto</a> m a b -&gt; <a>Auto</a> m a [b]
--   </pre>
--   
--   <tt><a>accelerate</a> n</tt> turns an <a>Auto</a> into an <a>Auto</a>
--   that "steps itself" <tt>n</tt> times for every single input/step. The
--   result is a list of the results of each single step.
--   
--   There are also various <a>Auto</a>s for observing the passage of time
--   (<a>count</a>) and actiong as a "delay" or a way to access the
--   previously stepped values of an <a>Auto</a>.
--   
--   TODO: dropping first few elements
module Control.Auto.Time

-- | A simple <a>Auto</a> that outputs the step count. First output is 0.
--   
--   TODO: should be 1?
count :: (Serialize b, Num b) => Auto m a b

-- | A non-resuming/non-serializing version of <a>count</a>.
count_ :: Num b => Auto m a b

-- | An <a>Auto</a> that returns the last value received by it. Given an
--   "initial value" to output first.
--   
--   This is (potentially) a <b>very dangerous</b> <a>Auto</a>, because its
--   usage and its very existence opens the door to breaking
--   denotative/declarative style and devolving into imperative style
--   coding. However, when used where it is supposed to be used, it is more
--   or less invaluable, and will be an essential part of many programs.
--   
--   Its main usage is for dealing with bindings. If you ever are laying
--   out recursive bindings in a high-level/denotative way, you need to
--   have at least one value be able to have a "initial output" without
--   depending on anything else. <a>lastVal</a> and <a>delay</a> allow you
--   to do this.
--   
--   See the <a>recursive</a> example for more information on the
--   appropriate usage of <a>lastVal</a> and <a>delay</a>.
lastVal :: Serialize a => a -> Auto m a a

-- | The non-resuming/non-serializing version of <a>lastVal</a>.
lastVal_ :: a -> Auto m a a

-- | An alias for <a>lastVal</a>; used in contexts where "delay" is more a
--   meaningful description than "last value". All of the warnings for
--   <a>lastVal</a> still apply, so you should probably read it if you
--   haven't :)
delay :: Serialize a => a -> Auto m a a

-- | The non-resuming/non-serializing version of <a>delay</a>.
delay_ :: a -> Auto m a a

-- | Like <a>delay</a>, except has as many "initial values" as the input
--   list. Outputs every item in the input list in order before returning
--   the first received value.
--   
--   <pre>
--   delayList [y0] = delay y0
--   </pre>
delayList :: (Serialize a, Monad m) => [a] -> Auto m a a

-- | The non-resuming/non-serializing version of <a>delayList</a>.
delayList_ :: Monad m => [a] -> Auto m a a

-- | Like <a>delay</a>, except delays the desired number of steps with the
--   same initial output value.
--   
--   <pre>
--   delayN n x0 = delayList (replicate n x0)
--   </pre>
--   
--   <pre>
--   delayN 1 x0 = delay x0
--   </pre>
delayN :: (Serialize a, Monad m) => Int -> a -> Auto m a a

-- | The non-resuming/non-serializing version of <a>delayN</a>
delayN_ :: Monad m => Int -> a -> Auto m a a

-- | "stretch" an <a>Auto</a> out, slowing time. <tt><a>stretch</a> n
--   a</tt> will take one input, repeat the same output <tt>n</tt> times
--   (ignoring input), and then take another.
--   
--   <pre>
--   &gt;&gt;&gt; let a       = stretch 2 (mkAccum (+) 0)
--   
--   &gt;&gt;&gt; let (ys, _) = overList' a [1,8,5,4,3,7,2,0]
--   
--   &gt;&gt;&gt; ys
--      [1,1,6,6,9,9,11,11]
--   -- [1,_,5,_,3,_,2 ,_ ] &lt;-- the inputs
--   </pre>
stretch :: (Serialize b, Monad m) => Int -> Auto m a b -> Auto m a b

-- | The non-resuming/non-serializing version of <a>stretch</a>.
stretch_ :: Monad m => Int -> Auto m a b -> Auto m a b

-- | Like <a>stretch</a>, but instead of holding the the "stretched"
--   outputs, emits a <a>Blip</a> every time the stretched <a>Auto</a>
--   "progresses" (every <tt>n</tt> ticks)
--   
--   See <a>stretch</a> for more information.
--   
--   <pre>
--   &gt;&gt;&gt; let a = stretchB 2 (mkAccum (+) 0)
--   
--   &gt;&gt;&gt; let (ys, _) = overList' a [1,8,5,4,3,7,2,0]
--   
--   &gt;&gt;&gt; ys
--   [Blip 1, NoBlip, Blip 6, NoBlip, Blip 9, NoBlip, Blip 11, NoBlip]
--   </pre>
stretchB :: Monad m => Int -> Auto m a b -> Auto m a (Blip b)

-- | <tt><a>accelerate</a> n a</tt> turns an <a>Auto</a> <tt>a</tt> into an
--   "accelerated" <a>Auto</a>, where every input is fed into the
--   <a>Auto</a> <tt>n</tt> times. All of the results are collected in the
--   output.
--   
--   The same input is fed repeatedly <tt>n</tt> times.
--   
--   <pre>
--   &gt;&gt;&gt; let a = accelerate 3 (mkAccum (+) 0)
--   
--   &gt;&gt;&gt; let Output ys1 a' = stepAuto' a 5
--   
--   &gt;&gt;&gt; ys1
--   [5,10,15]
--   
--   &gt;&gt;&gt; let Output ys2 _  = stepAuto' a' (-8)
--   
--   &gt;&gt;&gt; ys2
--   [7,-1,-9]
--   </pre>
accelerate :: Monad m => Int -> Auto m a b -> Auto m a [b]

-- | <tt><a>accelerateWith</a> xd n a</tt> behaves like
--   <tt><a>accelerate</a> n a</tt>, except instead of <i>repeating</i> the
--   same intput <tt>n</tt> times, that input is fed once; the rest of the
--   <tt>n</tt> times, <tt>a</tt> is fed <tt>xd</tt>, the "default"
--   <tt>x</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let a = accelerateWith (-1) 3 (mkAccum (+) 0)
--   
--   &gt;&gt;&gt; let Output ys1 a' = stepAuto' a 5
--   
--   &gt;&gt;&gt; ys1
--   [5,4,3]    -- fed 5, then (-1) twice
--   
--   &gt;&gt;&gt; let Output ys2 _  = stepAuto' a' 14
--   
--   &gt;&gt;&gt; ys2
--   [17,16,15] -- fed 14, then (-1) twice
--   </pre>
accelerateWith :: Monad m => a -> Int -> Auto m a b -> Auto m a [b]

-- | Turns an <a>Auto</a> into an "accelerated" <a>Auto</a>; an <a>Auto</a>
--   that takes an <tt>a</tt> and returns a <tt>b</tt> turns into an
--   <a>Auto</a> that takes a <i>list</i> of <tt>a</tt> and returns a
--   <i>list</i> of <tt>b</tt> from running that <a>Auto</a> on all of
--   those <tt>a</tt> in order.
--   
--   <pre>
--   &gt;&gt;&gt; let a = accelOverList (mkAccum (+) 0)
--   
--   &gt;&gt;&gt; let Output ys1 a' = stepAuto' a [3,9,2]
--   
--   &gt;&gt;&gt; ys1
--   [3, 12, 14]
--   
--   &gt;&gt;&gt; let Output ys2 _  = stepAuto' a' [8,5]
--   
--   &gt;&gt;&gt; ys2
--   [22, 30]
--   </pre>
accelOverList :: Monad m => Auto m a b -> Auto m [a] [b]

-- | Takes an <a>Auto</a> that produces <tt>(b, <a>Blip</a> c)</tt>, and
--   turns it into an <a>Auto</a> that produces <tt>([b], c)</tt>.
--   
--   Basically, the new <a>Auto</a> "squishes together" the periods of
--   output between each <a>Blip</a> occurrnece. All outputs between each
--   <a>Blip</a> occurrence are accumulated and returned in the resulting
--   <tt>[b]</tt>.
--   
--   It "does this" in the same manner as <a>accelerateWith</a> and
--   <a>fastForward</a>: first feed the input, then step repeatedly with
--   the default input value.
--   
--   <pre>
--   &gt;&gt;&gt; let a :: Auto' Int (Int, Blip String)
--           a = proc i -&gt; do
--                   sums &lt;- mkAccum (+) 0 -&lt; i
--                   blp  &lt;- inB 3         -&lt; i     -- Blip at every 3 ticks.
--                   id    -&lt; (sums, show &lt;$&gt; blp)
--   
--   &gt;&gt;&gt; let skipA :: Auto' Int ([Int], String)
--           skipA = skipTo (-1) a
--   
--   &gt;&gt;&gt; let Output res1 skipA' = stepAuto' skipA 8
--   
--   &gt;&gt;&gt; res1
--   ([8,7,6], "6")     -- fed 8 first, then (-1) repeatedly
--   
--   &gt;&gt;&gt; let Output res2 _      = stepAuto' skipA' 5
--   
--   &gt;&gt;&gt; res2
--   ([11,10,9], "9")   -- fed 5 first, then (-1) repeatedly
--   </pre>
skipTo :: Monad m => a -> Auto m a (b, Blip c) -> Auto m a ([b], c)

-- | Takes an <a>Auto</a> and basically "removes" the periods in which it
--   returns <a>Nothing</a>, by re-running the <a>Auto</a> with the same
--   input until it outputs a <a>Just</a>.
--   
--   Basically, it magically turns an <tt><a>Auto</a> m a (<a>Maybe</a>
--   b)</tt> into an <tt><a>Auto</a> m a b</tt>, by skipping over each
--   <a>Nothing</a>.
--   
--   It does this in the same manner as <a>accelerateWith</a> and
--   <a>skipTo</a>: first feed in the input, then step repeatedly with the
--   default input value.
--   
--   <pre>
--   &gt;&gt;&gt; let a :: Auto' Int (Maybe Int)
--           a = proc i -&gt; do
--                   sums &lt;- mkAccum (+) 0 -&lt; i
--                   id    -&lt; if (i `mod` 5) == 0
--                              then Just i
--                              else Nothing
--   
--   &gt;&gt;&gt; let ffA :: Auto' Int Int
--           ffA = fastForward (-1) a
--   
--   &gt;&gt;&gt; let Output y1 ffA' = stepAuto' ffA 7
--   
--   &gt;&gt;&gt; y1
--   5          -- went from 7 (Nothing), to 6 (Nothing), to 5 (Just 5)
--   
--   &gt;&gt;&gt; let Output y2 _    = stepAuto' ffA' (-9)
--   -5         -- went from -4 (Nothing) to -5 (Just (-5))
--   </pre>
fastForward :: Monad m => a -> Auto m a (Maybe b) -> Auto m a b

-- | Same behavior as <a>fastForward</a>, except accumulates all of the
--   <tt><a>Left</a> c</tt> outputs in a list.
fastForwardEither :: Monad m => a -> Auto m a (Either c b) -> Auto m a (b, [c])


-- | The <a>Auto</a>s in this module are all dedicated to managing and
--   working with "collections" of <a>Auto</a>s: <a>Auto</a>s that can
--   contain and manage and feed/multiplex input through several internal
--   <a>Auto</a>s, and collect the results in the end. These are
--   particularly useful for managing collection of <a>Auto</a>s that can
--   be added to or deleted from, like monsters in a map, or bullets.
--   
--   A lot of these <a>Auto</a>s take advantaage <i>Interval</i> semantics
--   (<a>Maybe</a> for continuous on/off periods) to signal when they want
--   to be removed or turned off.
--   
--   For these, the best way to learn them is probably by seeing examples.
--   However, if there is a time when you might want collections of things
--   that can be added to or removed from dynamically, this might be what
--   you are looking for.
module Control.Auto.Collection

-- | Give a list of <tt><a>Auto</a> m a b</tt> and get back an
--   <tt><a>Auto</a> m [a] [b]</tt> --- take a list of <tt>a</tt>'s and
--   feed them to each of the <a>Auto</a>s, and collects their output
--   <tt>b</tt>'s.
--   
--   If the input list doesn't have enough items to give to all of the
--   <a>Auto</a>s wrapped, then use the given default value. Any extra
--   items in the input list are ignored.
--   
--   For an example, we're going to make a list of <a>Auto</a>s that output
--   a running sum of all of their inputs, but each starting at a different
--   beginning value:
--   
--   <pre>
--   summerList :: [Auto' Int Int]
--   summerList = map sumFrom [0, 10, 20, 30]
--   </pre>
--   
--   Then, let's throw it into <a>zipAuto</a> with a sensible default
--   value, 0:
--   
--   <pre>
--   summings0 :: Auto' [Int] [Int]
--   summings0 = zipAuto 0 summerList
--   </pre>
--   
--   Now let's try it out!
--   
--   <pre>
--   &gt;&gt;&gt; let Output r1 summings1 = stepAuto' summings0 [1,2,3,4]
--   
--   &gt;&gt;&gt; r1
--   [ 1, 12, 23, 34]
--   
--   &gt;&gt;&gt; let Output r2 summings2 = stepAuto' summings1 [5,5]
--   
--   &gt;&gt;&gt; r2
--   [ 6, 17, 23, 34]
--   
--   &gt;&gt;&gt; let Output r3 _         = stepAuto' summings2 [10,1,10,1,10000]
--   
--   &gt;&gt;&gt; r3
--   [16, 18, 33, 35]
--   </pre>
zipAuto :: Monad m => a -> [Auto m a b] -> Auto m [a] [b]

-- | Like <a>zipAuto</a>, but delay the input by one step, using the
--   default value as the delaying value.
--   
--   Let's try the example from <a>zipAuto</a>, except with <a>dZipAuto</a>
--   instead:
--   
--   <pre>
--   summerList :: [Auto' Int Int]
--   summerList = map sumFrom [0, 10, 20, 30]
--   
--   summings0 :: Auto' [Int] [Int]
--   summings0 = dZipAuto 0 summerList
--   </pre>
--   
--   Trying it out:
--   
--   <pre>
--   &gt;&gt;&gt; let Output r1 summings1 = stepAuto' summings0 [1,2,3,4]
--   
--   &gt;&gt;&gt; r1
--   [ 0, 10, 20, 30]
--   
--   &gt;&gt;&gt; let Output r2 summings2 = stepAuto' summings1 [5,5]
--   
--   &gt;&gt;&gt; r2
--   [ 1, 12, 23, 34]
--   
--   &gt;&gt;&gt; let Output r3 summings3 = stepAuto' summings2 [10,1,10,1,10000]
--   
--   &gt;&gt;&gt; r3
--   [ 6, 17, 23, 34]
--   
--   &gt;&gt;&gt; let Output r4 _         = stepAuto' summings3 [100,100,100,100]
--   
--   &gt;&gt;&gt; r4
--   [16, 18, 33, 35]
--   </pre>
dZipAuto :: (Serialize a, Monad m) => a -> [Auto m a b] -> Auto m [a] [b]

-- | The non-serializing/non-resuming version of <a>dZipAuto</a>.
dZipAuto_ :: Monad m => a -> [Auto m a b] -> Auto m [a] [b]

-- | Takes a bunch of <a>Auto</a>s that take <a>Blip</a> streams, and turns
--   them into an <a>Auto</a> that takes a bunch of <a>Blip</a> streams and
--   feeds them into each one in order.
--   
--   It's basically like <a>zipAuto</a>, except instead of taking in normal
--   streams of values, it takes in <a>Blip</a> streams of values.
--   
--   If the input streams ever number less than the number of <a>Auto</a>s
--   zipped, then the other <a>Auto</a>s are just stepped with a
--   <a>Blip</a> stream that doesn't emit in that step.
zipAutoB :: Monad m => [Auto m (Blip a) b] -> Auto m [Blip a] [b]

-- | A delayed version of <a>zipAutoB</a>
dZipAutoB :: (Serialize a, Monad m) => [Auto m (Blip a) b] -> Auto m [Blip a] [b]

-- | The non-serializing/non-resuming version of <a>dZipAutoB</a>.
dZipAutoB_ :: Monad m => [Auto m (Blip a) b] -> Auto m [Blip a] [b]

-- | A dynamic box of <a>Auto</a>s. Takes a list of inputs to feed to each
--   one, in the order that they were added. Also takes a <a>Blip</a>
--   stream, which emits with new <a>Auto</a>s to to the box.
--   
--   Add new <a>Auto</a>s to the box however you want with the <a>Blip</a>
--   stream. It collects all of the <a>Just</a> outputs and outputs them
--   all. Whenever any of the wrapped <a>Auto</a>s begins to output
--   <a>Nothing</a>, it is removed from the box.
--   
--   The adding/removing aside, the routing of the inputs (the first field
--   of the tuple) to the internal <a>Auto</a>s and the outputs behaves the
--   same as with <a>zipAuto</a>.
--   
--   This will be a pretty powerful collection if you ever imagine adding
--   and destroying behaviors dynamically...like spawning new enemies, or
--   something like that.
--   
--   Let's see an example...here we are going to be throwing a bunch of
--   <a>Auto</a>s that count to five and then die into our
--   <a>dynZip_</a>...once every other step.
--   
--   <pre>
--   -- count upwards, then die when you reach 5
--   countThenDie :: Auto' () (Maybe Int)
--   countThenDie = onFor 5 . iterator (+1) 1
--   
--   -- emit a new <tt>countThenDie</tt> every two steps
--   throwCounters :: Auto' () (Blip [Auto' () (Maybe Int)])
--   throwCounters = tagBlips [countThenDie] . every 2
--   
--   a :: Auto' () [Int]
--   a = proc _ -&gt; do
--       newCounter &lt;- throwCounters -&lt; ()
--       dynZip_ ()  -&lt; (repeat (), newCounter)
--   
--   -- or
--   a' = dynZip_ () . (pure (repeat ()) &amp;&amp;&amp; throwCounters)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (res, _) = stepAutoN' 15 a ()
--   
--   &gt;&gt;&gt; res
--   [[], [1            ]
--      , [2,           ]
--      , [3, 1         ]
--      , [4, 2         ]
--      , [5, 3, 1      ]
--      , [   4, 2      ]
--      , [   5, 3, 1   ]
--      , [      4, 2   ]
--      , [      5, 3, 1]
--   ]
--   </pre>
--   
--   This is a little unweildy, because <a>Auto</a>s maybe disappearing out
--   of the thing while you are trying to feed inputs into it. You might be
--   feeding an input to an <a>Auto</a>...but one of the <a>Auto</a>s
--   before it on the list has disappeared, so it accidentally goes to the
--   wrong one.
--   
--   Because of this, it is suggested that you use <a>dynMap_</a>, which
--   allows you to "target" labeled <a>Auto</a>s with your inputs.
--   
--   TODO: Consider putting it in and running inputs immediately?
dynZip_ :: Monad m => a -> Auto m ([a], Blip [Auto m a (Maybe b)]) [b]

-- | A dynamic box of <a>Auto</a>s, indexed by an <a>Int</a>. Takes an
--   <a>IntMap</a> of inputs to feed into their corresponding <a>Auto</a>s,
--   and collect all of the outputs into an output <a>IntMap</a>.
--   
--   Whenever any of the internal <a>Auto</a>s return <a>Nothing</a>, they
--   are removed from the collection.
--   
--   Toy examples here are of limited use, but let's try it out. Here we
--   will have a <a>dynMap_</a> that feeds each internal <a>Auto</a> back
--   to itself. The result of each is sent directly back to itself.
--   
--   <pre>
--   looper :: Auto' () (IntMap Int)
--   looper = proc _ -&gt; do
--       initAutos <a>immediately -&lt; sumFromD &lt;$</a> [1,-1,0]
--       rec
--           outs &lt;- dynMap_ 0 . delay mempty -&lt; (outs, initAutos)
--       id -&lt; outs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (res, _) = stepAutoN' 20 looper ()
--   
--   &gt;&gt;&gt; tail res
--   [ fromList []
--   , fromList [(0, 1 ), (1, -1 ), (2, 0 )]
--   , fromList [(0, 1 ), (1, -1 ), (2, 0 )]
--   , fromList [(0, 2 ), (1, -2 ), (2, 0 )]
--   , fromList [(0, 3 ), (1, -3 ), (2, 0 )]
--   , fromList [(0, 5 ), (1, -5 ), (2, 0 )]
--   , fromList [(0, 8 ), (1, -8 ), (2, 0 )]
--   , fromList [(0, 13), (1, -13), (2, 0 )]
--   , fromList [(0, 21), (1, -21), (2, 0 )]
--   , fromList [(0, 34), (1, -34), (2, 0 )]
--   ]
--   </pre>
--   
--   The first part of each tuple is the <a>Int</a> "key", and the second
--   part is the value.
--   
--   Basically, the twice-delayed results are fed into the each
--   corresponding <a>Auto</a> --- the results from the <a>Auto</a>
--   starting at positive 1 is fed back to the <a>Auto</a> with a positive
--   counter....results from the <a>Auto</a> starting at negative 1 are fed
--   back into the <a>Auto</a> with the negative counter...and results of
--   the <a>Auto</a> starting at 0 is fed back into the <a>Auto</a> that
--   stays at 0.
--   
--   TODO: put in pointers to real examples
dynMap_ :: Monad m => a -> Auto m (IntMap a, Blip [Auto m a (Maybe b)]) (IntMap b)

-- | <a>Auto</a> multiplexer. Takes a function mapping a key <tt>k</tt> to
--   an initial <a>Auto</a> to be stored at that key. Then, every turn,
--   takes a key-input pair <tt>(k, x) :: (k, a)</tt>, and "runs" the
--   <a>Auto</a> at that key <tt>k</tt> with that input value <tt>x</tt>,
--   and outputs the result.
--   
--   TODO: talk about how you can "restart" arrows using combinators from
--   switch and stuff.
--   
--   TODO: keys to use with adding things one after another, like in
--   dynMap.
--   
--   TODO: example
mux :: (Serialize k, Ord k, Monad m) => (k -> Auto m a b) -> Auto m (k, a) b

-- | The non-serializing/non-resuming version of <a>mux</a>.
mux_ :: (Ord k, Monad m) => (k -> Auto m a b) -> Auto m (k, a) b

-- | <a>Auto</a> multiplexer, like <a>mux</a>, but with multple inputs and
--   outputs at a time. Instead of giving in a single key-value pair of
--   type <tt>(k, a)</tt>, give an entire key-value collection, <tt>Map k
--   a</tt>. It runs all of the given <tt>a</tt> inputs with their
--   corresponding <a>Auto</a>s indexed by <tt>k</tt>, and outputs all of
--   the results in a <tt>Map k b</tt>.
--   
--   TODO: Example
muxMany :: (Serialize k, Ord k, Monad m) => (k -> Auto m a b) -> Auto m (Map k a) (Map k b)

-- | The non-serializing/non-resuming version of <a>muxMany</a>.
muxMany_ :: (Ord k, Monad m) => (k -> Auto m a b) -> Auto m (Map k a) (Map k b)

-- | Keeps a whole bunch of <a>Auto</a>s in a <a>Map</a>, and every step,
--   outputs a <a>Map</a> containing each key and the last (<a>Just</a>)
--   value outputted by the <a>Auto</a> stored at that key.
--   
--   Gets as input a key-value pair <tt>(k, x) :: (k, a)</tt>, and feeds
--   that input to the <a>Auto</a> stored at that key. If there is no
--   <a>Auto</a> yet stored, then generates a fresh one using the given
--   <a>Auto</a>-making function.
--   
--   As soon as a stored <a>Auto</a> outputs a <a>Nothing</a>, the
--   <a>Auto</a> (and its key) are removed from the <a>Map</a>, and never
--   outputted again in the total output, its most recent value lost
--   forever. However, you can still "recreate" it by passing in a
--   key-value pair with that key; life starts all over again.
--   
--   TODO: keys to use with adding things one after another, like in
--   dynMap.
--   
--   TODO: Example
gather :: (Ord k, Monad m, Serialize k, Serialize b) => (k -> Auto m a (Maybe b)) -> Auto m (k, a) (Map k b)

-- | The non-serializing/non-resuming version of <a>gather</a>:
--   
--   <b>Does</b> serialize the actual <b><a>Auto</a>s</b> themselves; the
--   <a>Auto</a>s are all serialized and re-loaded/resumed when 'gather_ f'
--   is resumed.
--   
--   Does <b>not</b> serialize the "last outputs", so resumed <a>Auto</a>s
--   that have not yet been re-run/accessed to get a fresh output are not
--   represented in the output map at first.
gather_ :: (Ord k, Monad m, Serialize k) => (k -> Auto m a (Maybe b)) -> Auto m (k, a) (Map k b)

-- | The non-serializing/non-resuming vervsion of <a>gather</a>:
--   
--   Serializes neither the <a>Auto</a>s themselves nor the "last outputs"
--   --- essentially, serializes/resumes nothing.
gather__ :: (Ord k, Monad m) => (k -> Auto m a (Maybe b)) -> Auto m (k, a) (Map k b)

-- | Like <a>gather</a>, but allows you to input multiple key-value pairs
--   every step, as a <a>Map</a>. Still outputs a <a>Map</a> with "the last
--   result of every stored <a>Auto</a>".
--   
--   TODO: Example
gatherMany :: (Ord k, Monad m, Serialize k, Serialize b) => (k -> Auto m a (Maybe b)) -> Auto m (Map k a) (Map k b)

-- | The non-serializing/non-resuming version of <a>gatherMany</a>:
--   
--   <b>Does</b> serialize the actual <b><a>Auto</a>s</b> themselves; the
--   <a>Auto</a>s are all serialized and re-loaded/resumed when
--   'gatherMany_ f' is resumed.
--   
--   Does <b>not</b> serialize the "last outputs", so resumed <a>Auto</a>s
--   that have not yet been re-run/accessed to get a fresh output are not
--   represented in the output map at first.
gatherMany_ :: (Ord k, Monad m, Serialize k) => (k -> Auto m a (Maybe b)) -> Auto m (Map k a) (Map k b)

-- | The non-serializing/non-resuming vervsion of <a>gatherMany</a>:
--   
--   Serializes neither the <a>Auto</a>s themselves nor the "last outputs"
--   --- essentially, serializes/resumes nothing.
gatherMany__ :: (Ord k, Monad m) => (k -> Auto m a (Maybe b)) -> Auto m (Map k a) (Map k b)


-- | This module provides combinators and utilities for working with the
--   semantic concept of "intervals": <a>Auto</a>s producing values that
--   can either be "on" or "off"...typically for contiguous chunks at a
--   time.
module Control.Auto.Interval

-- | An <a>Auto</a> that produces an interval that always "off"
--   (<a>Nothing</a>), never letting anything pass.
--   
--   Note that any monadic effects of the input <a>Auto</a> when composed
--   with <a>off</a> are still executed, even though their result value is
--   suppressed.
--   
--   <pre>
--   off == arr (const Nothing)
--   </pre>
off :: Auto m a (Maybe b)

-- | An <a>Auto</a> that takes a value stream and turns it into an
--   "always-on" interval, with that value. Lets every value pass through.
--   
--   <pre>
--   toOn == arr Just
--   </pre>
toOn :: Auto m a (Maybe a)

-- | An <a>Auto</a> taking in an interval stream and transforming it into a
--   normal value stream, using the given default value whenever the
--   interval is off/blocking.
--   
--   <pre>
--   fromInterval d = arr (fromMaybe d)
--   </pre>
fromInterval :: a -> Auto m (Maybe a) a

-- | An <a>Auto</a> taking in an interval stream and transforming it into a
--   normal value stream, using the given default value whenever the
--   interval is off/blocking, and applying the given function to the input
--   when the interval is on/passing. Analogous to <a>maybe</a> from
--   <a>Prelude</a> and <a>Data.Maybe</a>.
--   
--   <pre>
--   fromIntervalWith d f = arr (maybe d f)
--   </pre>
fromIntervalWith :: b -> (a -> b) -> Auto m (Maybe a) b

-- | An <a>Auto</a> that behaves like <a>toOn</a> (letting values pass,
--   "on") for the given number of steps, then otherwise is off
--   (suppressing all input values from passing) forevermore.
onFor :: Int -> Auto m a (Maybe a)

-- | An <a>Auto</a> that is off for the given number of steps, suppressing
--   all input values, then behaves like <a>toOn</a> forevermore, passing
--   through values as "on" values.
offFor :: Int -> Auto m a (Maybe a)

-- | An <a>Auto</a> that allows values to pass whenever the input satisfies
--   the predicate...and is off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; let a = when (\x -&gt; x &gt;= 2 &amp;&amp; x &lt;= 4) . count
--   
--   &gt;&gt;&gt; let Output res _ = stepAutoN' 6 a ()
--   
--   &gt;&gt;&gt; res
--   [Nothing, Just 2, Just 3, Just 4, Nothing, Nothing]
--   </pre>
--   
--   (<tt>count</tt> is the <a>Auto</a> that ignores its input and outputs
--   the current step count at every step)
when :: (a -> Bool) -> Auto m a (Maybe a)

-- | Like <a>when</a>, but only allows values to pass whenever the input
--   does not satisfy the predicate. Blocks whenever the predicate is true.
--   
--   <pre>
--   &gt;&gt;&gt; let a = unless (\x -&gt; x &lt; 2 &amp;&amp;&amp; x &gt; 4) . count
--   
--   &gt;&gt;&gt; let Output res _ = stepAutoN' 6 a ()
--   
--   &gt;&gt;&gt; res
--   [Nothing, Just 2, Just 3, Just 4, Nothing, Nothing]
--   </pre>
--   
--   (<tt>count</tt> is the <a>Auto</a> that ignores its input and outputs
--   the current step count at every step)
unless :: (a -> Bool) -> Auto m a (Maybe a)

-- | <a>Chooses</a> between an interval-producing <a>Auto</a> and an
--   "normal" value, "always on" <a>Auto</a>. Behaves like the "on" value
--   of the first <a>Auto</a> if it is on; otherwise, behaves like the
--   second.
--   
--   <pre>
--   &gt;&gt;&gt; let a1 = (onFor 2 . pure "hello") &lt;|!&gt; pure "world"
--   
--   &gt;&gt;&gt; let Output res1 _ = stepAutoN' 5 a1 ()
--   
--   &gt;&gt;&gt; res1
--   ["hello", "hello", "world", "world", "world"]
--   </pre>
--   
--   This one is neat because it associates from the right, so it can be
--   "chained":
--   
--   <pre>
--   &gt;&gt;&gt; let a2 = onFor 2 . pure "hello"
--           &lt;|!&gt; onFor 4 . pure "world"
--           &lt;|!&gt; pure "goodbye!"
--   
--   &gt;&gt;&gt; let Output res2 _ = stepAutoN' 6 a2 ()
--   
--   &gt;&gt;&gt; res2
--   ["hello", "hello", "world", "world", "goodbye!", "goodbye!"]
--   </pre>
--   
--   TODO: Formatting here
--   
--   <tt>a <a>|!</a> b <a>|!</a> c</tt> associates as <tt>a <a>|!</a> (b
--   <a>|!</a> c)</tt>
--   
--   So using this, you can "chain" a bunch of choices between intervals,
--   and then at the right-most, "final" one, provide the default behavior.
--   
--   Warning: If your underlying monad produces effects, remember that
--   <i>both</i> <a>Auto</a>s are run at every step, along with any monadic
--   effects, regardless of whether they are "on" or "off".
(<|!>) :: Monad m => Auto m a (Maybe b) -> Auto m a b -> Auto m a b

-- | This "chooses" between two interval-producing <a>Auto</a>s; behaves
--   like the first <a>Auto</a> if it is "on"; otherwise, behaves like the
--   second.
--   
--   <pre>
--   &gt;&gt;&gt; let a = (onFor 2 . pure "hello") &lt;|?&gt; (onFor 4 . pure "world")
--   
--   &gt;&gt;&gt; let Output res _ = stepAutoN' 5 a ()
--   
--   &gt;&gt;&gt; res
--   [Just "hello", Just "hello", Just "world", Just "world", Nothing]
--   </pre>
--   
--   You can drop the parentheses, because of precedence; the above could
--   have been written as:
--   
--   <pre>
--   &gt;&gt;&gt; let a' = onFor 2 . pure "hello" &lt;|?&gt; onFor 4 . pure "world"
--   </pre>
--   
--   Warning: If your underlying monad produces effects, remember that
--   <i>both</i> <a>Auto</a>s are run at every step, along with any monadic
--   effects, regardless of whether they are "on" or "off".
--   
--   Note that more often than not, <a>&lt;|!&gt;</a> is probably more
--   useful. This is useful only in the case that you really, really want
--   an interval at the end of it all.
(<|?>) :: Monad m => Auto m a (Maybe b) -> Auto m a (Maybe b) -> Auto m a (Maybe b)

-- | Run all <a>Auto</a>s from the same input, and return the behavior of
--   the first one that is not <a>Nothing</a>. If all are <a>Nothing</a>,
--   output <a>Nothing</a>.
--   
--   <pre>
--   chooseInterval == foldr (&lt;|?&gt;) off
--   </pre>
chooseInterval :: Monad m => [Auto m a (Maybe b)] -> Auto m a (Maybe b)

-- | Run all <a>Auto</a>s from the same input, and return the behavior of
--   the first one that is not <a>Nothing</a>; if all are <a>Nothing</a>,
--   return the behavior of the "default case".
--   
--   <pre>
--   choose == foldr (&lt;|!&gt;)
--   </pre>
choose :: Monad m => Auto m a b -> [Auto m a (Maybe b)] -> Auto m a b

-- | Takes in a value stream and a <a>Blip</a> stream. Doesn't allow any
--   values in at first, until the <a>Blip</a> stream emits. Then, allows
--   all values through as "on" forevermore.
--   
--   <pre>
--   &gt;&gt;&gt; let a = after . (count &amp;&amp;&amp; inB 3)
--   
--   &gt;&gt;&gt; let Output res _ = stepAutoN' 5 a ()
--   
--   &gt;&gt;&gt; res
--   [Nothing, Nothing, Just 3, Just 4, Just 4]
--   </pre>
--   
--   (<tt>count</tt> is the <a>Auto</a> that ignores its input and outputs
--   the current step count at every step, and <tt><tt>inB</tt> 3</tt> is
--   the <a>Auto</a> generating a <a>Blip</a> stream that emits at the
--   third step.)
--   
--   Be careful to remember that <a>after</a> does not actually "switch"
--   anything. In the above example, <tt>count</tt> is still "run" at every
--   step, and is progressed (and if it were an <a>Auto</a> with monadic
--   effects, they would still be executed). It just isn't allowed to pass
--   through <a>after</a> until the <a>Blip</a> stream emits.
after :: Auto m (a, Blip b) (Maybe a)

-- | Takes in a value stream and a <a>Blip</a> stream. Allows all values
--   through, as "on", until the <a>Blip</a> stream emits...then doesn't
--   let anything pass after that.
--   
--   <pre>
--   &gt;&gt;&gt; let a = before . (count &amp;&amp;&amp; inB 3)
--   
--   &gt;&gt;&gt; let Output res _ = stepAutoN' 5 a ()
--   
--   &gt;&gt;&gt; res
--   [Just 1, Just 2, Nothing, Nothing, Nothing]
--   </pre>
--   
--   (<tt>count</tt> is the <a>Auto</a> that ignores its input and outputs
--   the current step count at every step, and <tt><tt>inB</tt> 3</tt> is
--   the <a>Auto</a> generating a <a>Blip</a> stream that emits at the
--   third step.)
--   
--   Be careful to remember that <a>before</a> doesn't actually "switch"
--   anything. In the above example, <tt>count</tt> is <i>still</i> "run"
--   at every step (and if it were an <a>Auto</a> with monad effects, they
--   would still be executed). It's just that the values are suppressed.
before :: Auto m (a, Blip b) (Maybe a)

-- | Takes in a value stream and two <a>Blip</a> streams. Starts off as
--   "off", not letting anything pass. When the first <a>Blip</a> stream
--   emits, it toggles onto the "on" state and lets everything pass; when
--   the second <a>Blip</a> stream emits, it toggles back onto the "off"
--   state.
--   
--   <pre>
--   &gt;&gt;&gt; let a = before . (count &amp;&amp;&amp; (inB 3 &amp;&amp;&amp; inB 5))
--   
--   &gt;&gt;&gt; let Output res _ = stepAutoN' 7 a ()
--   
--   &gt;&gt;&gt; res
--   [Nothing, Nothing, Just 3, Just 4, Nothing, Nothing, Nothing]
--   </pre>
between :: Auto m (a, (Blip b, Blip c)) (Maybe a)

-- | Takes in a <a>Blip</a> stream and constantly outputs the last emitted
--   value. Starts off as <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let a1 = hold . inB 3 . count
--   
--   &gt;&gt;&gt; let Output res1 _ = stepAutoN' 5 a1 ()
--   
--   &gt;&gt;&gt; res1
--   [Nothing, Nothing, Just 3, Just 3, Just 3]
--   </pre>
--   
--   You can make this behave as an <tt><a>Auto</a> m (<a>Blip</a> a)
--   b</tt> (no possible <a>Nothing</a>s) by providing a "default" value,
--   to be used when the input stream has not yet emitted, in one of two
--   ways:
--   
--   The first, using <a>&lt;|!&gt;</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let a2 = (hold . inB 3 . count) &lt;|!&gt; pure 100
--   
--   &gt;&gt;&gt; let Output res2 _ = stepAutoN' 5 a2 ()
--   
--   &gt;&gt;&gt; res2
--   [100, 100, 3, 3, 3]
--   </pre>
--   
--   The second, using <a>fromInterval</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let a3 = fromInterval 100 . hold . inB 3 . count
--   
--   &gt;&gt;&gt; let Output res3 _ = stepAutoN' 5 a3 ()
--   
--   &gt;&gt;&gt; res3
--   [100, 100, 3, 3, 3]
--   </pre>
hold :: Serialize a => Auto m (Blip a) (Maybe a)

-- | The non-serializing/non-resuming version of <a>hold</a>.
hold_ :: Auto m (Blip a) (Maybe a)

-- | Like <a>hold</a>, but it only "holds" the last emitted value for the
--   given number of steps.
--   
--   <pre>
--   &gt;&gt;&gt; let a = holdFor 2 . inB 3 . count
--   
--   &gt;&gt;&gt; let Output res _ = stepAutoN' 7 a ()
--   
--   &gt;&gt;&gt; res
--   [Nothing, Nothing, Just 3, Just 4, Nothing, Nothing, Nothing]
--   </pre>
holdFor :: Serialize a => Int -> Auto m (Blip a) (Maybe a)

-- | The non-serializing/non-resuming version of <a>holdFor</a>.
holdFor_ :: Int -> Auto m (Blip a) (Maybe a)

-- | <a>Lifts</a> an <tt><a>Auto</a> m a b</tt> (transforming <tt>a</tt>s
--   into <tt>b</tt>s) into an <tt><a>Auto</a> m (<a>Maybe</a> a)
--   (<a>Maybe</a> b)</tt>, transforming <i>intervals</i> of <tt>a</tt>s
--   into <i>intervals</i> of <tt>b</tt>.
--   
--   It does this by "running" the given <a>Auto</a> whenever it receives a
--   <a>Just</a> value, and skipping/pausing it whenever it receives a
--   <a>Nothing</a> value.
--   
--   <pre>
--   &gt;&gt;&gt; let a1 = during (sumFrom 0) . onFor 2 . pure 1
--   
--   &gt;&gt;&gt; let Output res1 _ = stepAutoN' 5 a1 ()
--   
--   &gt;&gt;&gt; res1
--   [Just 1, Just 2, Nothing, Nothing, Nothing]
--   
--   &gt;&gt;&gt; let a2 = during (sumFrom 0) . offFor 2 . pure 1
--   
--   &gt;&gt;&gt; let Output res2 _ = stepAutoN' 5 a2 ()
--   
--   &gt;&gt;&gt; res2
--   [Nothing, Nothing, Just 1, Just 2, Just 3]
--   </pre>
--   
--   (Remember that <tt><a>pure</a> x</tt> is the <a>Auto</a> that ignores
--   its input and constantly just pumps out <tt>x</tt> at every step)
--   
--   Note the difference between putting the <tt>sumFrom</tt> "after" the
--   <a>offFor</a> in the chain with <a>during</a> (like the previous
--   example) and putting the <tt>sumFrom</tt> "before":
--   
--   <pre>
--   &gt;&gt;&gt; let a3 = offFor 2 . sumFrom 0 . pure 1
--   
--   &gt;&gt;&gt; let Output res3 _ = stepAutoN' 5 a3 ()
--   
--   &gt;&gt;&gt; res3
--   [Nothing, Nothing, Just 3, Just 4, Just 5]
--   </pre>
--   
--   In the first case (with <tt>a2</tt>), the output of <tt><a>pure</a>
--   1</tt> was suppressed by <a>offFor</a>, and <tt><a>during</a>
--   (<tt>sumFrom</tt> 0)</tt> was only summing on the times that the 1's
--   were "allowed through"...so it only "starts counting" on the third
--   step.
--   
--   In the second case (with <tt>a3</tt>), the output of the
--   <tt><a>pure</a> 1</tt> is never suppressed, and went straight into the
--   <tt><tt>sumFrom</tt> 0</tt>. <tt>sumFrom</tt> is always summing, the
--   entire time. The final output of that <tt><tt>sumFrom</tt> 0</tt> is
--   suppressed at the end with <tt><a>offFor</a> 2</tt>.
during :: Monad m => Auto m a b -> Auto m (Maybe a) (Maybe b)

-- | <a>Lifts</a> (more technically, "binds") an <tt><a>Auto</a> m a
--   (<a>Maybe</a> b)</tt> into an <tt><a>Auto</a> m (<a>Maybe</a> a)
--   (<a>Maybe</a> b)</tt>
--   
--   The given <a>Auto</a> is "run" only on the <a>Just</a> inputs, and
--   paused on <a>Nothing</a> inputs.
--   
--   It's kind of like <a>during</a>, but the resulting <tt><a>Maybe</a>
--   (<a>Maybe</a> b))</tt> is "joined" back into a <tt><a>Maybe</a>
--   b</tt>.
--   
--   <pre>
--   bindI a == fmap join (during a)
--   </pre>
--   
--   This very important combinator allows you to properly "chain" ("bind")
--   together series of inhibiting <a>Auto</a>s. If you have an
--   <tt><a>Auto</a> m a (<a>Maybe</a> b)</tt> and an <tt><a>Auto</a> m b
--   (<a>Maybe</a> c)</tt>, you can chain them into an <tt><a>Auto</a> m a
--   (<a>Maybe</a> c)</tt>.
--   
--   <pre>
--   f             :: <a>Auto</a> m a (<a>Maybe</a> b)
--   g             :: <a>Auto</a> m b (<a>Maybe</a> c)
--   <a>bindI</a> g . f :: <a>Auto</a> m a (<a>Maybe</a> c)
--   </pre>
--   
--   (Users of libraries with built-in inhibition semantics like Yampa and
--   netwire might recognize this as the "default" composition in those
--   other libraries)
--   
--   As a contrived example, how about an <a>Auto</a> that only allows
--   values through during a window...between, say, the second and fourth
--   steps:
--   
--   <pre>
--   &gt;&gt;&gt; let window start finish = bindI (onFor finish) . offFor start
--   
--   &gt;&gt;&gt; let a = window 1 4 . count
--   
--   &gt;&gt;&gt; let Output res _ = stepAutoN' 5 a ()
--   
--   &gt;&gt;&gt; res
--   [Nothing, Just 2, Just 3, Just 4, Nothing, Nothing]
--   </pre>
--   
--   (Remember that <tt>count</tt> is the <a>Auto</a> that ignores its
--   input and displays the current step count, starting with 1)
bindI :: Monad m => Auto m a (Maybe b) -> Auto m (Maybe a) (Maybe b)


-- | This module provides utilities for "running" and "unrolling"
--   <a>Auto</a>s. You'll find "enhanced" versions of <a>stepAuto</a>,
--   mechanisms for running <a>Auto</a>s "interactively" inside <a>IO</a>,
--   monadic and non-monadic "self-runners" (provide the handlers, and the
--   <a>Auto</a> just recursively runs intself), and finally, ways of
--   "unrolling" the underlying <a>Monad</a> of <a>Auto</a>s into more
--   manageable and composable and easy to work with forms.
module Control.Auto.Run

-- | Steps the <a>Auto</a> through every element of the given list as
--   input.
--   
--   <pre>
--   &gt;&gt;&gt; let a          = mkAccum (+) 0
--   
--   &gt;&gt;&gt; let (ys, a')   = runIdentity (overList a [4,8,-3,5])
--   
--   &gt;&gt;&gt; ys
--   [4, 12, 9, 14]
--   
--   &gt;&gt;&gt; let Output y _ = runIdentity (stepAuto a 7)
--   
--   &gt;&gt;&gt; y
--   21
--   </pre>
overList :: Monad m => Auto m a b -> [a] -> m ([b], Auto m a b)

-- | Like <a>overList</a>, but with an <a>Auto'</a> (the underlying
--   <a>Monad</a> is <a>Identity</a>)
--   
--   <pre>
--   &gt;&gt;&gt; let a          = mkAccum (+) 0
--   
--   &gt;&gt;&gt; let (ys, a')   = overList' a [4,8,-3,5]
--   
--   &gt;&gt;&gt; ys
--   [4, 12, 9, 14]
--   
--   &gt;&gt;&gt; let Output y _ = stepAuto' a 7
--   
--   &gt;&gt;&gt; y
--   21
--   </pre>
overList' :: Auto' a b -> [a] -> ([b], Auto' a b)

-- | Repeatedly steps an <a>Auto</a> with the same input a given number of
--   times.
--   
--   <pre>
--   stepAutoN n a0 x = overList a0 (replicate n x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a          = iterator (*2) 1
--   
--   &gt;&gt;&gt; let (ys, a')   = runIdentity (stepAutoN 8 a ())
--   
--   &gt;&gt;&gt; ys
--   [1, 2, 4, 8, 16, 32, 64, 128]
--   
--   &gt;&gt;&gt; let Output y _ = runIdentity (stepAuto a ())
--   
--   &gt;&gt;&gt; y
--   256
--   </pre>
stepAutoN :: Monad m => Int -> Auto m a b -> a -> m ([b], Auto m a b)

-- | Like <a>stepAutoN</a>, but with an <a>Auto'</a> (the underlying
--   <a>Monad</a> is <a>Identity</a>)
--   
--   <pre>
--   &gt;&gt;&gt; let a          = iterator (*2) 1
--   
--   &gt;&gt;&gt; let (ys, a')   = stepAutoN 8 a ()
--   
--   &gt;&gt;&gt; ys
--   [1, 2, 4, 8, 16, 32, 64, 128]
--   
--   &gt;&gt;&gt; let Output y _ = stepAuto a ()
--   
--   &gt;&gt;&gt; y
--   256
--   </pre>
stepAutoN' :: Int -> Auto' a b -> a -> ([b], Auto' a b)

-- | Run an <a>Auto'</a> "interactively". Every step grab a string from
--   stdin, and feed it to the <a>Auto</a>. If the <a>Auto</a> pops out
--   <a>Nothing</a>, end the session; if it outputs a <a>Just</a>, print it
--   out to stdout and repeat all over again.
--   
--   If your <a>Auto</a> outputs something other than a <a>String</a>, you
--   can use <a>fmap</a> to transform the output into a <a>String</a>
--   en-route (like <tt><a>fmap</a> <a>show</a></tt>).
--   
--   If your <a>Auto</a> takes in something other than a <a>String</a>, you
--   can <tt>lmap</tt> a function to convert the input <a>String</a> to
--   whatever intput your <a>Auto</a> expects.
--   
--   Useful helper functions <a>duringRead</a> and <a>bindRead</a> are
--   provided for this case. <a>duringRead</a> turns an <tt><a>Auto</a> m a
--   b</tt> (with <tt><a>Read</a> a</tt>) into an <tt><a>Auto</a> m
--   <a>String</a> (<a>Maybe</a> b)</tt>, where it "reads" the
--   <a>String</a> into the <tt>a</tt>...but if the <a>read</a> fails, the
--   whole <a>Auto</a> returns <a>Nothing</a>. When used with
--   <a>interact</a>, that means that a failed <a>read</a> terminates the
--   loop.
interact :: Auto' String (Maybe String) -> IO (Auto' String (Maybe String))

-- | Like <a>interact</a>, but much more general. You can run it with an
--   <a>Auto</a> of any underlying <a>Monad</a>, as long as you provide the
--   natural transformation from that <a>Monad</a> to <a>IO</a>.
--   
--   The <a>Auto</a> can also output any <tt><a>Maybe</a> b</tt>; you have
--   to provide a function to "handle" it yourself; a <tt>b -&gt; <a>IO</a>
--   '()'</tt> (if you don't want to print it and you wanted to, say, write
--   it to a file.)
interactM :: Monad m => (b -> IO ()) -> (forall c. m c -> IO c) -> Auto m String (Maybe b) -> IO (Auto m String (Maybe b))

-- | Turn an <a>Auto</a> that takes a "readable" <tt>a</tt> and outputs a
--   <tt>b</tt> into an <a>Auto</a> that takes a <a>String</a> and outputs
--   a <tt><a>Maybe</a> b</tt>. When the <a>String</a> is successfuly
--   readable as the <tt>a</tt>, it steps the <a>Auto</a> and outputs a
--   succesful <a>Just</a> result; when it isn't, it outputs a
--   <a>Nothing</a> on that step.
--   
--   <pre>
--   &gt;&gt;&gt; let a0 = duringRead (mkAccum (+) (0 :: Int))
--   
--   &gt;&gt;&gt; let Output y1 a1 = stepAuto' a0 "12"
--   
--   &gt;&gt;&gt; y1
--   Just 12
--   
--   &gt;&gt;&gt; let Output y2 a2 = stepAuto' a1 "orange"
--   
--   &gt;&gt;&gt; y2
--   Nothing
--   
--   &gt;&gt;&gt; let Output y3 _  = stepAuto' a2 "4"
--   
--   &gt;&gt;&gt; y3
--   Just 16
--   </pre>
--   
--   See <a>interact</a> for neat use cases.
duringRead :: (Monad m, Read a) => Auto m a b -> Auto m String (Maybe b)

-- | Like <a>duringRead</a>, but the original <a>Auto</a> would output a
--   <tt><a>Maybe</a> b</tt> instead of a <tt>b</tt>. Returns
--   <a>Nothing</a> if either the <a>String</a> fails to parse or if the
--   original <a>Auto</a> returned <a>Nothing</a>; returns <a>Just</a> if
--   the <a>String</a> parses and the original <a>Auto</a> returned
--   <a>Just</a>.
--   
--   See <a>interact</a> for neat use cases.
bindRead :: (Monad m, Read a) => Auto m a (Maybe b) -> Auto m String (Maybe b)

-- | Heavy duty abstraction for "self running" an <a>Auto</a>. Give a
--   starting input and a function from an output to the next input to feed
--   in, and the <a>Auto</a>, and you get a feedback loop that constantly
--   feeds back in the result of the function applied to the previous
--   output. <a>Stops</a> when said function returns <a>Nothing</a>.
--   
--   Note that the none of the results are returned from the loop. Instead,
--   if you want to process the results, they must be utilized in the
--   "side-effects' of the "next input" function. (ie, a write to a file,
--   or an accumulation to a state).
run :: Monad m => a -> (b -> m (Maybe a)) -> Auto m a (Maybe b) -> m (Auto m a (Maybe b))

-- | A generalized version of <a>run</a> where the <a>Monad</a> you are
--   "running" the <a>Auto</a> in is different than the <a>Monad</a>
--   underneath the <a>Auto</a>. You just need to provide the natural
--   transformation.
runM :: (Monad m, Monad m') => a -> (b -> m (Maybe a)) -> (forall c. m' c -> m c) -> Auto m' a (Maybe b) -> m (Auto m' a (Maybe b))

-- | <a>Unrolls</a> the underlying <a>StateT</a> of an <a>Auto</a> into an
--   <a>Auto</a> that takes in an input state every turn (in addition to
--   the normal input) and outputs, along with the original result, the
--   modified state.
--   
--   So now you can use any <tt><a>StateT</a> s m</tt> as if it were an
--   <tt>m</tt>. Useful if you want to compose and create some isolated
--   <a>Auto</a>s with access to an underlying state, but not your entire
--   program.
--   
--   Also just simply useful as a convenient way to use an <a>Auto</a> over
--   <a>State</a> with <a>stepAuto</a> and friends.
--   
--   When used with <tt><a>State</a> s</tt>, it turns an <tt><a>Auto</a>
--   (<a>State</a> s) a b</tt> into an <tt><a>Auto'</a> (a, s) (b, s)</tt>.
runStateA :: Monad m => Auto (StateT s m) a b -> Auto m (a, s) (b, s)

-- | <a>Unrolls</a> the underlying <a>ReaderT</a> of an <a>Auto</a> into an
--   <a>Auto</a> that takes in the input "environment" every turn in
--   addition to the normal input.
--   
--   So you can use any <tt><a>ReaderT</a> r m</tt> as if it were an
--   <tt>m</tt>. Useful if you want to compose and create some isolated
--   <a>Auto</a>s with access to an underlying environment, but not your
--   entire program.
--   
--   Also just simply useful as a convenient way to use an <a>Auto</a> over
--   <a>Reader</a> with <a>stepAuto</a> and friends.
--   
--   When used with <tt><a>Reader</a> r</tt>, it turns an <tt><a>Auto</a>
--   (<a>Reader</a> r) a b</tt> into an <tt><a>Auto'</a> (a, r) b</tt>.
runReaderA :: Monad m => Auto (ReaderT r m) a b -> Auto m (a, r) b

-- | <a>Unrolls</a> the underlying <a>Monad</a> of an <a>Auto</a> if it
--   happens to be <a>Traversable</a> ('[]', <a>Maybe</a>, etc.).
--   
--   It can turn, for example, an <tt><a>Auto</a> [] a b</tt> into an
--   <tt><a>Auto'</a> a [b]</tt>; it collects all of the results together.
--   Or an <tt><a>Auto</a> <a>Maybe</a> a b</tt> into an <tt><a>Auto'</a> a
--   (<a>Maybe</a> b)</tt>.
--   
--   If you find a good use for this, let me know :)
runTraversableA :: (Monad f, Traversable f) => Auto f a b -> Auto m a (f b)


-- | Various <a>Auto</a>s for miscellaneous common processes.
--   
--   Note that all of these can be turned into an equivalent version acting
--   on <tt>Blip</tt> streams, with <tt>perBlip</tt>:
--   
--   <pre>
--   <a>sumFrom</a>         :: (<a>Serialize</a> a, <a>Num</a> a) =&gt; a -&gt; <a>Auto</a> m a a
--   <tt>perBlip</tt> <a>sumFrom</a> :: (<a>Serialize</a> a, <a>Num</a> a) =&gt; a -&gt; <a>Auto</a> m (<tt>Blip</tt> a) (<tt>Blip</tt> a)
--   </pre>
module Control.Auto.Process

-- | Outputs the running sum of all items passed so far, starting with an
--   initial count.
--   
--   The first output is the sum of the first input with the initial count.
--   See the documentation for <a>sumFromD</a> for more information.
--   
--   <pre>
--   sumFrom x0 = mkAccum (+) x0
--   </pre>
sumFrom :: (Serialize a, Num a) => a -> Auto m a a

-- | The non-resuming/non-serializing version of <a>sumFrom</a>.
sumFrom_ :: Num a => a -> Auto m a a

-- | Like <a>sumFrom</a>, except the first output is the starting count.
--   
--   <pre>
--   &gt;&gt;&gt; let a = sumFromD 5
--   
--   &gt;&gt;&gt; let Output y1 a' = stepAuto' a 10
--   
--   &gt;&gt;&gt; y1
--   5
--   
--   &gt;&gt;&gt; let Output y2 _  = stepAuto' a' 3
--   
--   &gt;&gt;&gt; y2
--   10
--   </pre>
--   
--   It's <a>sumFrom</a>, but "delayed".
--   
--   Useful for recursive bindings, where you need at least one value to be
--   able to produce its "first output" without depending on anything else.
--   
--   <pre>
--   sumFromD x0 = delay x0 . sumFrom x0
--   </pre>
sumFromD :: (Serialize a, Num a) => a -> Auto m a a

-- | The non-resuming/non-serializing version of <a>sumFromD</a>.
sumFromD_ :: Num a => a -> Auto m a a

-- | Returns the difference between the received input and the previous
--   input. The first result is <a>Nothing</a>; if you have something you
--   want the first result to be, you can use <tt>&lt;|!&gt;</tt> from
--   <a>Control.Auto.Interval</a>, or just <tt>fromMaybe</tt> or
--   <a>maybe</a> from <a>Data.Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let a = deltas
--   
--   &gt;&gt;&gt; let Output y1 a'  = stepAuto' a 5
--   
--   &gt;&gt;&gt; y1
--   Nothing
--   
--   &gt;&gt;&gt; let Output y2 a'' = stepAuto' a' 7
--   
--   &gt;&gt;&gt; y2
--   Just 2
--   
--   &gt;&gt;&gt; let Output y3 _   = stepAuto' a'' 4
--   
--   &gt;&gt;&gt; y3
--   Just (-3)
--   </pre>
--   
--   Usage with <tt>&lt;|!&gt;</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let a = deltas &lt;|!&gt; pure 100
--   
--   &gt;&gt;&gt; let (ys, _) = overList' a [5,7,4]
--   
--   &gt;&gt;&gt; ys
--   [100, 2, -3]
--   </pre>
--   
--   Usage with <tt>fromMaybe</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let a = fromMaybe 100 &lt;$&gt; deltas
--   
--   &gt;&gt;&gt; let (ys, _) = overList' a [5,7,4]
--   
--   &gt;&gt;&gt; ys
--   [100, 2, -3]
--   </pre>
deltas :: (Serialize a, Num a) => Auto m a (Maybe a)

-- | The non-resuming/non-serializing version of <a>deltas</a>.
deltas_ :: Num a => Auto m a (Maybe a)

-- | Accumulates the monoid sum of all inputs, starting with <a>mempty</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let a = mappender
--   
--   &gt;&gt;&gt; let Output y1 a'  = stepAuto' a (Last (Just 4))
--   
--   &gt;&gt;&gt; y1
--   Last (Just 4)
--   
--   &gt;&gt;&gt; let Output y2 a'' = stepAuto' a' (Last Nothing)
--   
--   &gt;&gt;&gt; y2
--   Last (Just 4)
--   
--   &gt;&gt;&gt; let Output y3 _   = stepAuto' a'' (Last (Just 2))
--   
--   &gt;&gt;&gt; y3
--   Last (Just 2)
--   </pre>
--   
--   <pre>
--   mappender = mkAccum mappend mempty
--   </pre>
mappender :: (Serialize a, Monoid a) => Auto m a a

-- | The non-resuming/non-serializing version of <a>mappender</a>.
mappender_ :: Monoid a => Auto m a a

-- | Accumulates the semigroup sum of all of its inputs; the same as
--   <a>mappender</a>, but you have to provide a "starting" value.
--   
--   <pre>
--   &gt;&gt;&gt; let a = mappendFrom (Max 0)
--   
--   &gt;&gt;&gt; let Output y1 a' = stepAuto' a (Max 3)
--   
--   &gt;&gt;&gt; y1
--   Max 3
--   
--   &gt;&gt;&gt; let Output y2 _  = stepAuto' a' (Max (-2))
--   
--   &gt;&gt;&gt; y2
--   Max 3
--   </pre>
--   
--   <pre>
--   mappendFrom m0 = mkAccum (&lt;&gt;) m0
--   </pre>
mappendFrom :: (Serialize a, Semigroup a) => a -> Auto m a a

-- | The non-resuming/non-serializing version of <a>mappender</a>.
mappendFrom_ :: Semigroup a => a -> Auto m a a


-- | This module provides tools for working with the automatically derived
--   serializability and resumability of <a>Auto</a>s. The first half
--   contains boring wrappers around encoding and decoding to and from
--   binary, filepaths on disk, etc.
--   
--   The second half contains <a>Auto</a> transformers that "imbue" an
--   <a>Auto</a> with IO serialization abilities. Note that these all
--   require an underlying <a>Monad</a> that is an instance of
--   <a>MonadIO</a>.
--   
--   You have "identity-like" transformers that take an <a>Auto</a> and
--   spit it back out operationally unchanged...but every step, it might do
--   some behind-the-scenes saving or re-load itself from disk when it is
--   first stepped. Or you have some "trigger enhancers" that take normal
--   <a>Auto</a>s and give you the ability to "trigger" saving and loading
--   events on the <a>Auto</a> using the <a>Blip</a> mechanisms from
--   <a>Control.Auto.Blip</a>.
module Control.Auto.Serialize

-- | Returns a <a>Put</a> --- instructions (from <a>Data.Serialize</a>) on
--   how to "freeze" the <a>Auto</a>, with its internal state, and save it
--   to a binary encoding. It can later be reloaded and "resumed" by
--   'loadAuto'/'decodeAuto'.
saveAuto :: Auto m a b -> Put

-- | Returns a <a>Get</a> from an <a>Auto</a> --- instructions (from
--   <a>Data.Serialize</a>) on taking a ByteString and "restoring" the
--   originally saved <a>Auto</a>, in the originally saved state.
loadAuto :: Auto m a b -> Get (Auto m a b)

-- | Encode an <a>Auto</a> and its internal state into a <a>ByteString</a>.
encodeAuto :: Auto m a b -> ByteString

-- | <a>Resume</a> an <a>Auto</a> from its <a>ByteString</a> serialization,
--   giving a <a>Left</a> if the deserialization is not possible.
decodeAuto :: Auto m a b -> ByteString -> Either String (Auto m a b)

-- | Given a <a>FilePath</a> and an <a>Auto</a>, serialize and freeze the
--   state of the <a>Auto</a> as binary to that <a>FilePath</a>.
writeAuto :: FilePath -> Auto m a b -> IO ()

-- | Give a <a>FilePath</a> and an <a>Auto</a>, and <a>readAuto</a> will
--   attempt to resume the saved state of the <a>Auto</a> from disk,
--   reading from the given <a>FilePath</a>. Will return <a>Left</a> upon a
--   decoding error, with the error, and <a>Right</a> if the decoding is
--   succesful.
readAuto :: FilePath -> Auto m a b -> IO (Either String (Auto m a b))

-- | Like <a>readAuto</a>, but if any <a>IO</a> or decoding error pops up,
--   it is silently ignored; the <i>original</i> <a>Auto</a> (passed to
--   <a>readAuto'</a>) is returned unchanged.
--   
--   Useful if you want to "resume an <a>Auto</a> in case there is a save
--   state, and otherwise use it as-is if there isn't".
readAuto' :: FilePath -> Auto m a b -> IO (Auto m a b)

-- | <a>Transforms</a> the given <a>Auto</a> into an <a>Auto</a> that
--   constantly saves its state to the given <a>FilePath</a> at every
--   "step". Requires an underlying <a>MonadIO</a>.
--   
--   Note that (unless the <a>Auto</a> depends on IO), the resulting
--   <a>Auto</a> is meant to be operationally <i>identical</i> in its
--   inputs/outputs to the original one.
saving :: MonadIO m => FilePath -> Auto m a b -> Auto m a b

-- | Like <a>loading</a>, except suppresses all I/O and decoding errors; if
--   there are errors, it returns back the given <a>Auto</a> as-is.
--   
--   Useful for when you aren't sure the save state is on disk or not yet,
--   and want to resume it only in the case that it is.
loading' :: MonadIO m => FilePath -> Auto m a b -> Auto m a b

-- | <a>Transforms</a> the given <a>Auto</a> into an <a>Auto</a> that, when
--   you <i>first</i> try to run or step it, "loads" itself from disk at
--   the given <a>FilePath</a>.
--   
--   Will throw a runtime exception on either an I/O error or a decoding
--   error.
--   
--   Note that (unless the <a>Auto</a> depends on IO), the resulting
--   <a>Auto</a> is meant to be operationally <i>identical</i> in its
--   inputs/outputs to the <i>fast-forwarded</i> original <a>Auto</a>.
loading :: MonadIO m => FilePath -> Auto m a b -> Auto m a b

-- | Like <a>serializing</a>, except suppresses all I/O and decoding
--   errors.
--   
--   Useful in the case that when the <a>Auto</a> is first run and there is
--   no save state yet on disk (or the save state is corrupted), it'll
--   "start a new one"; if there is one, it'll load it automatically. Then,
--   on every further step in both cases, it'll update the save state.
serializing' :: MonadIO m => FilePath -> Auto m a b -> Auto m a b

-- | A combination of <a>saving</a> and <a>loading</a>. When the
--   <a>Auto</a> is first run, it loads the save state from the given
--   <a>FilePath</a> and fast forwards it. Then, subsequently, it updates
--   the save state on disk on every step.
serializing :: MonadIO m => FilePath -> Auto m a b -> Auto m a b

-- | Takes an <a>Auto</a> and basically "wraps" it so that you can trigger
--   saves with a <a>Blip</a> stream.
--   
--   For example, we can take <tt><tt>sumFrom</tt> 0</tt>:
--   
--   <pre>
--   <a>saveOnB</a> (<tt>sumFrom</tt> 0) :: <a>Auto</a> <a>IO</a> (<a>Int</a>, <a>Blip</a> <a>FilePath</a>) <a>Int</a>
--   </pre>
--   
--   It'll behave just like <tt><tt>sumFrom</tt> 0</tt> (with the input you
--   pass in the first field of the tuple)...and whenever the <a>Blip</a>
--   stream (the second field of the input tuple) emits, it'll save the
--   state of <tt><tt>sumFrom</tt> 0</tt> to disk at the given
--   <a>FilePath</a>.
--   
--   Contrast to <a>saveFromB</a>, where the <a>Auto</a> itself can trigger
--   saves; in this one, saves are triggered "externally".
--   
--   Might be useful in similar situations as <a>saveFromB</a>, except if
--   you want to trigger the save externally.
saveOnB :: MonadIO m => Auto m a b -> Auto m (a, Blip FilePath) b

-- | Like <a>loadOnB</a>, except silently ignores errors. When a load is
--   requested, but there is an IO or parse error, the loading is skipped.
loadOnB' :: MonadIO m => Auto m a b -> Auto m (a, Blip FilePath) b

-- | Takes an <a>Auto</a> and basically "wraps" it so that you can trigger
--   loads/resumes from a file with a <a>Blip</a> stream.
--   
--   For example, we can take <tt><tt>sumFrom</tt> 0</tt>:
--   
--   <pre>
--   <a>loadOnB</a> (<tt>sumFrom</tt> 0) :: <a>Auto</a> <a>IO</a> (<a>Int</a>, <a>Blip</a> <a>FilePath</a>) <a>Int</a>
--   </pre>
--   
--   It'll behave just like <tt><tt>sumFrom</tt> 0</tt> (with the input you
--   pass in the first field of the tiple)...and whenever the <a>Blip</a>
--   stream (the second field of the input tuple) emits, it'll "reset" and
--   "reload" the <tt><tt>sumFrom</tt> 0</tt> from the <a>FilePath</a> on
--   disk.
--   
--   Will throw a runtime exception if there is an IO error or a parse
--   error.
--   
--   Contrast to <a>loadFromB</a>, where the <a>Auto</a> itself can trigger
--   reloads/resets; in this one, the loads are triggered "externally".
--   
--   Might be useful in similar situations as <a>loadFromB</a>, except if
--   you want to trigger the loading externally.
loadOnB :: MonadIO m => Auto m a b -> Auto m (a, Blip FilePath) b

-- | Takes an <a>Auto</a> that produces a <a>Blip</a> stream with a
--   <a>FilePath</a> and a value, and turns it into an <a>Auto</a> that,
--   outwardly, produces just the value.
--   
--   Whenever the output <a>Blip</a> stream emits, it automatically
--   serializes and saves the state of the <a>Auto</a> to the emitted
--   <a>FilePath</a>.
--   
--   In practice, this allows any <a>Auto</a> to basically control when it
--   wants to "save", by providing a <a>Blip</a> stream.
--   
--   The following is an alternative implementation of <a>saving</a>,
--   except saving every two steps instead of every step:
--   
--   <pre>
--   saving2 fp a = <a>saveFromB</a> (a <tt>&amp;&amp;&amp;</tt> (<tt>every</tt> 2 . <a>pure</a> fp))
--   </pre>
--   
--   Or, in proc notation:
--   
--   <pre>
--   saving2 fp a = saveFromB $ proc x -&gt; do
--       y &lt;- a       -&lt; x
--       b &lt;- every 2 -&lt; fp
--       id -&lt; (y, b)
--   </pre>
--   
--   (Recall that <tt><tt>every</tt> n</tt> is the <a>Auto</a> that emits
--   the received value every <tt>n</tt> steps)
--   
--   In useful real-world cases, you can have the <a>Auto</a> decide
--   whether or not to save itself based on its input. Like, for example,
--   when it detects a certain user command, or when the user has reached a
--   given location.
--   
--   The following takes a <a>FilePath</a> and an <a>Auto</a> (<tt>a</tt>),
--   and turns it into an <a>Auto</a> that "saves" whenever <tt>a</tt>
--   crosses over from positive to negative.
--   
--   <pre>
--   saveOnNegative fp a = saveFromB $ proc x -&gt; do
--       y       &lt;- a            -&lt; x
--       saveNow &lt;- <tt>became</tt> (&lt; 0) -&lt; y
--       id       -&lt; (y, fp <a>&lt;$</a> saveNow)
--   </pre>
--   
--   Contrast to <a>saveOnB</a>, where the saves are triggered by outside
--   input. In this case, the saves are triggered by the <a>Auto</a> to be
--   saved itself.
saveFromB :: MonadIO m => Auto m a (b, Blip FilePath) -> Auto m a b

-- | Like <a>loadFromB</a>, except silently ignores errors. When a load is
--   requested, but there is an IO or parse error, the loading is skipped.
loadFromB' :: MonadIO m => Auto m a (b, Blip FilePath) -> Auto m a b

-- | Takes an <a>Auto</a> that outputs a <tt>b</tt> and a <a>Blip</a>
--   stream of <a>FilePath</a>s and returns an <a>Auto</a> that ouputs only
--   that <tt>b</tt> stream...but every time the <a>Blip</a> stream emits,
--   it "resets/loads" itself from that <a>FilePath</a>.
--   
--   The following is a re-implementation of <a>loading</a>...except
--   delayed by one (the second step that is run is the first "resumed"
--   step).
--   
--   <pre>
--   loading2 fp a = <a>loadFromB</a> $ proc x -&gt; do
--       y       &lt;- a           -&lt; x
--       loadNow &lt;- <tt>immediately</tt> -&lt; fp
--       <a>id</a>       -&lt; (y, loadNow)
--   </pre>
--   
--   (the <a>Blip</a> stream emits only once, immediately, to re-load).
--   
--   In the real world, you could have the <a>Auto</a> decide to reset or
--   resume itself based on a user command:
--   
--   <pre>
--   loadFrom = loadFromB $ proc x -&gt; do
--       steps  &lt;- count -&lt; ()
--       toLoad &lt;- case words x of
--                     ("load":fp:_) -&gt; do
--                         immediately -&lt; fp
--                     _             -&gt; do
--                         never       -&lt; ()
--       id      -&lt; (steps, toLoad)
--   </pre>
--   
--   This will throw a runtime error on an IO exception or parsing error.
loadFromB :: MonadIO m => Auto m a (b, Blip FilePath) -> Auto m a b


-- | This module provides tools for generating and manipulating <a>Blip</a>
--   streams. The <a>Blip</a> abstraction is not fundamental to
--   <a>Auto</a>, but rather, like <i>interval</i>, is a very useful
--   semantic tool for the denotation of many programs, games, simulations,
--   and computations in general that you are likely to write with this
--   library.
module Control.Auto.Blip

-- | A type representing a "discrete" sort of event-like thing. It's
--   supposed to represent something that happens alone, and one at a time,
--   as opposed to things that are "on" or "off" for large intervals at a
--   time.
--   
--   It's here mainly because it's a pretty useful abstraction in the
--   context of the many combinators found in various modules of this
--   library. If you think of an <tt><tt>Auto</tt> m a (<a>Blip</a> b)</tt>
--   as a "<a>Blip</a> stream", then there are various combinators and
--   functions that are specifically designed to manipulate "<a>Blip</a>
--   streams".
--   
--   For the purposes of the semantics of what <a>Blip</a> is supposed to
--   represent, its constructors are hidden. (Almost) all of the various
--   <a>Blip</a> combinators (and its very useful <a>Functor</a> instance)
--   "preserve <a>Blip</a>ness" --- one-at-a-time occurrences remain
--   one-at-a-time under all of these combinators, and you should have
--   enough so that direct access to the constructor is not needed.
--   
--   If you are creating a framework, library, or backend, you might want
--   to manually create <a>Blip</a> stream-producing <tt>Auto</tt>s for
--   your users to access. In this case, you can import the constructors
--   and useful internal (and, of course, semantically unsafe) functions
--   from <a>Control.Auto.Blip.Internal</a>.
data Blip a

-- | Destruct a <a>Blip</a> by giving a default result if the <a>Blip</a>
--   is non-occuring and a function to apply on the contents, if the
--   <a>Blip</a> is occuring.
--   
--   Try not to use if possible, unless you are a framework developer. If
--   you're just making an application, try to use the other various
--   combinators in this library. It'll help you preserve the semantics of
--   what it means to be <a>Blip</a>py.
--   
--   Analogous to <a>maybe</a> from <a>Prelude</a>.
blip :: b -> (a -> b) -> Blip a -> b

-- | Merge two <a>Blip</a>s with a merging function. Is only a occuring
--   <a>Blip</a> if *both* <a>Blip</a>s are simultaneously occuring.
merge :: (a -> a -> a) -> Blip a -> Blip a -> Blip a

-- | Merges two <a>Blip</a> streams together into one, which emits
--   <i>either</i> of the original <a>Blip</a> streams emit. If both emit
--   at the same time, the left (first) one is favored.
mergeL :: Blip a -> Blip a -> Blip a

-- | Merges two <a>Blip</a> streams together into one, which emits
--   <i>either</i> of the original <a>Blip</a> streams emit. If both emit
--   at the same time, the right (second) one is favored.
mergeR :: Blip a -> Blip a -> Blip a

-- | An <a>Auto</a> producing a <a>Blip</a> stream that emits the input
--   whenever the input satisfies a given predicate.
--   
--   Warning! This <a>Auto</a> has the capability of "breaking" <a>Blip</a>
--   semantics. Be sure you know what you are doing when using this.
--   <a>Blip</a> streams are semantically supposed to only emit at
--   discrete, separate occurrences. Do not use this for interval-like (on
--   and off for chunks at a time) things; each input should be dealt with
--   as a separate thing.
--   
--   For interval semantics, we have <a>Control.Auto.Interval</a>.
--   
--   Good example:
--   
--   <pre>
--   -- is only emitting at discrete blips
--   emitOn even . iterator (+ 1) 0
--   </pre>
--   
--   Bad examples:
--   
--   <pre>
--   -- is emitting for "durations" or "intervals" of time.
--   emitOn (&lt; 10) . iterator (+ 1) 0
--   
--   emitOn (const True) . foo
--   </pre>
emitOn :: (a -> Bool) -> Auto m a (Blip a)

-- | An <a>Auto</a> that runs every input through a <tt>a -&gt;
--   <a>Maybe</a> b</tt> test and produces a blip stream that emits the
--   value inside every <a>Just</a> result.
--   
--   A less "boolean-blind" version of <a>emitOn</a>.
--   
--   Warning! Carries all of the same dangers of <a>emitOn</a>. You can
--   easily break <a>Blip</a> semantics with this if you aren't sure what
--   you are doing. Remember to only emit at discrete, separate occurences,
--   and not for interval-like (on and off for chunks at a time) things.
--   For interval semantics, we have <a>Control.Auto.Interval</a>.
--   
--   See the examples of <a>emitOn</a> for more concrete good/bad use
--   cases.
emitJusts :: (a -> Maybe b) -> Auto m a (Blip b)

-- | An <a>Auto</a> that emits whenever it receives a <a>Just</a> input,
--   with the value inside the <a>Just</a>.
--   
--   Warning! Carries all of the same dangers of <a>emitOn</a>. You can
--   easily break <a>Blip</a> semantics with this if you aren't sure what
--   you are doing. Remember to only emit at discrete, separate occurences,
--   and not for interval-like (on and off for chunks at a time) things.
--   For interval semantics, we have <a>Control.Auto.Interval</a>.
--   
--   See the examples of <a>emitOn</a> for more concrete good/bad use
--   cases.
onJusts :: Auto m (Maybe a) (Blip a)

-- | <tt><a>fromBlips</a> d</tt> is an <a>Auto</a> that decomposes the
--   incoming <a>Blip</a> stream by constantly outputting <tt>d</tt> except
--   when the stream emits, and outputs the emitted value when it does.
fromBlips :: a -> Auto m (Blip a) a

-- | Takes an <tt><a>Auto</a> m a b</tt> (an <a>Auto</a> that turns
--   incoming <tt>a</tt>s into outputting <tt>b</tt>s) into an
--   <tt><a>Auto</a> m (<a>Blip</a> a) (<a>Blip</a> b)</tt>; the original
--   <a>Auto</a> is lifted to only be applied to emitted contents of a
--   <a>Blip</a> stream.
--   
--   When the stream emits, the original <a>Auto</a> is "stepped" with the
--   emitted value; when it does not, it is paused and frozen until the
--   next emission.
--   
--   <pre>
--   &gt;&gt;&gt; let a    = perBlip (sumFrom 0)
--   
--   &gt;&gt;&gt; let blps = eachAt 2 [1,5,2]
--   
--   &gt;&gt;&gt; let Output bres _ = stepAutoN' 8 blps ()
--   
--   &gt;&gt;&gt; bres
--   [NoBlip, Blip 1, NoBlip, Blip 5, NoBlip, Blip 2, NoBlip, NoBlip]
--   
--   &gt;&gt;&gt; let Output ares _ = stepAutoN' 8 a ()
--   
--   &gt;&gt;&gt; ares
--   [NoBlip, Blip 1, NoBlip, Blip 6, NoBlip, Blip 8, NoBlip, NoBlip]
--   </pre>
perBlip :: Monad m => Auto m a b -> Auto m (Blip a) (Blip b)

-- | Takes an <tt><a>Auto</a> m a (<a>Blip</a> b)</tt> (an <a>Auto</a> that
--   turns incoming <tt>a</tt>s into a <a>Blip</a> stream of <tt>b</tt>s)
--   into an <tt><a>Auto</a> m (<a>Blip</a> a) (<a>Blip</a> b)</tt>. The
--   original <a>Auto</a> is applied only to emitted contents of a
--   <a>Blip</a> stream.
--   
--   It is like <a>perBlip</a>, but the resulting <tt><a>Blip</a>
--   (<a>Blip</a> b)</tt> is "joined" back into a <tt><a>Blip</a> b</tt>.
--   
--   <pre>
--   bindB a == fmap (blip NoBlip id) (perBlip a)
--   </pre>
bindB :: Monad m => Auto m a (Blip b) -> Auto m (Blip a) (Blip b)

-- | An <a>Auto</a> that ignores its input and produces a <a>Blip</a>
--   stream that never emits.
never :: Auto m a (Blip b)

-- | An <a>Auto</a> that produces a <a>Blip</a> stream that emits on the
--   first ever "tick", with the input at that step. It never emits again
--   after that.
--   
--   Often used with <a>pure</a>:
--   
--   <pre>
--   &gt;&gt;&gt; immediately . pure "Emit me!"
--   </pre>
--   
--   Or, in proc notation:
--   
--   <pre>
--   &gt;&gt;&gt; blp &lt;- immediately -&lt; "Emit me!"
--   </pre>
--   
--   To get a <a>Blip</a> stream that emits a given value (eg., "Emit me!")
--   once and stops emitting ever again.
immediately :: Auto m a (Blip a)

-- | An <a>Auto</a> that produces a <a>Blip</a> stream that only emits
--   once, after waiting the given number of ticks. It emits the input
--   after <i>waiting</i> that many steps.
--   
--   <pre>
--   immediately == inB 0
--   </pre>
inB :: Int -> Auto m a (Blip a)

-- | <tt><a>every</a> n</tt> is an <a>Auto</a> that takes in a stream of
--   <tt>a</tt>s and produces a blip stream that emits the input <tt>a</tt>
--   every <tt>n</tt> steps. First emission is on the <tt>n</tt>th step.
--   
--   Will usually break <a>Blip</a> semantics when you pass in 1.
every :: Int -> Auto m a (Blip a)

-- | <tt><a>eachAt</a> n xs</tt> is an <a>Auto</a> that ignores its input
--   and emits each element of <tt>xs</tt> one at a time, evey <tt>n</tt>
--   steps. First emitted value is at step <tt>n</tt>.
--   
--   Once the list is exhausted, never emits again.
--   
--   Obviously breaks <a>Blip</a> semantics when you pass in 1.
--   
--   The process of serializing and resuming this <a>Auto</a> is O(n) space
--   and time with the length of <tt>xs</tt>. So don't serialize this if
--   you plan on passing an infinite list :)
eachAt :: Serialize b => Int -> [b] -> Auto m a (Blip b)

-- | The non-serializing/non-resumable version of <a>eachAt</a>.
eachAt_ :: Int -> [b] -> Auto m a (Blip b)

-- | Re-emits every emission from the input <a>Blip</a> stream, but
--   replaces its value with the given value.
--   
--   <pre>
--   tagBlips x == modifyBlips (const x)
--   </pre>
tagBlips :: b -> Auto m (Blip a) (Blip b)

-- | Re-emits every emission from the input <a>Blip</a> stream, but applies
--   the given function to the emitted value.
modifyBlips :: (a -> b) -> Auto m (Blip a) (Blip b)

-- | Takes two <a>Auto</a>s generating <a>Blip</a> streams and returns a
--   "merged" <a>Auto</a> that emits when either of the original
--   <a>Auto</a>s emit. When both emit at the same time, the left (first)
--   one is favored.
--   
--   <pre>
--   a1 &lt;&amp; a2 == mergeL &lt;$&gt; a1 &lt;*&gt; a2
--   </pre>
(<&) :: Monad m => Auto m a (Blip b) -> Auto m a (Blip b) -> Auto m a (Blip b)

-- | Takes two <a>Auto</a>s generating <a>Blip</a> streams and returns a
--   "merged" <a>Auto</a> that emits when either of the original
--   <a>Auto</a>s emit. When both emit at the same time, the right (second)
--   one is favored.
--   
--   <pre>
--   a1 &amp;&gt; a2 == mergeR &lt;$&gt; a1 &lt;*&gt; a2
--   </pre>
(&>) :: Monad m => Auto m a (Blip b) -> Auto m a (Blip b) -> Auto m a (Blip b)

-- | Supress all emissions except for the very first.
once :: Auto m (Blip a) (Blip a)

-- | Suppress only the first emission, and ignore the rest.
notYet :: Auto m (Blip a) (Blip a)

-- | Suppress all emissions when the predicate is false.
filterB :: (a -> Bool) -> Auto m (Blip a) (Blip a)

-- | <tt><a>takeB</a> n</tt> allows only the first <tt>n</tt> emissions to
--   pass.
takeB :: Int -> Auto m (Blip a) (Blip a)

-- | Allow emissions to pass until the first that fails the predicate.
takeWhileB :: (a -> Bool) -> Auto m (Blip a) (Blip a)

-- | <tt><a>dropB</a> n</tt> suppresses the first <tt>n</tt> emissions and
--   passes through the rest.
dropB :: Int -> Auto m (Blip a) (Blip a)

-- | Suppress all emissions until the first one satisfying the predicate,
--   then allow the rest through.
dropWhileB :: (a -> Bool) -> Auto m (Blip a) (Blip a)

-- | Accumulates all emissions in the incoming <a>Blip</a> stream with a
--   "folding function", with a given starting value. <tt>b -&gt; a -&gt;
--   b</tt>, with a starting <tt>b</tt>, gives <tt><a>Auto</a> m
--   (<a>Blip</a> a) (<a>Blip</a> b)</tt>.
--   
--   The resulting <a>Blip</a> stream will emit every time the input stream
--   emits, but with the "accumulated value".
--   
--   Basically <a>mkAccum</a>, but on blip stream emissions.
--   
--   <pre>
--   accumB f x0 == perBlip (mkAccum f x0)
--   </pre>
accumB :: Serialize b => (b -> a -> b) -> b -> Auto m (Blip a) (Blip b)

-- | The non-serializing/non-resuming version of <a>accumB</a>.
accumB_ :: (b -> a -> b) -> b -> Auto m (Blip a) (Blip b)

-- | At every step, outputs the result of applying the "folding function"
--   with against the contents of every emitted value so far.
--   
--   <pre>
--   scanB f x0 == (hold . accumB f x0) &lt;|!&gt; pure x0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a = scanB (+) 0 . eachAt 2 [1,2,3]
--   
--   &gt;&gt;&gt; let Output res _ = stepAutoN' 8 ()
--   
--   &gt;&gt;&gt; res
--   [0, 1, 1, 3, 3, 6, 6, 6, 6]
--   </pre>
scanB :: Serialize b => (b -> a -> b) -> b -> Auto m (Blip a) b

-- | The non-serializing/non-resuming version of <a>scanB</a>.
scanB_ :: (b -> a -> b) -> b -> Auto m (Blip a) b

-- | At every step, outputs the monoid sum of all emitted values received
--   so far.
mscanB :: (Monoid a, Serialize a) => Auto m (Blip a) a

-- | The non-serializing/non-resuming version of <a>mscanB</a>.
mscanB_ :: Monoid a => Auto m (Blip a) a

-- | Outputs the number of emitted values of the input <a>Blip</a> stream
--   so far.
countB :: Auto m (Blip a) Int

-- | Produces a blip stream that emits whenever the input value changes.
--   Emits with the new value.
--   
--   Warning: Note that, when composed on a value that is never expected to
--   keep the same value twice, this technically breaks <a>Blip</a>
--   semantics.
onChange :: (Serialize a, Eq a) => Auto m a (Blip a)

-- | The non-serializing/non-resumable version of <a>onChange</a>.
onChange_ :: Eq a => Auto m a (Blip a)

-- | Produces a blip stream that emits whenever the predicate applied to
--   the input switches from false to true. Emits with the triggering input
--   value.
became :: Serialize a => (a -> Bool) -> Auto m a (Blip a)

-- | The non-serializing/non-resumable version of <a>became</a>.
became_ :: Monad m => (a -> Bool) -> Auto m a (Blip a)

-- | Like <a>became</a>, but emits a '()' instead of the triggering input
--   value.
became' :: Monad m => (a -> Bool) -> Auto m a (Blip ())

-- | Produces a blip stream that emits whenever the predicate applied to
--   the input switches from true to false. Emits with the triggering input
--   value.
noLonger :: Serialize a => (a -> Bool) -> Auto m a (Blip a)

-- | The non-serializing/non-resumable version of <a>noLonger</a>.
noLonger_ :: Monad m => (a -> Bool) -> Auto m a (Blip a)

-- | Like <a>noLonger</a>, but emits a '()' instead of the triggering input
--   value.
noLonger' :: Monad m => (a -> Bool) -> Auto m a (Blip ())

-- | Produces a blip stream that emits whenever the predicate applied to
--   the input switches from true to false or false to true. Emits with the
--   triggering input value.
onFlip :: (Serialize a, Monad m) => (a -> Bool) -> Auto m a (Blip a)

-- | The non-serializing/non-resumable version of <a>onFlip</a>.
onFlip_ :: Monad m => (a -> Bool) -> Auto m a (Blip a)

-- | Like <a>onFlip</a>, but emits a '()' instead of the triggering input
--   value.
onFlip' :: Monad m => (a -> Bool) -> Auto m a (Blip Bool)


-- | This module exports the preferred ways of interacting with the
--   underlying <a>Monad</a> of the <a>Auto</a> type, including accessing,
--   executing, and manipulating such effects.
module Control.Auto.Effects

-- | Lifts a "monadic function" (Kleisli arrow) into an <a>Auto</a>. Like
--   <tt>arr</tt>, but with monadic functions. Composition works just like
--   the composition of Kleisli arrows, with '(&lt;=&lt;)'.
arrM :: (a -> m b) -> Auto m a b

-- | <a>Executes</a> the given monadic action at every tick/step of the
--   <a>Auto</a>, outputting the result. Particularly useful with the
--   <tt>Reader</tt> <a>Monad</a>.
effect :: m b -> Auto m a b

-- | <a>Executes</a> the given monadic action at every tick/step of the
--   <a>Auto</a>, but ignores the result. Basically acts like <a>id</a>.
exec :: Monad m => m b -> Auto m a a

-- | Applies the "monadic function" to the contents of every incoming
--   <a>Blip</a>, and replaces the contents of the <a>Blip</a> with the
--   result of the function.
arrMB :: Monad m => (a -> m b) -> Auto m (Blip a) (Blip b)

-- | Executes a monadic action with every incoming <a>Blip</a>, and
--   replaces the contents of the <a>Blip</a> with the result of the
--   action.
effectB :: Monad m => m b -> Auto m (Blip a) (Blip b)

-- | Executes a monadic action with every incoming <a>Blip</a>, and passes
--   back that same <a>Blip</a> unchanged.
execB :: Monad m => m b -> Auto m (Blip a) (Blip a)

-- | <a>Executes</a> a monadic action once (and only once), and continues
--   to echo the result forevermore.
cache :: (Serialize b, Monad m) => m b -> Auto m a b

-- | <a>Executes</a> the monadic action once, and outputs '()' forevermore.
--   
--   TODO: literally fix
execOnce :: Monad m => m b -> Auto m a ()

-- | The non-resumable/non-serializable version of <a>cache</a>. Every time
--   the <a>Auto</a> is deserialized/reloaded, it re-executes the action to
--   retrieve the result again.
cache_ :: Monad m => m b -> Auto m a b

-- | The non-resumable/non-serializable version of <a>execOnce</a>. Every
--   time the <a>Auto</a> is deserialized/reloaded, the action is
--   re-executed again.
execOnce_ :: Monad m => m b -> Auto m a ()


-- | This module provides <a>Auto</a>s (purely) generating entropy in the
--   form of random or noisy processes. Note that every <a>Auto</a> here is
--   completely deterministic --- given the same initial seed, one would
--   expect the same stream of outputs on every run. Furthermore, if a
--   serializable <a>Auto</a> is serialized and resumed, it will continue
--   along the deterministic path dictated by the <i>original</i> seed
--   given.
--   
--   All of the <a>Auto</a>s in this module are generators: they ignore
--   their inputs and just provide random outputs. As such, you are likely
--   to be running them with inputs of type '()', and combining them with
--   your other processes using <tt>proc</tt> notation or the various
--   <tt>Arrow</tt> combinators.
--   
--   All of these <a>Auto</a>s come in three flavors: one serializing one
--   that works with any serializable <a>RandomGen</a> instance, one
--   serializing one that works specifically with <a>StdGen</a> from
--   <a>System.Random</a>, and one that takes any <a>RandomGen</a>
--   (including <a>StdGen</a>) and runs it without the ability to serialize
--   and resume deterministically.
--   
--   The reason why there's a specialized <a>StdGen</a> version for all of
--   these is that <a>StdGen</a> actually doesn't have a <a>Serialize</a>
--   instance, so a rudimentary serialization process is provded with the
--   <a>StdGen</a> versions.
--   
--   The first class of generators take arbitrary <tt>g -&gt; (b, g)</tt>
--   functions: "Generate a random <tt>b</tt>, using the given function,
--   and replace the seed with the resulting seed". Most "random" functions
--   follow this pattern, including <a>random</a> and <a>randomR</a>, and
--   if you are using something from <a>MonadRandom</a>, then you can use
--   the <tt>runRand</tt> function to turn a <tt><tt>Rand</tt> g b</tt>
--   into a <tt>g -&gt; (b, g)</tt>, as well:
--   
--   <pre>
--   <tt>runRand</tt> :: <a>RandomGen</a> g =&gt; <tt>Rand</tt> g b -&gt; (g -&gt; (b, g))
--   </pre>
--   
--   These are useful for generating noise...a new random value at every
--   stoep. They are entropy sources.
--   
--   The other two generators given are for useful random processes you
--   might run into. The first is a <a>Blip</a> stream that emits at random
--   times with the given frequency<i>probability. The second works
--   </i>Interval/ semantics from <a>Control.Auto.Interval</a>, and is a
--   stream that is "on" or "off", chunks at a time, for random lengths.
--   The average length of each on or off period is controlled by the
--   parameter you pass in.
module Control.Auto.Process.Random

-- | Given a seed-consuming generating function of form <tt>g -&gt; (b,
--   g)</tt> (where <tt>g</tt> is the seed, and <tt>b</tt> is the result)
--   and an initial seed, return an <a>Auto</a> that continually generates
--   random values using the given generating funcion.
--   
--   You'll notice that most of the useful functions from
--   <a>System.Random</a> fit this form:
--   
--   <pre>
--   <a>random</a>  :: <a>RandomGen</a> g =&gt;            g -&gt; (b, g)
--   <a>randomR</a> :: <a>RandomGen</a> g =&gt; (b, b) -&gt; (g -&gt; (b, g))
--   </pre>
--   
--   If you are using something from <a>MonadRandom</a>, then you can use
--   the <tt>runRand</tt> function to turn a <tt><tt>Rand</tt> g b</tt>
--   into a <tt>g -&gt; (b, g)</tt>:
--   
--   <pre>
--   <tt>runRand</tt> :: <a>RandomGen</a> g =&gt; <tt>Rand</tt> g b -&gt; (g -&gt; (b, g))
--   </pre>
--   
--   Here is an example using <a>stdRands</a> (for <a>StdGen</a>), but
--   <a>rands</a> works exactly the same way, I promise!
--   
--   <pre>
--   &gt;&gt;&gt; let g = mkStdGen 8675309
--   
--   &gt;&gt;&gt; let a = stdRands (randomR (1,100)) g :: Auto' a Int
--   
--   &gt;&gt;&gt; let (res, _) = stepAutoN' 10 a ()
--   
--   &gt;&gt;&gt; res
--   [67, 15, 97, 13, 55, 12, 34, 86, 57, 42]
--   </pre>
--   
--   Yeah, if you are using <a>StdGen</a> from <a>System.Random</a>, you'll
--   notice that <a>StdGen</a> has no <a>Serialize</a> instance, so you
--   can't use it with this; you have to either use <a>stdRands</a> or
--   <a>rands_</a> (if you don't want serialization/resumability).
--   
--   In the context of these generators, resumability basically means
--   deterministic behavior over re-loads.
rands :: (Serialize g, RandomGen g) => (g -> (b, g)) -> g -> Auto m a b

-- | Like <a>rands</a>, but specialized for <a>StdGen</a> from
--   <a>System.Random</a>, so that you can serialize and resume. This is
--   needed because <a>StdGen</a> doesn't have a <a>Serialize</a> instance.
--   
--   See the documentation of <a>rands</a> for more information.
stdRands :: (StdGen -> (b, StdGen)) -> StdGen -> Auto m a b

-- | The non-serializing/non-resuming version of <a>rands</a>.
rands_ :: RandomGen g => (g -> (b, g)) -> g -> Auto m a b

-- | Like <a>rands</a>, except taking a "monadic" random seed function
--   <tt>g -&gt; m (b, g)</tt>, instead of <tt>g -&gt; (b, g)</tt>. Your
--   random generating function has access to the underlying monad.
--   
--   If you are using something from <a>MonadRandom</a>, then you can use
--   the <tt>runRandT</tt> function to turn a <tt><tt>RandT</tt> g m b</tt>
--   into a <tt>g -&gt; m (b, g)</tt>:
--   
--   <pre>
--   <tt>runRandT</tt> :: (<a>Monad</a> m, <a>RandomGen</a> g)
--              =&gt; <tt>RandT</tt> g m b -&gt; m (g -&gt; (b, g))
--   </pre>
randsM :: (Serialize g, RandomGen g, Monad m) => (g -> m (b, g)) -> g -> Auto m a b

-- | Like <a>randsM</a>, but specialized for <a>StdGen</a> from
--   <a>System.Random</a>, so that you can serialize and resume. This is
--   needed because <a>StdGen</a> doesn't have a <a>Serialize</a> instance.
--   
--   See the documentation of <a>randsM</a> for more information.
stdRandsM :: Monad m => (StdGen -> m (b, StdGen)) -> StdGen -> Auto m a b

-- | The non-serializing/non-resuming version of <a>randsM</a>.
randsM_ :: (RandomGen g, Monad m) => (g -> m (b, g)) -> g -> Auto m a b

-- | Simulates a <a>Bernoulli Process</a>: a process where, at every trial,
--   the result is "on" with the given probability <tt>p</tt>, and "off"
--   otherwise. Every step is independent from the last.
--   
--   Basically, the result of every trial is an independent weighted coin
--   flip.
--   
--   It is implemented here as a <a>Blip</a> stream that emits whenever the
--   Bernoulli trial succeeds and does not emit otherwise.
--   
--   It is expected that, for probability <tt>p</tt>, the stream will emit
--   a value on average once every <tt>1/p</tt> ticks.
bernoulli :: (Serialize g, RandomGen g) => Double -> g -> Auto m a (Blip a)

-- | Like <a>bernoulli</a>, but specialized for <a>StdGen</a> from
--   <a>System.Random</a>, so that you can serialize and resume. This is
--   needed because <a>StdGen</a> doesn't have a <a>Serialize</a> instance.
--   
--   See the documentation of <a>bernoulli</a> for more information.
stdBernoulli :: Double -> StdGen -> Auto m a (Blip a)

-- | The non-serializing/non-resuming version of <a>bernoulli</a>.
bernoulli_ :: RandomGen g => Double -> g -> Auto m a (Blip a)

-- | An <a>Auto</a> that outputs intervals that are "on" and "off" for
--   contiguous but random lengths of time --- when "on", it allows values
--   to pass (in a <a>Just</a>); when "off", it prevents values from
--   passing (as <a>Nothing</a>).
--   
--   You provide a <a>Double</a>, an <tt>l</tt> parameter, representing the
--   average/expected length of each interval.
--   
--   The distribution of interval lengths follows a <a>Geometric
--   Distribution</a>. This distribution is, as we call it in maths,
--   "memoryless", which means that the "time left" that the <a>Auto</a>
--   will be "on" or "off" at any given time is going to be, on average,
--   the given <tt>l</tt> parameter.
--   
--   Internally, the "toggling" events follow a bernoulli process with a
--   <tt>p</tt> parameter of <tt>1 / l</tt>.
randIntervals :: (Serialize g, RandomGen g) => Double -> g -> Auto m a (Maybe a)

-- | Like <a>randIntervals</a>, but specialized for <a>StdGen</a> from
--   <a>System.Random</a>, so that you can serialize and resume. This is
--   needed because <a>StdGen</a> doesn't have a <a>Serialize</a> instance.
--   
--   See the documentation of <a>randIntervals</a> for more information.
stdRandIntervals :: Double -> StdGen -> Auto m a (Maybe a)

-- | The non-serializing/non-resuming version of <a>randIntervals</a>.
randIntervals_ :: RandomGen g => Double -> g -> Auto m a (Maybe a)


-- | A collection of versatile switching mechanisms. Switching is really a
--   core mechanic at the heart of how to structure a lot of program
--   logics. Switching from one "mode" to another, from dead to alive, from
--   room to room, menu to menu...switching between <a>Auto</a>s is a core
--   part about how many programs are built.
--   
--   All of the switches here take advantage of either <a>Blip</a>
--   semantics (from <a>Control.Auto.Blip</a>) or <i>Interval</i> semantics
--   (from <a>Control.Auto.Interval</a>)...so this is where maintaining
--   semantically meaningful <a>Blip</a> streams and intervals pays off!
--   
--   Each switch here has various examples, and you'll find many of these
--   in use in the <a>example projects</a>.
--   
--   Note the naming convention going on here (also used in
--   <a>Control.Auto.Serialize</a>): A switch "from" a <a>Blip</a> stream
--   is triggered "internally" by the <a>Auto</a> being switched itself; a
--   switch "on" a <a>Blip</a> stream is triggered "externally" by an
--   <a>Auto</a> that is <i>not</i> swiched.
module Control.Auto.Switch

-- | "One after the other". Behave like the first <a>Auto</a> (and run only
--   its effects) as long as it is "on" (<a>Just</a>). As soon as it is
--   <a>Nothing</a>, begin behaving like the second <a>Auto</a>
--   forevermore, and running the second <a>Auto'</a>s effects, if any.
--   Works well if the <a>Auto</a>s follow interval semantics from
--   <a>Control.Auto.Interval</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let a1 = (onFor 2 . pure "hello") --&gt; pure "world"
--   
--   &gt;&gt;&gt; let Output res1 _ = stepAutoN' 5 a1 ()
--   
--   &gt;&gt;&gt; res1
--   ["hello", "hello", "world", "world", "world"]
--   </pre>
--   
--   (Recall that <tt><a>pure</a> "hello"</tt> is the <a>Auto</a> that
--   ignores its input and constantly outputs "hello", and
--   <tt><tt>onFor</tt> 2</tt> lets its input pass "on" (<a>Just</a>) for
--   two steps, then is "off" (<a>Nothing</a>) ever after.)
--   
--   Association works in a way that you can "chain" <a>--&gt;</a>s, as
--   long as you have a non-<a>Maybe</a> / non-<a>Interval</a> <a>Auto</a>
--   at the end.
--   
--   <pre>
--   &gt;&gt;&gt; let a2 = onFor 2 . pure "hello"
--            --&gt; onFor 2 . pure "world"
--            --&gt; pure "goodbye!"
--   
--   &gt;&gt;&gt; let Output res2 _ = stepAutoN' 6 a2 ()
--   
--   &gt;&gt;&gt; res2
--   ["hello", "hello", "world", "world", "goodbye!", "goodbye!"]
--   </pre>
--   
--   <tt>a --&gt; b --&gt; c</tt> associates as <tt>a --&gt; (b --&gt;
--   c)</tt>
--   
--   This is pretty invaluable for having <a>Auto</a>s "step" through a
--   series of different <a>Auto</a>s, progressing their state from one
--   stage to the next. <a>Auto</a>s can control when they want to be
--   "moved on" from by turning "off" (outputting <a>Nothing</a>).
--   
--   Note that recursive bindings work just fine, so:
--   
--   <pre>
--   &gt;&gt;&gt; let a3 = onFor 2 . pure "hello"
--            --&gt; onFor 2 . pure "world"
--            --&gt; a3
--   
--   &gt;&gt;&gt; let (res3, _) = stepAutoN' 8 a3 ()
--   
--   &gt;&gt;&gt; res3
--   ["hello", "hello", "world", "world", "hello", "hello", "world", "world"]
--   </pre>
--   
--   the above represents an infinite loop between outputting "hello" and
--   outputting "world".
--   
--   By the way, it might be worth contrasting this with
--   <tt>&lt;|!&gt;</tt> and <tt>&lt;|?&gt;</tt> from
--   <a>Control.Auto.Interval</a>, which have the same type signatures.
--   Those alternative-y operators always <i>feed the input to both
--   sides</i>, <i>run both sides</i>, and output the first <a>Just</a>.
--   With <tt>&lt;|!&gt;</tt>, you can "switch back and forth" to the first
--   <a>Auto</a> as soon as the first <a>Auto</a> is "on" (<a>Just</a>)
--   again.
--   
--   <a>--&gt;</a>, in contrast, runs <i>only</i> the first <a>Auto</a>
--   until it is off (<a>Nothing</a>)...then runs <i>only</i> the second
--   <a>Auto</a>. This transition is one-way, as well.
(-->) :: Monad m => Auto m a (Maybe b) -> Auto m a b -> Auto m a b

-- | A variation of <a>--&gt;</a>, where the right hand side can also be an
--   interval/<a>Maybe</a>. The entire result is, then, a <a>Maybe</a>.
--   Probably less useful than <a>--&gt;</a> in most situations.
(-?>) :: Monad m => Auto m a (Maybe b) -> Auto m a (Maybe b) -> Auto m a (Maybe b)

-- | Takes an <a>Auto</a> that emits an output with a <a>Blip</a> stream
--   emitting <a>Auto</a>s.
--   
--   <tt><a>switchFrom_</a> a0</tt> behaves like <tt><a>fst</a>
--   <a>&lt;$&gt;</a> a0</tt> at first, outputting the first part of the
--   result tuple. Then, as soon as the <a>Blip</a> stream emits with an
--   <a>Auto</a> <tt>a1</tt>, the whole thing behaves like <tt>a1</tt>
--   forever.
--   
--   In the following example, <tt>a1</tt> is an <a>Auto</a> that counts
--   upwards forever and also outputs a <a>Blip</a> stream that will emit
--   an <a>Auto</a> containing <tt><a>pure</a> 100</tt> (the <a>Auto</a>
--   that always emits 100) after three steps.
--   
--   <pre>
--   a1 :: Auto' () (Int, Blip (Auto' () Int))
--   a1 = proc _ -&gt; do
--       c          &lt;- count -&lt; ()
--       switchBlip &lt;- inB 3 -&lt; pure 100
--       id -&lt; (c, switchBlip)
--   
--   -- alternatively
--   a1' = count &amp;&amp;&amp; (tagBlips (pure 100) . inB 3)
--   </pre>
--   
--   So, <tt><a>switchFrom_</a> a1</tt> will be the output of
--   <tt>count</tt> for three steps, and then switch to <tt><a>pure</a>
--   100</tt> afterwards (when the <a>Blip</a> stream emits):
--   
--   <pre>
--   &gt;&gt;&gt; let (res1, _) = stepAutoN' 6 (switchFrom_ a1) ()
--   
--   &gt;&gt;&gt; res1
--   [0, 1, 2, 100, 100, 100]
--   </pre>
--   
--   This is fun to use with recursion, so you can get looping switches:
--   
--   <pre>
--    a2 :: Auto' () (Int, Blip (Auto' () Int))
--    a2 = proc _ -&gt; do
--        c &lt;- count -&lt; ()
--        switchBlip &lt;- inB 3 -&lt; switchFrom_ a2
--        id -&lt; (c, switchBlip)
--   
--   -- alternatively
--   a2' = count &amp;&amp;&amp; (tagBlips (switchFrom_ a2) . inB 3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (res2, _) = stepAutoN' 10 (switchFrom_ a2) ()
--   
--   &gt;&gt;&gt; res2
--   [0, 1, 2, 0, 1, 2, 0, 1, 2, 0]
--   </pre>
--   
--   Note that this combinator is inherently unserializable, so you are
--   going to lose all serialization capabilities if you use this. So sad,
--   I know! :( This fact is reflected in the underscore suffix, as per
--   convention.
--   
--   If you want to use switching <i>and</i> have serialization, you can
--   use the perfectly serialization-safe alternative, <a>switchFromF</a>,
--   which slightly less powerful in ways that are unlikely to be missed in
--   practical usage.
switchFrom_ :: Monad m => Auto m a (b, Blip (Auto m a b)) -> Auto m a b

-- | Is a little <a>Auto</a> box...whenever the input <a>Blip</a> stream
--   emits an <a>Auto</a>, it begins to behave like that emitted
--   <a>Auto</a>.
--   
--   Input to the contained <a>Auto</a> is fed through the first field of
--   the tuple, and a <a>Blip</a> stream emitting new <a>Auto</a>s is fed
--   through the second field.
--   
--   When the stream emits, <i>immediately</i> feeds the input to the new
--   <a>Auto</a>.
--   
--   Given an initial <a>Auto</a> to behave like.
--   
--   For example, here we push several <a>Auto</a>s one after the other
--   into the box: <tt><a>pure</a> 100</tt>, <tt>count</tt>, and
--   <tt><tt>iterator</tt> (+3) 0</tt>, starting with <tt><a>pure</a>
--   0</tt>. <tt><a>eachAt_</a> 3</tt> emits each <a>Auto</a> in the given
--   list every three steps, starting on the third.
--   
--   <pre>
--   newAutos :: Auto' () (Blip (Auto' () Int))
--   newAutos = eachAt_ 3 [pure 100, count, iterator (+3) 0]
--   
--   a :: Auto' () Int
--   a = proc _ -&gt; do
--       blipAutos &lt;- newAutos -&lt; ()
--       switchOn_ (pure 0)    -&lt; ((), blipAutos)
--   
--   -- alternatively
--   a' = switchOn_ (pure 0) . (pure () &amp;&amp;&amp; newAutos)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (res, _) = stepAutoN' 14 a ()
--   
--   &gt;&gt;&gt; res
--   [0, 0, 100, 100, 100, 0, 1, 2, 0, 3, 6, 9, 12, 15]
--   </pre>
--   
--   Like <a>switchFrom_</a>, this combinator is inherently unserializable.
--   So if you use it, you give up serialization for your <a>Auto</a>s.
--   This is reflected in the underscore suffix.
--   
--   If you wish to have the same switching devices but keep serialization,
--   you can use <a>switchOnF</a>, which is slightly less powerful, but
--   should be sufficient for all practical use cases.
switchOn_ :: Monad m => Auto m a b -> Auto m (a, Blip (Auto m a b)) b

-- | Like <a>switchOn_</a>, <tt><a>switchOnF</a> f a0</tt> is like a little
--   <a>Auto</a> box wrapping and running an <a>Auto</a>. It takes in both
--   an input and a <a>Blip</a> stream of <tt>c</tt>'s. It behaves just
--   like the internal <tt><a>Auto</a> m a b</tt>, and initially behaves
--   like <tt>a0</tt>, until the <a>Blip</a> stream emits.
--   
--   Then, it swaps the <a>Auto</a> for a <i>new</i> one, given by the
--   function <tt>f</tt>. <tt>f</tt> is applied to the <tt>c</tt> that the
--   stream emits, and that new <a>Auto</a> is placed into the box and is
--   immediately run on that same step.
--   
--   In the following example we are using just <tt><a>iterate</a>
--   (+1)</tt> for our "next <a>Auto</a>" function, and triggering it with
--   a <a>Blip</a> stream that counts up from 0.
--   
--   <pre>
--   nextAuto :: Int -&gt; Auto' () Int
--   nextAuto = iterator (+1)
--   
--   triggerer :: Auto' () (Blip Int)
--   triggerer = stretchB 3 (iterator (+10) 0)
--   
--   a :: Auto' () Int
--   a = proc _ -&gt; do
--       triggers &lt;- triggerer -&lt; ()
--       switchOnF nextAuto (nextAuto 0) -&lt; ((), triggers)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (res, _) = stepAutoN' 10 a ()
--   
--   &gt;&gt;&gt; res
--   [0,1,2,10,11,12,20,21,22,30,31]
--   </pre>
switchOnF :: (Monad m, Serialize c) => (c -> Auto m a b) -> Auto m a b -> Auto m (a, Blip c) b

-- | The non-serializing/non-resuming version of <a>switchOnF</a>.
switchOnF_ :: Monad m => (c -> Auto m a b) -> Auto m a b -> Auto m (a, Blip c) b

-- | Takes a function from a <tt>c</tt> to a new (next) <a>Auto</a>, and an
--   initial <a>Auto</a>.
--   
--   These <a>Auto</a>s all taken in <tt>a</tt> and output <tt>b</tt>,
--   along with a <a>Blip</a> stream of <tt>c</tt>s.
--   
--   <tt><a>switchFromF</a> f a0</tt> behaves like the current <a>Auto</a>
--   (beginning with <tt>a0</tt>), taking in the <tt>a</tt> and popping out
--   the <tt>b</tt>. However, as soon as the <a>Blip</a> stream emits a
--   <tt>c</tt>, it replaces internal <a>Auto</a> with a new one,
--   determined by the function.
--   
--   Here is an example where the "next <a>Auto</a>" function is
--   <tt>nextAuto</tt>:
--   
--   <pre>
--   nextAuto :: Int -&gt; Auto' () (String, Blip Int)
--   nextAuto i0 = proc _ -&gt; do
--       c     &lt;- sumFromD i0 -&lt; 1
--       nextB &lt;- inB 3       -&lt; c
--       id    -<a>c, (+10) &lt;$</a> nextB)
--   </pre>
--   
--   <tt>nextAuto</tt> continually counts upwards from the given initial
--   value <tt>i0</tt>. Then, on the third step, the <a>Blip</a> stream
--   emits with the value of the counter plus ten.
--   
--   <pre>
--   &gt;&gt;&gt; let (res0, _) = stepAutoN' 5 (nextAuto 0) ()
--   
--   &gt;&gt;&gt; res0
--   [("0", NoBlip), ("1", NoBlip), ("2", Blip 13), ("3", NoBlip), ("4", NoBlip)]
--   </pre>
--   
--   Let's see what happens when we wrap it with <a>switchFromF</a> and an
--   initial <a>Auto</a> of <tt><tt>nextAuto</tt> 0</tt>:
--   
--   <pre>
--   a :: Auto' () String
--   a = switchFromF nextAuto (nextAuto 0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (res, _) = stepAutoN' 10 a ()
--   
--   &gt;&gt;&gt; res
--   [ "0", "1", "2", "12", "13", "14", "24", "25", "26", "36", "37"]
--   </pre>
--   
--   Every three steps, the the <a>Auto</a> is replaced by a new one,
--   skipping ten steps ahead. First it behaves like the first field of the
--   output of <tt>nextAuto 0</tt>, then like <tt>nextAuto 12</tt>, then
--   like <tt>nextAuto 24</tt>, etc.
--   
--   This is a more limited (but serializable) version of
--   <a>switchFrom_</a>, where you know the form of all the <a>Auto</a>s
--   you might be switching to in the future, and can generate them with a
--   function conceived ahead of time.
switchFromF :: (Monad m, Serialize c) => (c -> Auto m a (b, Blip c)) -> Auto m a (b, Blip c) -> Auto m a b

-- | The non-serializing/non-resuming version of <a>switchFromF</a>.
switchFromF_ :: Monad m => (c -> Auto m a (b, Blip c)) -> Auto m a (b, Blip c) -> Auto m a b

-- | Takes an innocent <a>Auto</a> and wraps a "reset button" around it. It
--   behaves just like the original <a>Auto</a> at first, but when the
--   <a>Blip</a> stream emits, the internal <a>Auto</a> is reset back to
--   the beginning.
--   
--   Here we have <tt>count</tt>, being reset every five steps:
--   
--   <pre>
--   &gt;&gt;&gt; let a = resetOn count . (pure () &amp;&amp;&amp; every 5)
--   
--   &gt;&gt;&gt; let (res, _) = stepAutoN' 15 a ()
--   
--   &gt;&gt;&gt; res
--   [0,1,2,3,0,1,2,3,4,0,1,2,3,4,0]
--   </pre>
resetOn :: Monad m => Auto m a b -> Auto m (a, Blip c) b

-- | Gives an <a>Auto</a> the ability to "reset" itself on command
--   
--   Basically acts like <tt><a>fmap</a> <a>fst</a></tt>
--   
--   <pre>
--   fmap fst :: Monad m =&gt; Auto m a (b, Blip c) -&gt; Auto m a b
--   </pre>
--   
--   But...whenever the <a>Blip</a> stream emits..."resets" the <a>Auto</a>
--   back to the original state, as if nothing ever happened.
--   
--   Here is a counter that attempts to resets itself every three steps:
--   
--   <pre>
--   resetCounter :: Auto' () (Int, Blip ())
--   resetCounter = count &amp;&amp;&amp; inB 3
--   </pre>
--   
--   And now we throw it into <a>resetFrom</a>:
--   
--   <pre>
--   resettingCounter :: Auto' () Int
--   resettingCounter = resetFrom resetCounter
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (res, _) = stepAutoN' 11 resettingCounter ()
--   
--   &gt;&gt;&gt; res
--   [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1]
--   </pre>
resetFrom :: Monad m => Auto m a (b, Blip c) -> Auto m a b

module Control.Auto

-- | The output of a <a>stepAuto</a>. Contains the "result" value of the
--   stepping (<a>outRes</a>), and the "next <a>Auto</a>", <a>outAuto</a>.
--   
--   An <tt><a>Auto</a> m a b</tt> will produce an <tt><a>Output</a> m a
--   b</tt>; when "stepped" with an <tt>a</tt>, the "result"
--   (<a>outRes</a>) is a <tt>b</tt>.
--   
--   Really, you can just think of this as a fancy tuple.
data Output m a b
Output :: b -> Auto m a b -> Output m a b

-- | Result value of a step
outRes :: Output m a b -> b

-- | The next <a>Auto</a>
outAuto :: Output m a b -> Auto m a b

-- | Special case of <a>Output</a> where the underlying <a>Monad</a> of
--   <a>outAuto</a> is <a>Identity</a>.
type Output' = Output Identity

-- | Map two functions onto both fields of an <a>Output</a>.
--   
--   If you want to map an <tt>a -&gt; b</tt> onto both fields (the result
--   and the result of the next Auto), you can use the <a>Functor</a>
--   instance instead.
onOutput :: (b -> b') -> (Auto m a b -> Auto m a' b') -> Output m a b -> Output m a' b'

-- | A type representing a "discrete" sort of event-like thing. It's
--   supposed to represent something that happens alone, and one at a time,
--   as opposed to things that are "on" or "off" for large intervals at a
--   time.
--   
--   It's here mainly because it's a pretty useful abstraction in the
--   context of the many combinators found in various modules of this
--   library. If you think of an <tt><tt>Auto</tt> m a (<a>Blip</a> b)</tt>
--   as a "<a>Blip</a> stream", then there are various combinators and
--   functions that are specifically designed to manipulate "<a>Blip</a>
--   streams".
--   
--   For the purposes of the semantics of what <a>Blip</a> is supposed to
--   represent, its constructors are hidden. (Almost) all of the various
--   <a>Blip</a> combinators (and its very useful <a>Functor</a> instance)
--   "preserve <a>Blip</a>ness" --- one-at-a-time occurrences remain
--   one-at-a-time under all of these combinators, and you should have
--   enough so that direct access to the constructor is not needed.
--   
--   If you are creating a framework, library, or backend, you might want
--   to manually create <a>Blip</a> stream-producing <tt>Auto</tt>s for
--   your users to access. In this case, you can import the constructors
--   and useful internal (and, of course, semantically unsafe) functions
--   from <a>Control.Auto.Blip.Internal</a>.
data Blip a

-- | The Auto type. Basically represents a function containing its own
--   localized internal state. If you have an <tt><a>Auto</a> a b</tt>, you
--   can "step" it with <a>stepAuto</a> and an <tt>a</tt>, to get a
--   <tt>b</tt> and a "next <a>Auto</a>". The <tt>a</tt> is the input, and
--   the <tt>b</tt> is the output, and the next <a>Auto</a> is the
--   <a>Auto</a> with updated internal state.
--   
--   The "stepping" process can be monadic:
--   
--   <pre>
--   stepAuto :: Auto m a b -&gt; a -&gt; m (Output m a b)
--   </pre>
--   
--   So you can have access to, say, a shared environment using
--   <tt>Reader</tt> or something like that.
--   
--   <a>Auto</a> is mostly useful because of its <a>Functor</a>,
--   <a>Applicative</a>, <a>Category</a>, and <a>Arrow</a> (and
--   Arrow-related) instances. These allow you to modify, combine, chain,
--   and side-chain Autos in expressive way, allowing you to build up
--   complex ones from combinations of simple, primitive ones.
--   
--   TODO: see tutorial
--   
--   The <a>Auto</a> also contains information on its own serialization, so
--   you can serialize and re-load the internal state without actually
--   accessing it.
data Auto m a b

-- | Special case of <a>Auto</a> where the underlying <a>Monad</a> is
--   <a>Identity</a>.
type Auto' = Auto Identity

-- | <a>Runs</a> the <a>Auto</a> through one step.
--   
--   Remember that at every step for an <tt><a>Auto</a> m a b</tt>, you
--   provide an <tt>a</tt> input and receive a <tt>b</tt> output with an
--   "updated"/"next" <a>Auto</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let a = mkAccum (+) 0 :: Auto Identity Int Int
--               -- an Auto that sums all of its input.
--   
--   &gt;&gt;&gt; let Identity (Output y a') = stepAuto a 3
--   
--   &gt;&gt;&gt; y      -- the result
--   3 :: Int
--   
--   &gt;&gt;&gt; :t a'   -- the updated 'Auto'
--   a' :: Auto Identity Int Int
--   </pre>
--   
--   (<a>Identity</a>, from <a>Data.Functor.Identity</a>, is the "dumb
--   Functor": <tt>data <a>Identity</a> a = <a>Identity</a> a</tt>)
--   
--   If you think of an <tt><a>Auto</a> m a b</tt> as a "stateful function"
--   of type <tt>a -&gt; m b</tt>, then <a>stepAuto</a> lets you "run" it.
stepAuto :: Monad m => Auto m a b -> a -> m (Output m a b)

-- | <a>stepAuto</a>, but for an <a>Auto'</a> --- the underlying
--   <a>Monad</a> is <a>Identity</a>.
stepAuto' :: Auto' a b -> a -> Output' a b

-- | Repeatedly steps an <a>Auto</a> with the same input a given number of
--   times.
--   
--   <pre>
--   stepAutoN n a0 x = overList a0 (replicate n x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a          = iterator (*2) 1
--   
--   &gt;&gt;&gt; let (ys, a')   = runIdentity (stepAutoN 8 a ())
--   
--   &gt;&gt;&gt; ys
--   [1, 2, 4, 8, 16, 32, 64, 128]
--   
--   &gt;&gt;&gt; let Output y _ = runIdentity (stepAuto a ())
--   
--   &gt;&gt;&gt; y
--   256
--   </pre>
stepAutoN :: Monad m => Int -> Auto m a b -> a -> m ([b], Auto m a b)

-- | Like <a>stepAutoN</a>, but with an <a>Auto'</a> (the underlying
--   <a>Monad</a> is <a>Identity</a>)
--   
--   <pre>
--   &gt;&gt;&gt; let a          = iterator (*2) 1
--   
--   &gt;&gt;&gt; let (ys, a')   = stepAutoN 8 a ()
--   
--   &gt;&gt;&gt; ys
--   [1, 2, 4, 8, 16, 32, 64, 128]
--   
--   &gt;&gt;&gt; let Output y _ = stepAuto a ()
--   
--   &gt;&gt;&gt; y
--   256
--   </pre>
stepAutoN' :: Int -> Auto' a b -> a -> ([b], Auto' a b)

-- | Encode an <a>Auto</a> and its internal state into a <a>ByteString</a>.
encodeAuto :: Auto m a b -> ByteString

-- | <a>Resume</a> an <a>Auto</a> from its <a>ByteString</a> serialization,
--   giving a <a>Left</a> if the deserialization is not possible.
decodeAuto :: Auto m a b -> ByteString -> Either String (Auto m a b)

-- | A special <a>Auto</a> that acts like the <a>id</a> <a>Auto</a>, but
--   forces results as they come through to be fully evaluated, when
--   composed with other <a>Auto</a>s.
forcer :: NFData a => Auto m a a

-- | A special <a>Auto</a> that acts like the <a>id</a> <a>Auto</a>, but
--   forces results as they come through to be evaluated to Weak Head
--   Normal Form, with <a>seq</a>, when composed with other <a>Auto</a>s.
seqer :: Auto m a a

-- | An <a>Auto</a> that returns the last value received by it. Given an
--   "initial value" to output first.
--   
--   This is (potentially) a <b>very dangerous</b> <a>Auto</a>, because its
--   usage and its very existence opens the door to breaking
--   denotative/declarative style and devolving into imperative style
--   coding. However, when used where it is supposed to be used, it is more
--   or less invaluable, and will be an essential part of many programs.
--   
--   Its main usage is for dealing with bindings. If you ever are laying
--   out recursive bindings in a high-level/denotative way, you need to
--   have at least one value be able to have a "initial output" without
--   depending on anything else. <a>lastVal</a> and <a>delay</a> allow you
--   to do this.
--   
--   See the <a>recursive</a> example for more information on the
--   appropriate usage of <a>lastVal</a> and <a>delay</a>.
lastVal :: Serialize a => a -> Auto m a a

-- | The non-resuming/non-serializing version of <a>lastVal</a>.
lastVal_ :: a -> Auto m a a

-- | Construct an <a>Auto</a> from a state transformer: an <tt>a -&gt; s
--   -&gt; (b, s)</tt> gives you an <tt><a>Auto</a> m a b</tt>, for any
--   <a>Monad</a> <tt>m</tt>. At every step, it takes in the <tt>a</tt>
--   input, runs the function with the stored internal state, returns the
--   <tt>b</tt> result, and now contains the new resulting state. You have
--   to intialize it with an initial state, of course.
--   
--   Try not to use this if it's ever avoidable, unless you're a framework
--   developer or something. Try make something by combining/composing the
--   various <a>Auto</a> combinators.
--   
--   This version is a wrapper around <a>mkAuto</a>, that keeps track of
--   the serialization and re-loading of the internal state for you, so you
--   don't have to deal with it explicitly.
--   
--   If your state <tt>s</tt> does not have a <a>Serialize</a> instance,
--   then you should either write a meaningful one, provide the
--   serialization methods manually with <a>mkState'</a>, or throw away
--   serializability and use <a>mkState_</a>.
mkState :: Serialize s => (a -> s -> (b, s)) -> s -> Auto m a b

-- | Construct an <a>Auto</a> from a "monadic" state transformer: <tt>a
--   -&gt; s -&gt; m (b, s)</tt> gives you an <tt><a>Auto</a> m a b</tt>.
--   At every step, it takes in the <tt>a</tt> input, runs the function
--   with the stored internal state and "executes" the <tt>m (b, s)</tt> to
--   get the <tt>b</tt> output, and stores the <tt>s</tt> as the new,
--   updated state. Must be initialized with an initial state.
--   
--   Try not to use this if it's ever avoidable, unless you're a framework
--   developer or something. Try make something by combining/composing the
--   various <a>Auto</a> combinators.
--   
--   This version is a wrapper around <a>mkAuto</a>, that keeps track of
--   the serialization and re-loading of the internal state for you, so you
--   don't have to deal with it explicitly.
--   
--   If your state <tt>s</tt> does not have a <a>Serialize</a> instance,
--   then you should either write a meaningful one, provide the
--   serialization methods manually with <a>mkStateM'</a>, or throw away
--   serializability and use <a>mkStateM_</a>.
mkStateM :: Serialize s => (a -> s -> m (b, s)) -> s -> Auto m a b

-- | A version of <a>mkState</a>, where the internal state isn't
--   serialized. It can be "saved" and "loaded", but the state is lost in
--   the process.
--   
--   Useful if your state <tt>s</tt> cannot have a meaningful
--   <a>Serialize</a> instance.
mkState_ :: (a -> s -> (b, s)) -> s -> Auto m a b

-- | A version of <a>mkStateM</a>, where the internal state isn't
--   serialized. It can be "saved" and "loaded", but the state is lost in
--   the process.
--   
--   Useful if your state <tt>s</tt> cannot have a meaningful
--   <a>Serialize</a> instance.
mkStateM_ :: (a -> s -> m (b, s)) -> s -> Auto m a b

-- | Construct an <a>Auto</a> from a "folding" function: <tt>b -&gt; a
--   -&gt; b</tt> yields an <tt><a>Auto</a> m a b</tt>. Basically acts like
--   a <a>foldl</a> or a <a>scanl</a>. There is an internal accumulator
--   that is "updated" with an <tt>a</tt> at every step. Must be given an
--   initial accumulator.
--   
--   Example: an <a>Auto</a> that sums up all of its input.
--   
--   <pre>
--   &gt;&gt;&gt; let summer = mkAccum (+) 0
--   
--   &gt;&gt;&gt; let Output sum1 summer' = stepAuto summer 3
--   
--   &gt;&gt;&gt; sum1
--   3
--   
--   &gt;&gt;&gt; let Output sum2 _       = stepAuto summer'' 10
--   
--   &gt;&gt;&gt; sum2
--   13
--   </pre>
--   
--   If your accumulator <tt>b</tt> does not have a <a>Serialize</a>
--   instance, then you should either write a meaningful one, or throw away
--   serializability and use <a>mkAccum_</a>.
mkAccum :: Serialize b => (b -> a -> b) -> b -> Auto m a b

-- | A version of 'mkAccum_, where the internal accumulator isn't
--   serialized. It can be "saved" and "loaded", but the state is lost in
--   the process.
--   
--   Useful if your accumulator <tt>b</tt> cannot have a meaningful
--   <a>Serialize</a> instance.
mkAccum_ :: (b -> a -> b) -> b -> Auto m a b

-- | Construct an <a>Auto</a> from a "monadic" "folding" function: <tt>b
--   -&gt; a -&gt; m b</tt> yields an <tt><a>Auto</a> m a b</tt>. Basically
--   acts like a <a>foldM</a> or <tt>scanM</tt> (if it existed). here is an
--   internal accumulator that is "updated" with an input <tt>a</tt> with
--   the result of the executed <tt>m b</tt> at every step. Must be given
--   an initial accumulator.
--   
--   If your accumulator <tt>b</tt> does not have a <a>Serialize</a>
--   instance, then you should either write a meaningful one, or throw away
--   serializability and use <a>mkAccumM_</a>.
mkAccumM :: (Serialize b, Monad m) => (b -> a -> m b) -> b -> Auto m a b

-- | A version of 'mkAccumM_, where the internal accumulator isn't
--   serialized. It can be "saved" and "loaded", but the state is lost in
--   the process.
--   
--   Useful if your accumulator <tt>b</tt> cannot have a meaningful
--   <a>Serialize</a> instance.
mkAccumM_ :: Monad m => (b -> a -> m b) -> b -> Auto m a b

-- | A "delayed" version of <a>mkAccum</a>, where the first output is
--   actually the initial state of the accumulator. Useful in recursive
--   bindings.
mkAccumD :: Serialize b => (b -> a -> b) -> b -> Auto m a b

-- | The non-resuming/non-serializing version of <a>mkAccumD</a>.
mkAccumD_ :: (b -> a -> b) -> b -> Auto m a b

-- | A "delayed" version of <a>mkAccumM</a>, where the first output is
--   actually the initial state of the accumulator. Useful in recursive
--   bindings.
mkAccumMD :: (Serialize b, Monad m) => (b -> a -> m b) -> b -> Auto m a b

-- | The non-resuming/non-serializing version of <a>mkAccumMD</a>.
mkAccumMD_ :: Monad m => (b -> a -> m b) -> b -> Auto m a b

-- | Analogous to <a>iterate</a> from <a>Prelude</a>. Keeps accumulator
--   value and continually applies the function to the value at every step,
--   outputting the result.
--   
--   The first result is the initial accumulator value.
--   
--   <pre>
--   &gt;&gt;&gt; let (y, _) = stepAutoN' 10 (iterator (*2) 1) ()
--   
--   &gt;&gt;&gt; y
--   [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
--   </pre>
iterator :: Serialize b => (b -> b) -> b -> Auto m a b

-- | The non-resuming/non-serializing version of <a>iterator</a>.
iterator_ :: (b -> b) -> b -> Auto m a b

-- | Like <a>iterator</a>, but with a monadic function.
iteratorM :: (Serialize b, Monad m) => (b -> m b) -> b -> Auto m a b

-- | The non-resuming/non-serializing version of <a>iteratorM</a>.
iteratorM_ :: Monad m => (b -> m b) -> b -> Auto m a b
