<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Auto.Core</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Auto-Core.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">auto-0.1.0.0: DSL providing denotational, compositional semantics for
discrete-step, locally stateful, interactive programs,
games &amp; automations.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Justin Le 2014</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>justin@jle.im</td></tr><tr><th>Stability</th><td>unstable</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Auto.Core</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Auto</a><ul><li><a href="#g:2">Type</a></li><li><a href="#g:3">Running</a></li><li><a href="#g:4">Serializing</a></li></ul></li><li><a href="#g:5">Auto output</a></li><li><a href="#g:6">Auto constructors</a><ul><li><a href="#g:7">Lifting values and functions</a></li><li><a href="#g:8">from State transformers</a></li><li><a href="#g:9">from Accumulators</a><ul><li><a href="#g:10">Result-first</a></li><li><a href="#g:11">Initial accumulator-first</a></li></ul></li><li><a href="#g:12">Arbitrary Autos</a></li></ul></li><li><a href="#g:13">Strictness</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module defines and provides the core types, (smart) constructors,
 and general utilities used by the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> library.</p><p>A lot of low-level functionality is provided here which is most likely
 unnecessary for most applications; many are mostly for internal usage or
 advanced/fine-grained usage; it also isn't really enough to do many
 things with, either.  It's recommended that you import <a href="Control-Auto.html">Control.Auto</a>
 instead, which re-organizes the more useful parts of this module in
 addition with useful parts of others to provide a nice packaged entry
 point.</p><p>For information on how to actually use these types, see
 <a href="Control-Auto-Tutorial.html">Control.Auto.Tutorial</a>.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Auto">Auto</a> m a b</li><li class="src short"><span class="keyword">type</span> <a href="#t:Auto-39-">Auto'</a> = <a href="Control-Auto-Core.html#t:Auto">Auto</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></li><li class="src short"><a href="#v:autoConstr">autoConstr</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:toArb">toArb</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:stepAuto">stepAuto</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; a -&gt; m (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</li><li class="src short"><a href="#v:stepAuto-39-">stepAuto'</a> ::  <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b -&gt; a -&gt; <a href="Control-Auto-Core.html#t:Output-39-">Output'</a> a b</li><li class="src short"><a href="#v:encodeAuto">encodeAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:decodeAuto">decodeAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</li><li class="src short"><a href="#v:saveAuto">saveAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a></li><li class="src short"><a href="#v:loadAuto">loadAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</li><li class="src short"><span class="keyword">data</span> <a href="#t:Output">Output</a> m a b = <a href="#v:Output">Output</a> {<ul class="subs"><li><a href="#v:outRes">outRes</a> :: b</li><li><a href="#v:outAuto">outAuto</a> :: <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:Output-39-">Output'</a> = <a href="Control-Auto-Core.html#t:Output">Output</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></li><li class="src short"><a href="#v:onOutput">onOutput</a> ::  (b -&gt; b') -&gt; (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a' b') -&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a' b'</li><li class="src short"><a href="#v:onOutRes">onOutRes</a> ::  (b -&gt; b) -&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b</li><li class="src short"><a href="#v:onOutAuto">onOutAuto</a> ::  (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a' b) -&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a' b</li><li class="src short"><a href="#v:mkConst">mkConst</a> ::  b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkConstM">mkConstM</a> ::  m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkFunc">mkFunc</a> ::  (a -&gt; b) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkFuncM">mkFuncM</a> ::  (a -&gt; m b) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkState">mkState</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s =&gt; (a -&gt; s -&gt; (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkState_">mkState_</a> ::  (a -&gt; s -&gt; (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkStateM">mkStateM</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s =&gt; (a -&gt; s -&gt; m (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkStateM_">mkStateM_</a> ::  (a -&gt; s -&gt; m (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkState-39-">mkState'</a> ::  <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a> s -&gt; (s -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a>) -&gt; (a -&gt; s -&gt; (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkStateM-39-">mkStateM'</a> ::  <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a> s -&gt; (s -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a>) -&gt; (a -&gt; s -&gt; m (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAccum">mkAccum</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAccum_">mkAccum_</a> ::  (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAccumM">mkAccumM</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAccumM_">mkAccumM_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAccumD">mkAccumD</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAccumD_">mkAccumD_</a> ::  (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAccumMD">mkAccumMD</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAccumMD_">mkAccumMD_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAuto">mkAuto</a> ::  <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b) -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a> -&gt; (a -&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAuto_">mkAuto_</a> ::  (a -&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAutoM">mkAutoM</a> ::  <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b) -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a> -&gt; (a -&gt; m (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAutoM_">mkAutoM_</a> ::  (a -&gt; m (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:forceSerial">forceSerial</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:forcer">forcer</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/deepseq-1.3.0.2/Control-DeepSeq.html#t:NFData">NFData</a> a =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:seqer">seqer</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a a</li></ul></div><div id="interface"><h1 id="g:1">Auto</h1><h2 id="g:2">Type</h2><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Auto" class="def">Auto</a> m a b</p><div class="doc"><p>The Auto type.  Basically represents a function containing its own
 localized internal state.  If you have an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> a b</code>, you can &quot;step&quot;
 it with <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code> and an <code>a</code>, to get a <code>b</code> and a &quot;next <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;.  The
 <code>a</code> is the input, and the <code>b</code> is the output, and the next <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> is the
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> with updated internal state.</p><p>The &quot;stepping&quot; process can be monadic:</p><pre>stepAuto :: Auto m a b -&gt; a -&gt; m (Output m a b)</pre><p>So you can have access to, say, a shared environment using <code>Reader</code> or
 something like that.</p><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> is mostly useful because of its <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a></code>, <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a></code>,
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#t:Category">Category</a></code>, and <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:Arrow">Arrow</a></code> (and Arrow-related) instances.  These allow you
 to modify, combine, chain, and side-chain Autos in expressive way,
 allowing you to build up complex ones from combinations of simple,
 primitive ones.</p><p>TODO: see tutorial</p><p>The <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> also contains information on its own serialization, so you
 can serialize and re-load the internal state without actually accessing
 it.</p></div><div class="subs instances"><p id="control.i:Auto" class="caption collapser" onclick="toggleSection('i:Auto')">Instances</p><div id="section.i:Auto" class="show"><table><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#t:Category">Category</a> * (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:Arrow">Arrow</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:ArrowChoice">ArrowChoice</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad-Fix.html#t:MonadFix">MonadFix</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:ArrowLoop">ArrowLoop</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.2.0.1/html/Data-Profunctor-Unsafe.html#t:Profunctor">Profunctor</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a> m) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Floating">Floating</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Floating">Floating</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Fractional">Fractional</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Fractional">Fractional</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.15.3/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> b) =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.15.3/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Auto-39-" class="def">Auto'</a> = <a href="Control-Auto-Core.html#t:Auto">Auto</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></p><div class="doc"><p>Special case of <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> where the underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> is <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:autoConstr" class="def">autoConstr</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></p><div class="doc"><p>Returns a string representation of the internal constructor of the
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.  Useful for debugging the result of compositions and functions
 and seeing how they affect the internal structure of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:toArb" class="def">toArb</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Re-structure <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> internals to use the <code>Arb</code> (&quot;arbitrary&quot;)
 constructors, as recursion-based mealy machines.  Almost always a bad
 idea in every conceivable situation.  Why is it even here?</p></div></div><h2 id="g:3">Running</h2><div class="top"><p class="src"><a name="v:stepAuto" class="def">stepAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc"><p>the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> to step</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>the input</p></td></tr><tr><td class="src">-&gt; m (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</td><td class="doc"><p>the output, and the updated <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>.</p></td></tr></table></div><div class="doc"><p><a href="Runs.html">Runs</a> the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> through one step.</p><p>Remember that at every step for an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>, you provide an <code>a</code>
 input and receive a <code>b</code> output with an &quot;updated&quot;/&quot;next&quot; <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = mkAccum (+) 0 :: Auto Identity Int Int
</code></strong>            -- an Auto that sums all of its input.
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Identity (Output y a') = stepAuto a 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>y      -- the result
</code></strong>3 :: Int
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:t a'   -- the updated 'Auto'
</code></strong>a' :: Auto Identity Int Int
</pre><p>(<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></code>, from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html">Data.Functor.Identity</a>, is the &quot;dumb Functor&quot;: <code>data
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></code> a = <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></code> a</code>)</p><p>If you think of an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code> as a &quot;stateful function&quot; of type <code>a -&gt;
 m b</code>, then <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code> lets you &quot;run&quot; it.</p></div></div><div class="top"><p class="src"><a name="v:stepAuto-39-" class="def">stepAuto'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b</td><td class="doc"><p>the <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> to step</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>the input</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Output-39-">Output'</a> a b</td><td class="doc"><p>the output, and the updated <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code></p></td></tr></table></div><div class="doc"><p><code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code>, but for an <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> --- the underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> is
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></code>.  Returns the output stripped of <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></code>.</p><p>If you think of an <code><code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a b</code> as a &quot;stateful function&quot; of type
 <code>a -&gt; b</code>, then <code><a href="Control-Auto-Core.html#v:stepAuto-39-">stepAuto'</a></code> lets you &quot;run&quot; it.</p></div></div><h2 id="g:4">Serializing</h2><div class="doc"><p>The <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> type offers an interface in which you can serialize
 (&quot;freeze&quot;) and &quot;resume&quot; an Auto, in <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> (binary) form.</p><p>You can &quot;freeze&quot; any <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> into a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> using <code><a href="Control-Auto-Core.html#v:encodeAuto">encodeAuto</a></code> (or,
 if you want the raw <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a></code> (from <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html">Data.Serialize</a>) for some reason,
 there's <code><a href="Control-Auto-Core.html#v:saveAuto">saveAuto</a></code>.</p><p>You can &quot;resume&quot; any <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> using <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> (or,
 if you want the raw <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a></code> for some reason, there's <code><a href="Control-Auto-Core.html#v:loadAuto">loadAuto</a></code>).</p><p>Note <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> and <code><a href="Control-Auto-Core.html#v:loadAuto">loadAuto</a></code> &quot;resume&quot; a <em>given <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code></em>.  That is, if
 you call <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> on a &quot;fresh <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;, it'll decode a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code>
 into <em>that <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, but &quot;resumed&quot;</em>.  That is, it'll &quot;fast forward&quot; that
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> into the state it was when it was saved.</p><p>For example, let's say I have <code>a = <code><a href="Control-Auto-Core.html#v:mkAccum">mkAccum</a></code> (+) 0</code>, the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that
 returns the sum of everything it has received so far.  If I feed it
 3 and 10, it'll have its internal accumulator as 13, keeping track of
 all the numbers it has seen so far.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a             = mkAccum (+) 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Output _ a'   = stepAuto' a  3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Output _ a''  = stepAuto' a' 10
</code></strong></pre><p>I can then use <code><a href="Control-Auto-Core.html#v:encodeAuto">encodeAuto</a></code> to &quot;freeze&quot;/&quot;save&quot; the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> into the
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> <code>bs</code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let bs            = encodeAuto a''
</code></strong></pre><p>To &quot;resume&quot; / &quot;load&quot; it, I can use <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> to &quot;resume&quot; the
 <em>original</em> <code>a</code>.  Remember, <code>a</code> was our original <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, the summer
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> with a starting accumulator of 0.  We use <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> to
 &quot;resume&quot; it, with and resume it with its internal accumulator at 13.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Right resumed = decodeAuto a bs
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Output y _    = stepAuto' resumed 0
</code></strong>13
</pre><p>Note that all of these would have had the same result:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Right resumed = decodeAuto a'  bs
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Right resumed = decodeAuto a'' bs
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Right resumed = decodeAuto (mkAccum (+) 0) bs
</code></strong></pre><p>I mean, after all, if <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> &quot;fast forwards&quot; an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> to the
 state it was at when it was frozen...then all of these should really be
 resumed to the same point, right?</p><p>One way you can think about it is that <code><a href="Control-Auto-Core.html#v:loadAuto">loadAuto</a></code> / <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> takes
 an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> and creates a &quot;blueprint&quot; from that <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, on how to &quot;load
 it&quot;; the blueprint contains what the form of the internal state is, and
 their offets in the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code>.  So in the above, <code>a</code>, <code>a'</code>, <code>a''</code>,
 and 'mkAccum (+) 0' all have the same &quot;blueprint&quot; --- their internal
 states are of the same structure.</p><p>Some specific <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s (indicated by a naming convention) might choose to
 have internal state, yet ignore it when saving/loading.  So, saving it
 actaully saves no state, and &quot;resuming&quot; it really doesn't do anything.
 That is, <code><code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> a_ bs = Right a_</code>.  There isn't a real way to
 identify from the type of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> if it will properly save/resume or
 not, so you have to keep track of this yourself.  In all of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>
 &quot;included&quot; in this library, any <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> whose name <em>does not</em> end in <code>_</code>
 <em>will serialize and resume</em>.  An <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> whose name ends in <code>_</code> is taken
 by naming convention to be a non-resuming <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.</p><p>In your own compositions, if you are sure to always use resuming
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s, your composition will also be properly resuming...so you don't
 have to worry about this!  You shouldn't really ever be &quot;surprised&quot;,
 because you'll always explicitly chose the resuming version for <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s
 you want to resume, and the non-resuming version for those you don't.</p><p>TODO: replace &quot;decode&quot; with &quot;resume&quot;.</p></div><div class="top"><p class="src"><a name="v:encodeAuto" class="def">encodeAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Encode an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> and its internal state into a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:decodeAuto" class="def">decodeAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</p><div class="doc"><p><a href="Resume.html">Resume</a> an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from its <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> serialization, giving
 a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> if the deserialization is not possible.</p></div></div><div class="top"><p class="src"><a name="v:saveAuto" class="def">saveAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a></p><div class="doc"><p>Returns a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a></code> --- instructions (from <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html">Data.Serialize</a>) on how to
 &quot;freeze&quot; the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, with its internal state, and save it to a binary
 encoding.  It can later be reloaded and &quot;resumed&quot; by
 'loadAuto'/'decodeAuto'.</p></div></div><div class="top"><p class="src"><a name="v:loadAuto" class="def">loadAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</p><div class="doc"><p>Returns a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a></code> from an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> ---  instructions (from
 <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html">Data.Serialize</a>) on taking a ByteString and &quot;restoring&quot; the originally
 saved <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, in the originally saved state.</p></div></div><h1 id="g:5">Auto output</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Output" class="def">Output</a> m a b</p><div class="doc"><p>The output of a <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code>.  Contains the &quot;result&quot; value of the
 stepping (<code><a href="Control-Auto-Core.html#v:outRes">outRes</a></code>), and the &quot;next <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;, <code><a href="Control-Auto-Core.html#v:outAuto">outAuto</a></code>.</p><p>An <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code> will produce an <code><code><a href="Control-Auto-Core.html#t:Output">Output</a></code> m a b</code>; when &quot;stepped&quot; with
 an <code>a</code>, the &quot;result&quot; (<code><a href="Control-Auto-Core.html#v:outRes">outRes</a></code>) is a <code>b</code>.</p><p>Really, you can just think of this as a fancy tuple.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Output" class="def">Output</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:outRes" class="def">outRes</a> :: b</dt><dd class="doc"><p>Result value of a step</p></dd><dt class="src"><a name="v:outAuto" class="def">outAuto</a> :: <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</dt><dd class="doc"><p>The next <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code></p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Output" class="caption collapser" onclick="toggleSection('i:Output')">Instances</p><div id="section.i:Output" class="show"><table><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> (<a href="Control-Auto-Core.html#t:Output">Output</a> m a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Control-Auto-Core.html#t:Output">Output</a> m a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Floating">Floating</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Floating">Floating</a> (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Fractional">Fractional</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Fractional">Fractional</a> (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/GHC-Generics.html#t:Generic">Generic</a> (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.15.3/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> b) =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.15.3/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/GHC-Generics.html#t:Rep">Rep</a> (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Output-39-" class="def">Output'</a> = <a href="Control-Auto-Core.html#t:Output">Output</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></p><div class="doc"><p>Special case of <code><a href="Control-Auto-Core.html#t:Output">Output</a></code> where the underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> of <code><a href="Control-Auto-Core.html#v:outAuto">outAuto</a></code> is
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/transformers-0.3.0.0/Data-Functor-Identity.html#t:Identity">Identity</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:onOutput" class="def">onOutput</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; b')</td><td class="doc"><p>function over the result</p></td></tr><tr><td class="src">-&gt; (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a' b')</td><td class="doc"><p>function over the resulting <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a' b'</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Map two functions onto both fields of an <code><a href="Control-Auto-Core.html#t:Output">Output</a></code>.</p><p>If you want to map an <code>a -&gt; b</code> onto both fields (the result and the
 result of the next Auto), you can use the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a></code> instance instead.</p></div></div><div class="top"><p class="src"><a name="v:onOutRes" class="def">onOutRes</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; b)</td><td class="doc"><p>function over the result</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Map a function onto the <code><a href="Control-Auto-Core.html#v:outRes">outRes</a></code> of an <code><a href="Control-Auto-Core.html#t:Output">Output</a></code>: the &quot;result&quot; of
 a <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code>.</p><p>Useful for completely pointless and probably obfuscating point free code :D</p></div></div><div class="top"><p class="src"><a name="v:onOutAuto" class="def">onOutAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a' b)</td><td class="doc"><p>function over the resulting <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a' b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Map a function onto the 'outAuto of an <code><a href="Control-Auto-Core.html#t:Output">Output</a></code>, the resulting
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.  See note on <code><a href="Control-Auto-Core.html#v:onOutRes">onOutRes</a></code>.</p></div></div><h1 id="g:6">Auto constructors</h1><h2 id="g:7">Lifting values and functions</h2><div class="top"><p class="src"><a name="v:mkConst" class="def">mkConst</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: b</td><td class="doc"><p>constant value to be outputted</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that always yields the given value, ignoring its
 input.</p><p>Provided for API constency, but you should really be using <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:pure">pure</a></code> from
 the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a></code> instance, from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html">Control.Applicative</a>, which does the
 same thing.</p></div></div><div class="top"><p class="src"><a name="v:mkConstM" class="def">mkConstM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: m b</td><td class="doc"><p>monadic action to be executed at every step</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that always &quot;executes&quot; the given monadic value at
 every step, yielding the result and ignoring its input.</p><p>Provided for API consistency, but you shold really be using <code>effect</code>
 from <a href="Control-Auto-Effects.html">Control.Auto.Effects</a>, which does the same thing.</p></div></div><div class="top"><p class="src"><a name="v:mkFunc" class="def">mkFunc</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; b)</td><td class="doc"><p>pure function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct a stateless <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that simply applies the given (pure)
 function to every input, yielding the output.</p><p>This is rarely needed; you should be using <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#v:arr">arr</a></code> from the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:Arrow">Arrow</a></code>
 instance, from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html">Control.Arrow</a>.</p></div></div><div class="top"><p class="src"><a name="v:mkFuncM" class="def">mkFuncM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; m b)</td><td class="doc"><p>&quot;monadic&quot; function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct a statelss <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that simply applies and executes the givne
 (monadic) function to every input, yielding the output.</p><p>It's recommended that you use <code>arrM</code> from <a href="Control-Auto-Effects.html">Control.Auto.Effects</a>.  This
 is only really provided for consistency.</p></div></div><h2 id="g:8">from State transformers</h2><div class="top"><p class="src"><a name="v:mkState" class="def">mkState</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; s -&gt; (b, s))</td><td class="doc"><p>state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>intial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from a state transformer: an <code>a -&gt; s -&gt; (b, s)</code>
 gives you an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>, for any <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> <code>m</code>.  At every step, it
 takes in the <code>a</code> input, runs the function with the stored internal
 state, returns the <code>b</code> result, and now contains the new resulting state.
 You have to intialize it with an initial state, of course.</p><p>Try not to use this if it's ever avoidable, unless you're a framework
 developer or something.  Try make something by combining/composing the
 various <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> combinators.</p><p>This version is a wrapper around <code><a href="Control-Auto-Core.html#v:mkAuto">mkAuto</a></code>, that keeps track of the
 serialization and re-loading of the internal state for you, so you don't
 have to deal with it explicitly.</p><p>If your state <code>s</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you should
 either write a meaningful one, provide the serialization methods
 manually with <code><a href="Control-Auto-Core.html#v:mkState-39-">mkState'</a></code>, or throw away serializability and use
 <code><a href="Control-Auto-Core.html#v:mkState_">mkState_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mkState_" class="def">mkState_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; s -&gt; (b, s))</td><td class="doc"><p>state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto-Core.html#v:mkState">mkState</a></code>, where the internal state isn't serialized.  It
 can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the process.</p><p>Useful if your state <code>s</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance.</p></div></div><div class="top"><p class="src"><a name="v:mkStateM" class="def">mkStateM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; s -&gt; m (b, s))</td><td class="doc"><p>(monadic) state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from a &quot;monadic&quot; state transformer: <code>a -&gt; s -&gt;
 m (b, s)</code> gives you an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>.  At every step, it takes in the
 <code>a</code> input, runs the function with the stored internal state and
 &quot;executes&quot; the <code>m (b, s)</code> to get the <code>b</code> output, and stores the <code>s</code> as
 the new, updated state.  Must be initialized with an initial state.</p><p>Try not to use this if it's ever avoidable, unless you're a framework
 developer or something.  Try make something by combining/composing the
 various <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> combinators.</p><p>This version is a wrapper around <code><a href="Control-Auto-Core.html#v:mkAuto">mkAuto</a></code>, that keeps track of the
 serialization and re-loading of the internal state for you, so you don't
 have to deal with it explicitly.</p><p>If your state <code>s</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you should
 either write a meaningful one, provide the serialization methods
 manually with <code><a href="Control-Auto-Core.html#v:mkStateM-39-">mkStateM'</a></code>, or throw away serializability and use
 <code><a href="Control-Auto-Core.html#v:mkStateM_">mkStateM_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mkStateM_" class="def">mkStateM_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; s -&gt; m (b, s))</td><td class="doc"><p>(monadic) state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto-Core.html#v:mkStateM">mkStateM</a></code>, where the internal state isn't serialized.
 It can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the process.</p><p>Useful if your state <code>s</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance.</p></div></div><div class="top"><p class="src"><a name="v:mkState-39-" class="def">mkState'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a> s</td><td class="doc"><p><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a></code>; strategy for reading and deserializing the state</p></td></tr><tr><td class="src">-&gt; (s -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a>)</td><td class="doc"><p><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a></code>; strategy for serializing given state</p></td></tr><tr><td class="src">-&gt; (a -&gt; s -&gt; (b, s))</td><td class="doc"><p>state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>intial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto-Core.html#v:mkState">mkState</a></code>, where the internal state doesn't have
 a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, so you provide your own instructions for getting
 and putting the state.</p></div></div><div class="top"><p class="src"><a name="v:mkStateM-39-" class="def">mkStateM'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a> s</td><td class="doc"><p><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a></code>; strategy for reading and deserializing the state</p></td></tr><tr><td class="src">-&gt; (s -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a>)</td><td class="doc"><p><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a></code>; strategy for serializing given state</p></td></tr><tr><td class="src">-&gt; (a -&gt; s -&gt; m (b, s))</td><td class="doc"><p>(monadic) state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto-Core.html#v:mkStateM">mkStateM</a></code>, where the internal state doesn't have
 a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, so you provide your own instructions for getting
 and putting the state.</p></div></div><h2 id="g:9">from Accumulators</h2><h3 id="g:10">Result-first</h3><div class="top"><p class="src"><a name="v:mkAccum" class="def">mkAccum</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from a &quot;folding&quot; function: <code>b -&gt; a -&gt; b</code> yields an
 <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>.  Basically acts like a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-List.html#v:foldl">foldl</a></code> or a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-List.html#v:scanl">scanl</a></code>.  There is
 an internal accumulator that is &quot;updated&quot; with an <code>a</code> at every step.
 Must be given an initial accumulator.</p><p>Example: an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that sums up all of its input.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let summer = mkAccum (+) 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Output sum1 summer' = stepAuto summer 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sum1
</code></strong>3
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Output sum2 _       = stepAuto summer'' 10
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sum2
</code></strong>13
</pre><p>If your accumulator <code>b</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you
 should either write a meaningful one, or throw away serializability and
 use <code><a href="Control-Auto-Core.html#v:mkAccum_">mkAccum_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mkAccum_" class="def">mkAccum_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>intial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of 'mkAccum_, where the internal accumulator isn't
 serialized. It can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the
 process.</p><p>Useful if your accumulator <code>b</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code>
 instance.</p></div></div><div class="top"><p class="src"><a name="v:mkAccumM" class="def">mkAccumM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from a &quot;monadic&quot; &quot;folding&quot; function: <code>b -&gt; a -&gt;
 m b</code> yields an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>.  Basically acts like a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:foldM">foldM</a></code> or <code>scanM</code>
 (if it existed).  here is an internal accumulator that is &quot;updated&quot; with
 an input <code>a</code> with the result of the executed <code>m b</code> at every step.  Must
 be given an initial accumulator.</p><p>If your accumulator <code>b</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you
 should either write a meaningful one, or throw away serializability and
 use <code><a href="Control-Auto-Core.html#v:mkAccumM_">mkAccumM_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mkAccumM_" class="def">mkAccumM_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of 'mkAccumM_, where the internal accumulator isn't
 serialized. It can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the
 process.</p><p>Useful if your accumulator <code>b</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code>
 instance.</p></div></div><h3 id="g:11">Initial accumulator-first</h3><div class="top"><p class="src"><a name="v:mkAccumD" class="def">mkAccumD</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A &quot;delayed&quot; version of <code><a href="Control-Auto-Core.html#v:mkAccum">mkAccum</a></code>, where the first output is actually
 the initial state of the accumulator.  Useful in recursive bindings.</p></div></div><div class="top"><p class="src"><a name="v:mkAccumD_" class="def">mkAccumD_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>intial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto-Core.html#v:mkAccumD">mkAccumD</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mkAccumMD" class="def">mkAccumMD</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A &quot;delayed&quot; version of <code><a href="Control-Auto-Core.html#v:mkAccumM">mkAccumM</a></code>, where the first output is actually
 the initial state of the accumulator.  Useful in recursive bindings.</p></div></div><div class="top"><p class="src"><a name="v:mkAccumMD_" class="def">mkAccumMD_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto-Core.html#v:mkAccumMD">mkAccumMD</a></code>.</p></div></div><h2 id="g:12">Arbitrary Autos</h2><div class="top"><p class="src"><a name="v:mkAuto" class="def">mkAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>resuming/loading <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a></code></p></td></tr><tr><td class="src">-&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a></td><td class="doc"><p>saving <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a></code></p></td></tr><tr><td class="src">-&gt; (a -&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</td><td class="doc"><p>step function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> by explicity giving its serialization,
 deserialization, and the (pure) function from <code>a</code> to <code>b</code> and the &quot;next
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;.</p><p>Ideally, you wouldn't have to use this unless you are making your own
 framework.  Try your best to make what you want by assembling
 primtives together.</p></div></div><div class="top"><p class="src"><a name="v:mkAuto_" class="def">mkAuto_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; <a href="Control-Auto-Core.html#t:Output">Output</a> m a b)</td><td class="doc"><p>step function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto-Core.html#v:mkAuto">mkAuto</a></code>, but without any way of meaningful serializing or
 deserializing.</p><p>Be careful!  This <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> can still carry arbitrary internal state, but
 it cannot be meaningfully serialized or re-loaded/resumed.  You can
 still pretend to do so using
 'loadAuto'/'saveAuto'/'encodeAuto'/'decodeAuto' (and the type system
 won't stop you), but when you try to &quot;resume&quot;/decode it, its state will
 be lost.</p></div></div><div class="top"><p class="src"><a name="v:mkAutoM" class="def">mkAutoM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>resuming/loading <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Get.html#t:Get">Get</a></code></p></td></tr><tr><td class="src">-&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a></td><td class="doc"><p>saving <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.0.1/html/Data-Serialize-Put.html#t:Put">Put</a></code></p></td></tr><tr><td class="src">-&gt; (a -&gt; m (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b))</td><td class="doc"><p>(monadic) step function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> by explicitly giving its serializiation,
 deserialization, and the (monadic) function from <code>a</code> to <code>b</code> and the
 &quot;next <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;.</p><p>Ideally, you wouldn't have to use this unless you are making your own
 framework.  Try your best to make what you want by assembling
 primtives together.</p></div></div><div class="top"><p class="src"><a name="v:mkAutoM_" class="def">mkAutoM_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; m (<a href="Control-Auto-Core.html#t:Output">Output</a> m a b))</td><td class="doc"><p>(monadic) step function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto-Core.html#v:mkAutoM">mkAutoM</a></code>, but without any way of meaningful serializing or
 deserializing.</p><p>Be careful!  This <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> can still carry arbitrary internal state, but
 it cannot be meaningfully serialized or re-loaded/resumed.  You can
 still pretend to do so using
 'loadAuto'/'saveAuto'/'encodeAuto'/'decodeAuto' (and the type system
 won't stop you), but when you try to &quot;resume&quot;/decode it, its state will
 be reset.</p></div></div><h1 id="g:13">Strictness</h1><div class="top"><p class="src"><a name="v:forceSerial" class="def">forceSerial</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Force the serializing components of an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:forcer" class="def">forcer</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/deepseq-1.3.0.2/Control-DeepSeq.html#t:NFData">NFData</a> a =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a a</p><div class="doc"><p>A special <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that acts like the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#v:id">id</a></code> <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, but forces results as
 they come through to be fully evaluated, when composed with other
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s.</p></div></div><div class="top"><p class="src"><a name="v:seqer" class="def">seqer</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a a</p><div class="doc"><p>A special <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that acts like the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#v:id">id</a></code> <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, but forces results as
 they come through to be evaluated to Weak Head Normal Form, with <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:seq">seq</a></code>,
 when composed with other <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>