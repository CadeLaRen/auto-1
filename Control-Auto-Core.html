<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Auto.Core</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Auto-Core.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">auto-0.2.0.6: Denotative, locally stateful programming DSL &amp; platform</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Justin Le 2015</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>justin@jle.im</td></tr><tr><th>Stability</th><td>unstable</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Auto.Core</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Auto</a><ul><li><a href="#g:2">Type</a></li><li><a href="#g:3">Running</a></li><li><a href="#g:4">Serializing</a></li><li><a href="#g:5">Underlying monad</a></li><li><a href="#g:6">Special modifiers</a></li></ul></li><li><a href="#g:7">Auto constructors</a><ul><li><a href="#g:8">Lifting values and functions</a></li><li><a href="#g:9">from State transformers</a></li><li><a href="#g:10">from Accumulators</a><ul><li><a href="#g:11">Result-first</a></li><li><a href="#g:12">Initial accumulator-first</a></li></ul></li><li><a href="#g:13">Arbitrary Autos</a></li></ul></li><li><a href="#g:14">Strictness</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module defines and provides the core types, (smart) constructors,
 and general high and low-level utilities used by the <em>auto</em> library.</p><p>A lot of low-level functionality is provided here which is most likely
 unnecessary for most applications; many are mostly for internal usage or
 advanced/fine-grained usage.  It also isn't really enough to do too many
 useful things, either.  It's recommended that you import <a href="Control-Auto.html">Control.Auto</a>
 instead, which re-organizes the more useful parts of this module in
 addition with useful parts of others to provide a nice packaged entry
 point.  If something in here becomes useful for more than just
 fine-tuning or low-level tweaking, it is probably supposed to be in
 <a href="Control-Auto.html">Control.Auto</a> anyway.</p><p>Information on how to use these types is available in the
 <a href="https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md">tutorial</a>!</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Auto">Auto</a> m a b</li><li class="src short"><span class="keyword">type</span> <a href="#t:Auto-39-">Auto'</a> = <a href="Control-Auto-Core.html#t:Auto">Auto</a> <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></li><li class="src short"><a href="#v:autoConstr">autoConstr</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:toArb">toArb</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:purifyAuto">purifyAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b -&gt; <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b</li><li class="src short"><a href="#v:stepAuto">stepAuto</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; a -&gt; m (b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</li><li class="src short"><a href="#v:stepAuto-39-">stepAuto'</a> ::  <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b -&gt; a -&gt; (b, <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b)</li><li class="src short"><a href="#v:evalAuto">evalAuto</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; a -&gt; m b</li><li class="src short"><a href="#v:evalAuto-39-">evalAuto'</a> ::  <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b -&gt; a -&gt; b</li><li class="src short"><a href="#v:execAuto">execAuto</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; a -&gt; m (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</li><li class="src short"><a href="#v:execAuto-39-">execAuto'</a> ::  <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b -&gt; a -&gt; <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b</li><li class="src short"><a href="#v:encodeAuto">encodeAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:decodeAuto">decodeAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</li><li class="src short"><a href="#v:saveAuto">saveAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a></li><li class="src short"><a href="#v:resumeAuto">resumeAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</li><li class="src short"><a href="#v:unserialize">unserialize</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:hoistA">hoistA</a> :: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m') =&gt; (<span class="keyword">forall</span> c. m c -&gt; m' c) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m' a b</li><li class="src short"><a href="#v:generalizeA">generalizeA</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:interceptO">interceptO</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; ((b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b) -&gt; m c) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a c</li><li class="src short"><a href="#v:mkConst">mkConst</a> ::  b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkConstM">mkConstM</a> ::  m b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkFunc">mkFunc</a> ::  (a -&gt; b) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkFuncM">mkFuncM</a> ::  (a -&gt; m b) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkState">mkState</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s =&gt; (a -&gt; s -&gt; (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkState_">mkState_</a> ::  (a -&gt; s -&gt; (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkStateM">mkStateM</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s =&gt; (a -&gt; s -&gt; m (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkStateM_">mkStateM_</a> ::  (a -&gt; s -&gt; m (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkState-39-">mkState'</a> ::  <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a> s -&gt; (s -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a>) -&gt; (a -&gt; s -&gt; (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkStateM-39-">mkStateM'</a> ::  <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a> s -&gt; (s -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a>) -&gt; (a -&gt; s -&gt; m (b, s)) -&gt; s -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accum">accum</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accum_">accum_</a> ::  (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumM">accumM</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumM_">accumM_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumD">accumD</a> :: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumD_">accumD_</a> ::  (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumMD">accumMD</a> :: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:accumMD_">accumMD_</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAuto">mkAuto</a> ::  <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b) -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a> -&gt; (a -&gt; (b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAuto_">mkAuto_</a> ::  (a -&gt; (b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAutoM">mkAutoM</a> ::  <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b) -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a> -&gt; (a -&gt; m (b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:mkAutoM_">mkAutoM_</a> ::  (a -&gt; m (b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)) -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:forceSerial">forceSerial</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</li><li class="src short"><a href="#v:forcer">forcer</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/deepseq-1.3.0.2/Control-DeepSeq.html#t:NFData">NFData</a> a =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a a</li><li class="src short"><a href="#v:seqer">seqer</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a a</li></ul></div><div id="interface"><h1 id="g:1">Auto</h1><h2 id="g:2">Type</h2><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Auto" class="def">Auto</a> m a b</p><div class="doc"><p>The <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> type.  For this library, an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> semantically
 represents<em>denotes a </em>a relationship/ between an input and an
 output that is preserved over multiple steps, where that relationship is
 (optionally) maintained within the context of a monad.</p><p>A lot of fancy words, I know...but you can think of an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> as nothing
 more than a &quot;stream transformer&quot;.  A stream of sequential inputs come in
 one at a time, and a stream of outputs pop out one at a time, as well.</p><p>Using the <code>streamAuto</code> function, you can &quot;unwrap&quot; the inner stream
 transformer from any <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>: if <code>a :: <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>, <code>streamAuto</code> lets
 you turn it into an <code>[a] -&gt; m [b]</code>.  &quot;Give me a stream of <code>a</code>s, one at
 a time, and I'll give you a list of <code>b</code>s, matching a relationship to
 your stream of <code>a</code>s.&quot;</p><pre>-- unwrap your inner [a] -&gt; m [b]!
<code>streamAuto</code> :: Monad m =&gt; <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b -&gt; ([a] -&gt; m [b])
</pre><p>There's a handy type synonym <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> for relationships that don't really
 need a monadic context; the <code>m</code> is just <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></code>:</p><pre>type Auto' = Auto Identity
</pre><p>So if you had an <code>a :: <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a b</code>, you can use <code>streamAuto'</code> to
 &quot;unwrap&quot; the inner stream transformer, <code>[a] -&gt; [b]</code>.</p><pre>-- unwrap your inner [a] -&gt; [b]!
<code>streamAuto'</code> :: <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a b -&gt; ([a] -&gt; [b])
</pre><p>All of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s given in this library maintain some sort of semantic
 relationship between streams --- for some, the outputs might be the
 inputs with a function applied; for others, the outputs might be the
 cumulative sum of the inputs.</p><p>See the
 <a href="https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md">tutorial</a>
 for more information!</p><p>Operationally, an  <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code> is implemented as a &quot;stateful
 function&quot;.  A function from an <code>a</code> where, every time you &quot;apply&quot; it, you
 get a <code>b</code> and an &quot;updated <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;/function with updated state.</p><p>You can get this function using <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code>:</p><pre><code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code> :: <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b -&gt; (a -&gt; m (b, <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b))
</pre><p>Or, for <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>, <code><a href="Control-Auto-Core.html#v:stepAuto-39-">stepAuto'</a></code>:</p><pre><code><a href="Control-Auto-Core.html#v:stepAuto-39-">stepAuto'</a></code> :: <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a b -&gt; (a -&gt; (b, <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a b))
</pre><p>&quot;Give me an <code>a</code> and I'll give you a <code>b</code> and your &quot;updated&quot; <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;.</p><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s really are mostly useful because they can be composed, chained,
 and modified using their various typeclass instances, like <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#t:Category">Category</a></code>,
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a></code>, <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a></code>, <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:Arrow">Arrow</a></code>, etc., and also with the combinators
 in this library.  You can build complex programs as a complex <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> by
 building up smaller and smaller components.  See the tutorial for more
 information on this.</p><p>This type also contains information on its own serialization, so you can
 serialize and re-load the internal state to binary or disk.  See the
 &quot;serialization&quot; section in the documentation for <a href="Control-Auto-Core.html">Control.Auto.Core</a>, or
 the documentation for <code><a href="Control-Auto-Core.html#v:mkAutoM">mkAutoM</a></code> for more details.</p></div><div class="subs instances"><p id="control.i:Auto" class="caption collapser" onclick="toggleSection('i:Auto')">Instances</p><div id="section.i:Auto" class="show"><table><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#t:Category">Category</a> * (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc"><p>Gives the ability to &quot;compose&quot; two <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s; feeds the input stream
 into the first, feeds that output stream into the second, and returns as
 a result the output stream of the second.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:Arrow">Arrow</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc"><p>Gives us <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#v:arr">arr</a></code>, which is a &quot;stateless&quot; <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that behaves just like
 a function; its outputs are the function applied the corresponding
 inputs.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (arr negate) [1..10]
</code></strong>[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
</pre><p>Also allows you to have an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> run on only the &quot;first&quot; or &quot;second&quot;
 field in an input stream that is tuples...and also allows <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s to run
 side-by-side on an input stream of tuples (run each on either tuple
 field).</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [4,6,8,7]
</code></strong>[4,10,18,25]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (first (sumFrom 0)) [(4,True),(6,False),(8,False),(7,True)]
</code></strong>[(4,True),(10,False),(18,False),(25,True)]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (productFrom 1) [1,3,5,2]
</code></strong>[1,3,15,30]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0 *** productFrom 1) [(4,1),(6,3),(8,5),(7,2)]
</code></strong>[(4,1),(10,3),(18,15),(25,30)]
</pre><p>Most importantly, however, allows for &quot;proc&quot; notation; see the
 <a href="https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md">tutorial</a>!
 for more details.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:ArrowChoice">ArrowChoice</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc"><p>Allows you to have an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> only act on &quot;some&quot; inputs (only on
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code>s, for example), and be &quot;paused&quot; otherwise.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [1,4,2,5]
</code></strong>[1,5,7,12]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (left (sumFrom 0)) [Left 1, Right 'a', Left 4, Left 2, Right 'b', Left 5]
</code></strong>[Left 1, Right 'a', Left 5, Left 6, Right 'b', Left 12]
</pre><p>Again mostly useful for &quot;proc&quot; notation, with branching.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad-Fix.html#t:MonadFix">MonadFix</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:ArrowLoop">ArrowLoop</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc"><p>Finds the fixed point of self-referential <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s (for example,
 feeding the output stream of an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> to itself).  Mostly used with
 proc notation to allow recursive bindings.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor.html#t:Strong">Strong</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc"><p>See <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:Arrow">Arrow</a></code> instance.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor.html#t:Choice">Choice</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc"><p>See <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:ArrowChoice">ArrowChoice</a></code> instance</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad-Fix.html#t:MonadFix">MonadFix</a> m =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor.html#t:Costrong">Costrong</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc"><p>See <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:ArrowLoop">ArrowLoop</a></code> instance</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#t:Profunctor">Profunctor</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m)</td><td class="doc"><p><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#v:lmap">lmap</a></code> lets you map over the <em>input</em> stream, and <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#v:rmap">rmap</a></code> lets you map
 over the <em>output</em> stream.  Note that, as with all <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#t:Profunctor">Profunctor</a></code>s, <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/profunctors-4.4.1/html/Data-Profunctor-Unsafe.html#v:rmap">rmap</a></code>
 is <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:fmap">fmap</a></code>.</p></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a> m) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a)</td><td class="doc"><p>When the underlying 'Monad'/'Applicative' <code>m</code> is an <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a></code>,
 fork the input through each one and &quot;squish&quot; their results together
 inside the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a></code> context.  Somewhat rarely used, because who
 uses an <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a></code> <code>m</code>?</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto (arrM (mfilter even . Just)) [1..10]
</code></strong>Nothing
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto (arrM (Just . negate)) [1..10]
</code></strong>Just [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto (arrM (mfilter even . Just)) &lt;|&gt; arrM (Just . negate)) [1..10]
</code></strong>Just [-1,2,-3,4,-5,6,-7,8,-9,10]
</pre></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a)</td><td class="doc"><p>Maps over the output stream of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [1..10]
</code></strong>[1,3,6,10,15,21,28,36,45,55]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (show &lt;$&gt; sumFrom 0) [1..10]
</code></strong>[&quot;1&quot;,&quot;3&quot;,&quot;6&quot;,&quot;10&quot;,&quot;15&quot;,&quot;21&quot;,&quot;28&quot;,&quot;36&quot;,&quot;45&quot;,&quot;55&quot;]
</pre></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a)</td><td class="doc"><p><code><a href="Control-Auto-Generate.html#v:pure">pure</a></code> creates the &quot;constant&quot; <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (pure &quot;foo&quot;) [1..5]
</code></strong>[&quot;foo&quot;,&quot;foo&quot;,&quot;foo&quot;,&quot;foo&quot;,&quot;foo&quot;]
</pre><p><code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> and <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:liftA2">liftA2</a></code> etc. give you the ability to fork the input stream
 over many <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s, and recombine the results:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [1..10]
</code></strong>[ 1, 3,  6, 10,  15]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (productFrom 1) [1..10]
</code></strong>[ 1, 2,  6, 24, 120]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (liftA2 (+) (sumFrom 0) (productFrom 1)) [1..5]
</code></strong>[ 2, 5, 12, 34, 135]
</pre><p>For effectful <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, you can imagine <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:-42--62-">*&gt;</a></code> as &quot;forking&quot; the input stream
 through both, and only keeping the result of the second:</p><pre><code>effect</code> <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#v:print">print</a></code> *&gt; <code>sumFrom</code> 0
</pre><p>would, for example, behave just like <code><code>sumFrom</code> 0</code>, except printing the
 input to <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#t:IO">IO</a></code> at every step.</p></td></tr><tr><td class="src"><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Typeable-Internal.html#t:Typeable">Typeable</a> ((* -&gt; *) -&gt; * -&gt; * -&gt; *) <a href="Control-Auto-Core.html#t:Auto">Auto</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Floating">Floating</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Floating">Floating</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>A bunch of constant producers, mappers-of-output-streams, and
 forks-and-recombiners.</p></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Fractional">Fractional</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Fractional">Fractional</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>Fork the input stream and divide the outputs.  <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:recip">recip</a></code> maps <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:recip">recip</a></code> to
 the output stream; <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:fromRational">fromRational</a></code> will be a constant stream of that
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Rational">Rational</a></code>, so you can write <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s using numerical literals in code;
 see <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a></code> instance.</p></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>Fork the input stream and add, multiply, etc. the outputs.  <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:negate">negate</a></code>
 will negate the ouptput stream.  <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:fromInteger">fromInteger</a></code> will be a constant stream
 of that <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Integer">Integer</a></code>, so you can write <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s using numerical literals in
 code:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (sumFrom 0) [1..10]
</code></strong>[1,3,6,10,15,21,28,36,45,55]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (4 + sumFrom 0) [1..10]
</code></strong>[5,7,10,14,19,25,32,40,49,59]
</pre></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:IsString">IsString</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:IsString">IsString</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>String literals in code will be <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s that constanty produce that
 string.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 6 . streamAuto' (onFor 2 . &quot;hello&quot; --&gt; &quot;world&quot;) $ repeat ()
</code></strong>[&quot;hello&quot;,&quot;hello&quot;,&quot;world&quot;,&quot;world&quot;,&quot;world&quot;,&quot;world&quot;]
</pre></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> b) =&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>Fork the input stream and mappend the outputs.  <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#v:mempty">mempty</a></code> is a constant
 stream of <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#v:mempty">mempty</a></code>s, ignoring its input.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto' (mconcat [arr (take 3), accum (++) &quot;&quot;]) [&quot;hello&quot;,&quot;world&quot;,&quot;good&quot;,&quot;bye&quot;]
</code></strong>[&quot;helhello&quot;,&quot;worhelloworld&quot;,&quot;goohelloworldgood&quot;,&quot;byehelloworldgoodbye&quot;]
</pre></td></tr><tr><td class="src">(<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> b) =&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#t:Semigroup">Semigroup</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>Fork the input stream and <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/semigroups-0.16.2.2/html/Data-Semigroup.html#v:-60--62-">&lt;&gt;</a></code> the outputs.  See the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a></code>
 instance.</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Auto-39-" class="def">Auto'</a> = <a href="Control-Auto-Core.html#t:Auto">Auto</a> <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></p><div class="doc"><p>Special case of <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> where the underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> is <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></code>.</p><p>Instead of &quot;wrapping&quot; an <code>[a] -&gt; m [b]</code>, it &quot;wraps&quot; an <code>[a] -&gt; [b]</code>.</p></div></div><div class="top"><p class="src"><a name="v:autoConstr" class="def">autoConstr</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></p><div class="doc"><p>Returns a string representation of the internal constructor of the
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.  Useful for debugging the result of compositions and functions
 and seeing how they affect the internal structure of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.</p><p>In the order of efficiency, <a href="AutoFunc.html">AutoFunc</a>s tend to be faster than
 <a href="AutoState.html">AutoState</a>s tend to be faster than <a href="AutoArb.html">AutoArb</a>s.  However, when composing
 one with the other (using <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#t:Category">Category</a></code> or <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a></code>), the two have to
 be &quot;reduced&quot; to the greatest common denominator; composing an <a href="AutoFunc.html">AutoFunc</a>
 with an <a href="AutoArb.html">AutoArb</a> produces an <a href="AutoArb.html">AutoArb</a>.</p><p>More benchmarking is to be done to be able to rigorously say what these
 really mean, performance wise.</p></div></div><div class="top"><p class="src"><a name="v:toArb" class="def">toArb</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Re-structure <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> internals to use the <code>Arb</code> (&quot;arbitrary&quot;)
 constructors, as recursion-based mealy machines.</p><p>Almost always a bad idea in every conceivable situation.  Why is it even
 here?</p><p>I'm sorry.</p></div></div><div class="top"><p class="src"><a name="v:purifyAuto" class="def">purifyAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b -&gt; <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b</p><div class="doc"><p>In theory, &quot;purifying&quot; an <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>&quot; should prep it for faster
 evaluation when used with <code><a href="Control-Auto-Core.html#v:stepAuto-39-">stepAuto'</a></code> or <code>streamAuto'</code>.  But the
 benchmarks have not been run yet, so stay tuned!</p><p>TODO: Benchmark</p></div></div><h2 id="g:3">Running</h2><div class="top"><p class="src"><a name="v:stepAuto" class="def">stepAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc"><p>the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> to step</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>the input</p></td></tr><tr><td class="src">-&gt; m (b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>the output, and the updated <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>.</p></td></tr></table></div><div class="doc"><p><a href="Runs.html">Runs</a> the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> through one step.</p><p>That is, given an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>, returns a function that takes an <code>a</code>
 and returns a <code>b</code> and an &quot;updated&quot;/&quot;next&quot; <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>; an <code>a -&gt; m (b, <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>
 m a b)</code>.</p><p>This is the main way of running an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> &quot;step by step&quot;, so if you have
 some sort of game loop that updates everything every &quot;tick&quot;, this is
 what you're looking for.  At every loop, gather input <code>a</code>, feed it into
 the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, &quot;render&quot; the result <code>b</code>, and get your new <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> to run the
 next time.</p><p>Here is an example with <code><code>sumFrom</code> 0</code>, the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> whose output is the
 cumulative sum of the inputs, and an underying monad of <code>Identity</code>.
 Here,</p><pre>stepAuto :: Auto Identity Int Int
         -&gt; (Int -&gt; Identity (Int, Auto Identity Int Int))
</pre><p>Every time you &quot;step&quot;, you give it an <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></code> and get a resulting <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></code>
 (the cumulative sum) and the &quot;updated <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;, with the updated
 accumulator.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a0 :: Auto Identity Int Int
</code></strong>        a0 = sumFrom 0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Identity (res1, a1) = stepAuto a0 4      -- run with 4
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res1
</code></strong>4                -- the cumulative sum, 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Identity (res2, a2) = stepAuto a1 5      -- run with 5
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res2
</code></strong>9                -- the cumulative sum, 4 + 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let Identity (res3, _ ) = stepAuto a2 3      -- run with 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res3
</code></strong>12               -- the cumulative sum, 4 + 5 + 3
</pre><p>By the way, for the case where your <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> is under <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></code>, we have
 a type synomym <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>...and a convenience function to make &quot;running&quot; it
 more streamlined:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a0 :: Auto' Int Int
</code></strong>        a0 = sumFrom 0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res1, a1) = stepAuto' a0 4          -- run with 4
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res1
</code></strong>4                -- the cumulative sum, 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res2, a2) = stepAuto' a1 5          -- run with 5
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res2
</code></strong>9                -- the cumulative sum, 4 + 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res3, _ ) = stepAuto' a2 3          -- run with 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res3
</code></strong>12               -- the cumulative sum, 4 + 5 + 3
</pre><p>But, if your <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> actaully has effects when being stepped, <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code>
 will execute them:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a0 :: Auto IO Int Int
</code></strong>        a0 = effect (putStrLn &quot;hey!&quot;) *&gt; sumFrom 0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(res1, a1) &lt;- stepAuto a0 4              -- run with 4
</code></strong>hey!         -- IO effect
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res1
</code></strong>4                -- the cumulative sum, 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(res2, a2) &lt;- stepAuto a1 5              -- run with 5
</code></strong>hey!         -- IO effect
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res2
</code></strong>9                -- the cumulative sum, 4 + 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(res3, _ ) &lt;- stepAuto a2 3              -- run with 3
</code></strong>hey!         -- IO effect
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res3
</code></strong>12               -- the cumulative sum, 4 + 5 + 3
</pre><p>(Here, <code><code>effect</code> (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#v:putStrLn">putStrLn</a></code> &quot;hey&quot;)</code> is an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> IO Int ()</code>, which
 ignores its input and just executes <code><code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/System-IO.html#v:putStrLn">putStrLn</a></code> &quot;hey&quot;</code> every time it is
 run.  When we use <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:-42--62-">*&gt;</a></code> from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html">Control.Applicative</a>, we &quot;combine&quot; the two
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s together and run them <em>both</em> on each input (4, 5, 3...)...but
 for the &quot;final&quot; output at the end, we only return the output of the
 second one, <code><code>sumFrom</code> 0</code> (5, 9, 12...))</p><p>If you think of an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code> as a &quot;stateful function&quot; <code>a -&gt; m b</code>,
 then <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code> lets you &quot;run&quot; it.</p><p>In order to directly run an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> on a stream, an <code>[a]</code>, use
 <code>streamAuto</code>.  That gives you an <code>[a] -&gt; m [b]</code>.</p></div></div><div class="top"><p class="src"><a name="v:stepAuto-39-" class="def">stepAuto'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b</td><td class="doc"><p>the <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> to step</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>the input</p></td></tr><tr><td class="src">-&gt; (b, <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b)</td><td class="doc"><p>the output, and the updated <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code></p></td></tr></table></div><div class="doc"><p><a href="Runs.html">Runs</a> an <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> through one step.</p><p>That is, given an <code><code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a b</code>, returns a function that takes an <code>a</code>
 and returns a <code>b</code> and an &quot;updated&quot;/&quot;next&quot; <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>; an <code>a -&gt; (b, <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>
 a b)</code>.</p><p>See <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code> documentation for motivations, use cases, and more
 details.  You can use this instead of <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code> when your underyling
 monad is <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/transformers-0.4.3.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></code>, and your <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> doesn't produce any effects.</p><p>Here is an example with <code><code>sumFrom</code> 0</code>, the <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> whose output is the
 cumulative sum of the inputs</p><pre>stepAuto' :: Auto' Int Int
          -&gt; (Int -&gt; (Int, Auto' Int Int))
</pre><p>Every time you &quot;step&quot;, you give it an <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></code> and get a resulting <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></code>
 (the cumulative sum) and the &quot;updated <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>&quot;, with the updated
 accumulator.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a0 :: Auto' Int Int
</code></strong>        a0 = sumFrom 0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res1, a1) = stepAuto' a0 4          -- run with 4
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res1
</code></strong>4                -- the cumulative sum, 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res2, a2) = stepAuto' a1 5          -- run with 5
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res2
</code></strong>9                -- the cumulative sum, 4 + 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (res3, _ ) = stepAuto' a2 3          -- run with 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>res3
</code></strong>12               -- the cumulative sum, 4 + 5 + 3
</pre><p>If you think of an <code><code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a b</code> as a &quot;stateful function&quot; <code>a -&gt; b</code>,
 then <code><a href="Control-Auto-Core.html#v:stepAuto-39-">stepAuto'</a></code> lets you &quot;run&quot; it.</p><p>In order to directly run an <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> on a stream, an <code>[a]</code>, use
 <code>streamAuto'</code>.  That gives you an <code>[a] -&gt; [b]</code>.</p></div></div><div class="top"><p class="src"><a name="v:evalAuto" class="def">evalAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> to run</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>input</p></td></tr><tr><td class="src">-&gt; m b</td><td class="doc"><p>output</p></td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code>, but drops the &quot;next <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot; and just gives the
 result.</p></div></div><div class="top"><p class="src"><a name="v:evalAuto-39-" class="def">evalAuto'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> to run</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>input</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>output</p></td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto-Core.html#v:stepAuto-39-">stepAuto'</a></code>, but drops the &quot;next <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>&quot; and just gives the
 result.  <code><a href="Control-Auto-Core.html#v:evalAuto">evalAuto</a></code> for <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:execAuto" class="def">execAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> to run</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>input</p></td></tr><tr><td class="src">-&gt; m (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>updated <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code></p></td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto-Core.html#v:stepAuto">stepAuto</a></code>, but drops the result and just gives the &quot;updated
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;.</p></div></div><div class="top"><p class="src"><a name="v:execAuto-39-" class="def">execAuto'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b</td><td class="doc"><p><code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> to run</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>input</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b</td><td class="doc"><p>updated <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code></p></td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto-Core.html#v:stepAuto-39-">stepAuto'</a></code>, but drops the result and just gives the &quot;updated
 <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>&quot;.  <code><a href="Control-Auto-Core.html#v:execAuto">execAuto</a></code> for <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>.</p></div></div><h2 id="g:4">Serializing</h2><div class="doc"><p>The <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> type offers an interface in which you can serialize
 (&quot;freeze&quot;) and &quot;resume&quot; an Auto, in <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> (binary) form.</p><p>You can &quot;freeze&quot; any <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> into a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> using <code><a href="Control-Auto-Core.html#v:encodeAuto">encodeAuto</a></code> (or,
 if you want the raw <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a></code> (from <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html">Data.Serialize</a>) for some reason,
 there's <code><a href="Control-Auto-Core.html#v:saveAuto">saveAuto</a></code>.</p><p>You can &quot;resume&quot; any <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> using <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> (or,
 if you want the raw <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a></code> for some reason, there's <code><a href="Control-Auto-Core.html#v:resumeAuto">resumeAuto</a></code>).</p><p>Note <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> and <code><a href="Control-Auto-Core.html#v:resumeAuto">resumeAuto</a></code> &quot;resume&quot; a <em>given <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code></em>.  That is,
 if you call <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> on a &quot;fresh <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;, it'll decode
 a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> into <em>that <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, but &quot;resumed&quot;</em>.  That is, it'll &quot;fast
 forward&quot; that <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> into the state it was when it was saved.</p><p>For example, let's say I have <code>a = <code>sumFrom</code> 0</code>, the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> whose output
 is the cumulative sum of all of its inputs so far. If I feed it 3 and
 10, it'll have its internal accumulator as 13, keeping track of all the
 numbers it has seen so far.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let a = sumFrom 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (_, a' ) = stepAuto' a  3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (_, a'') = stepAuto' a' 10
</code></strong></pre><p>I can then use <code><a href="Control-Auto-Core.html#v:encodeAuto">encodeAuto</a></code> to &quot;freeze&quot;/&quot;save&quot; the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> into the
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> <code>bs</code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let bs            = encodeAuto a''
</code></strong></pre><p>To &quot;resume&quot; / &quot;load&quot; it, I can use <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> to &quot;resume&quot; the
 <em>original</em> <code>a</code>.  Remember, <code>a</code> was our original <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, the summer
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> with a starting accumulator of 0.  We use <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> to
 &quot;resume&quot; it, with and resume it with its internal accumulator at 13.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (Right resumed) = decodeAuto a bs
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (y, _) = stepAuto' resumed 0
</code></strong>13
</pre><p>Note that all of these would have had the same result:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (Right resumed) = decodeAuto a'  bs
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (Right resumed) = decodeAuto a'' bs
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (Right resumed) = decodeAuto (sumFrom 0) bs
</code></strong></pre><p>I mean, after all, if <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> &quot;fast forwards&quot; an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> to the
 state it was at when it was frozen...then all of these should really be
 resumed to the same point, right?</p><p>One way you can think about it is that <code><a href="Control-Auto-Core.html#v:resumeAuto">resumeAuto</a></code> / <code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> takes
 an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> and creates a &quot;blueprint&quot; from that <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, on how to &quot;load
 it&quot;; the blueprint contains what the form of the internal state is, and
 their offets in the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code>.  So in the above, <code>a</code>, <code>a'</code>, <code>a''</code>,
 and <code><code>sumFrom</code> 0</code> all have the same &quot;blueprint&quot; --- their internal
 states are of the same structure.</p><p>Now, the <em>magic</em> of this all is that combining and transforming <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s
 with the combinators in this library will also /compose serialization
 strategies<em> .... complex <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s and combinations</em>chains of <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s
 create serialization strategies &quot;for free&quot;.  The
 <a href="https://github.com/mstksg/auto-examples">auto-examples</a> repo has a lot
 of examples that use this  to great effect, serializing entire
 applications and entire chat bots without writing any serialization
 code; it all does it &quot;by itself&quot;.  Be sure to read about the caveats in
 the
 <a href="https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md">tutorial</a>.</p><p>Some specific <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s (indicated by a naming convention) might choose to
 have internal state, yet ignore it when saving/loading.  So, saving it
 actaully saves no state, and &quot;resuming&quot; it really doesn't do anything.
 That is, <code><code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> a_ bs = Right a_</code>.  There isn't a real way to
 identify from the type of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> if it will properly save/resume or
 not, so you have to keep track of this yourself.  In all of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>
 &quot;included&quot; in this library, any <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> whose name <em>does not</em> end in <code>_</code>
 <em>will serialize and resume</em>.  An <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> whose name ends in <code>_</code> is taken
 by naming convention to be a non-resuming <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.</p><p>In your own compositions, if you are sure to always use resuming
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s, your composition will also be properly resuming...so you don't
 have to worry about this!  You shouldn't really ever be &quot;surprised&quot;,
 because you'll always explicitly chose the resuming version for <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s
 you want to resume, and the non-resuming version for those you don't.</p><p>Now, <em>making</em> or <em>writing</em> your own generic <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> combinators and
 transformers that take advantage of serialization is a bit of
 a headache.  When you can, you might be able to make combinators out of
 the existing functions in this library.  Sometimes, however, it's
 unavoidable.  If you are making your own <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> combinators, making sure
 serialization works as expected is tough; check out the documentation
 for <code><a href="Control-Auto-Core.html#v:mkAutoM">mkAutoM</a></code> for more details.</p></div><div class="top"><p class="src"><a name="v:encodeAuto" class="def">encodeAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Encode an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> and its internal state into a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:decodeAuto" class="def">decodeAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</p><div class="doc"><p><a href="Resume.html">Resume</a> an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from its <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code> serialization, giving
 a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> if the deserialization is not possible.</p></div></div><div class="top"><p class="src"><a name="v:saveAuto" class="def">saveAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a></p><div class="doc"><p>Returns a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a></code> --- instructions (from <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html">Data.Serialize</a>) on how to
 &quot;freeze&quot; the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, with its internal state, and save it to a binary
 encoding.  It can later be reloaded and &quot;resumed&quot; by
 'resumeAuto'/'decodeAuto'.</p></div></div><div class="top"><p class="src"><a name="v:resumeAuto" class="def">resumeAuto</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</p><div class="doc"><p>Returns a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a></code> from an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> ---  instructions (from
 <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html">Data.Serialize</a>) on taking a ByteString and &quot;restoring&quot; the originally
 saved <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, in the originally saved state.</p></div></div><div class="top"><p class="src"><a name="v:unserialize" class="def">unserialize</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Takes an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that is serializable/resumable and returns an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>
 that is not.  That is, when it is &quot;saved&quot;, saves no data, and when it is
 &quot;resumed&quot;, resets itself back to the initial configuration every time;
 in other words, <code><code><a href="Control-Auto-Core.html#v:decodeAuto">decodeAuto</a></code> (unserialize a) bs = Right (unserialize
 a)</code>.  Trying to &quot;resume&quot; it will just always give itself, unchanged.</p></div></div><h2 id="g:5">Underlying monad</h2><div class="top"><p class="src"><a name="v:hoistA" class="def">hoistA</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m')</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> c. m c -&gt; m' c)</td><td class="doc"><p>monad morphism;
     the natural transformation</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m' a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Swaps out the underlying <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> of an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> using the given monad
 morphism &quot;transforming function&quot;, a natural transformation.</p><p>Basically, given a function to &quot;swap out&quot; any <code>m a</code> with an <code>m' a</code>, it
 swaps out the underlying monad of the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.</p><p>This forms a functor, so you rest assured in things like this:</p><pre>hoistA id == id
hoistA f a1 . hoistA f a2 == hoistA f (a1 . a2)
</pre></div></div><div class="top"><p class="src"><a name="v:generalizeA" class="def">generalizeA</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a> a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Generalizes an <code><code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code> a b</code> to an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b'</code> for any <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code>
 <code>m</code>, using <code>hoist</code>.</p><p>You generally should be able to avoid using this if you never directly
 write any <code><a href="Control-Auto-Core.html#t:Auto-39-">Auto'</a></code>s and always write 'Auto m' parameterized over all
 <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code>s, but...in case you import one from a library or something, you
 can use this.</p></div></div><h2 id="g:6">Special modifiers</h2><div class="top"><p class="src"><a name="v:interceptO" class="def">interceptO</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; ((b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b) -&gt; m c)</td><td class="doc"><p>intercepting function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a c</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Abstraction over lower-level funging with serialization; lets you
 modify the result of an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> by being able to intercept the <code>(b,
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b)</code> output and return a new output value <code>m c</code>.</p><p>Note that this is a lot like <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:fmap">fmap</a></code>:</p><pre>fmap :: (b -&gt; c) -&gt; Auto m a b -&gt; Auto m a c
</pre><p>Except gives you access to both the <code>b</code> and the &quot;updated <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;;
 instead of an <code>b -&gt; c</code>, you get to pass a <code>(b, <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b) -&gt; m c</code>.</p><p>Basically experimenting with a bunch of abstractions over different
 lower-level modification of <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s, because making sure the
 serialization works as planned can be a bit difficult.</p></div></div><h1 id="g:7">Auto constructors</h1><h2 id="g:8">Lifting values and functions</h2><div class="top"><p class="src"><a name="v:mkConst" class="def">mkConst</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: b</td><td class="doc"><p>constant value to be outputted</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> whose output is always the given value, ignoring
 its input.</p><p>Provided for API constency, but you should really be using <code><a href="Control-Auto-Generate.html#v:pure">pure</a></code> from
 the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a></code> instance, from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html">Control.Applicative</a>, which does the
 same thing.</p></div></div><div class="top"><p class="src"><a name="v:mkConstM" class="def">mkConstM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: m b</td><td class="doc"><p>monadic action to be executed at every step</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that always &quot;executes&quot; the given monadic value at
 every step, yielding the result as its output and ignoring its input.</p><p>Provided for API consistency, but you shold really be using <code>effect</code>
 from <a href="Control-Auto-Effects.html">Control.Auto.Effects</a>, which does the same thing.</p></div></div><div class="top"><p class="src"><a name="v:mkFunc" class="def">mkFunc</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; b)</td><td class="doc"><p>pure function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct a stateless <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that simply applies the given (pure)
 function to every input, yielding the output.  The output stream is just
 the result of applying the function to every input.</p><pre>streamAuto' (mkFunc f) = map f</pre><p>This is rarely needed; you should be using <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#v:arr">arr</a></code> from the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html#t:Arrow">Arrow</a></code>
 instance, from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Arrow.html">Control.Arrow</a>.</p></div></div><div class="top"><p class="src"><a name="v:mkFuncM" class="def">mkFuncM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; m b)</td><td class="doc"><p>&quot;monadic&quot; function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct a stateless <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that simply applies and executes the givne
 (monadic) function to every input, yielding the output.  The output
 stream is the result of applying the function to every input,
 executing/sequencing the action, and returning the returned value.</p><pre>streamAuto (mkFuncM f) = mapM f</pre><p>It's recommended that you use <code>arrM</code> from <a href="Control-Auto-Effects.html">Control.Auto.Effects</a>.  This
 is only really provided for consistency.</p></div></div><h2 id="g:9">from State transformers</h2><div class="top"><p class="src"><a name="v:mkState" class="def">mkState</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; s -&gt; (b, s))</td><td class="doc"><p>state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>intial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from a state transformer: an <code>a -&gt; s -&gt; (b, s)</code>
 gives you an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>, for any <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a></code> <code>m</code>.  At every step, it
 takes in the <code>a</code> input, runs the function with the stored internal
 state, returns the <code>b</code> result, and now contains the new resulting state.
 You have to intialize it with an initial state, of course.</p><p>From the &quot;stream transformer&quot; point of view, this is rougly equivalent
 to <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Traversable.html#v:mapAccumL">mapAccumL</a></code> from <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-List.html">Data.List</a>, with the function's arguments and
 results in the backwards order.</p><pre>streamAuto' (mkState f s0) = snd . mapAccumL (\s x -&gt; swap (f x s))</pre><p>Try not to use this if it's ever avoidable, unless you're a framework
 developer or something.  Try make something by combining/composing the
 various <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> combinators.</p><p>If your state <code>s</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you should
 either write a meaningful one, provide the serialization methods
 manually with <code><a href="Control-Auto-Core.html#v:mkState-39-">mkState'</a></code>, or throw away serializability and use
 <code><a href="Control-Auto-Core.html#v:mkState_">mkState_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mkState_" class="def">mkState_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; s -&gt; (b, s))</td><td class="doc"><p>state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto-Core.html#v:mkState">mkState</a></code>, where the internal state isn't serialized.  It
 can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the process.</p><p>See <code><a href="Control-Auto-Core.html#v:mkState">mkState</a></code> for more details.</p><p>Useful if your state <code>s</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance.</p></div></div><div class="top"><p class="src"><a name="v:mkStateM" class="def">mkStateM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> s</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; s -&gt; m (b, s))</td><td class="doc"><p>(monadic) state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from a &quot;monadic&quot; state transformer: <code>a -&gt; s -&gt;
 m (b, s)</code> gives you an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>.  At every step, it takes in the
 <code>a</code> input, runs the function with the stored internal state and
 &quot;executes&quot; the <code>m (b, s)</code> to get the <code>b</code> output, and stores the <code>s</code> as
 the new, updated state.  Must be initialized with an initial state.</p><p>Try not to use this if it's ever avoidable, unless you're a framework
 developer or something.  Try make something by combining/composing the
 various <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> combinators.</p><p>This version is a wrapper around <code><a href="Control-Auto-Core.html#v:mkAuto">mkAuto</a></code>, that keeps track of the
 serialization and re-loading of the internal state for you, so you don't
 have to deal with it explicitly.</p><p>If your state <code>s</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you should
 either write a meaningful one, provide the serialization methods
 manually with <code><a href="Control-Auto-Core.html#v:mkStateM-39-">mkStateM'</a></code>, or throw away serializability and use
 <code><a href="Control-Auto-Core.html#v:mkStateM_">mkStateM_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:mkStateM_" class="def">mkStateM_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; s -&gt; m (b, s))</td><td class="doc"><p>(monadic) state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto-Core.html#v:mkStateM">mkStateM</a></code>, where the internal state isn't serialized.
 It can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the process.</p><p>See <code><a href="Control-Auto-Core.html#v:mkStateM">mkStateM</a></code> for more details.</p><p>Useful if your state <code>s</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance.</p></div></div><div class="top"><p class="src"><a name="v:mkState-39-" class="def">mkState'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a> s</td><td class="doc"><p><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a></code>; strategy for reading and deserializing the state</p></td></tr><tr><td class="src">-&gt; (s -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a>)</td><td class="doc"><p><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a></code>; strategy for serializing given state</p></td></tr><tr><td class="src">-&gt; (a -&gt; s -&gt; (b, s))</td><td class="doc"><p>state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>intial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto-Core.html#v:mkState">mkState</a></code>, where the internal state doesn't have
 a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, so you provide your own instructions for getting
 and putting the state.</p><p>See <code><a href="Control-Auto-Core.html#v:mkState">mkState</a></code> for more details.</p></div></div><div class="top"><p class="src"><a name="v:mkStateM-39-" class="def">mkStateM'</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a> s</td><td class="doc"><p><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a></code>; strategy for reading and deserializing the state</p></td></tr><tr><td class="src">-&gt; (s -&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a>)</td><td class="doc"><p><code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a></code>; strategy for serializing given state</p></td></tr><tr><td class="src">-&gt; (a -&gt; s -&gt; m (b, s))</td><td class="doc"><p>(monadic) state transformer</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto-Core.html#v:mkStateM">mkStateM</a></code>, where the internal state doesn't have
 a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, so you provide your own instructions for getting
 and putting the state.</p><p>See <code><a href="Control-Auto-Core.html#v:mkStateM">mkStateM</a></code> for more details.</p></div></div><h2 id="g:10">from Accumulators</h2><h3 id="g:11">Result-first</h3><div class="top"><p class="src"><a name="v:accum" class="def">accum</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from a &quot;folding&quot; function: <code>b -&gt; a -&gt; b</code> yields an
 <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>.  Basically acts like a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-List.html#v:foldl">foldl</a></code> or a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-List.html#v:scanl">scanl</a></code>.  There is
 an internal accumulator that is &quot;updated&quot; with an <code>a</code> at every step.
 Must be given an initial accumulator.</p><p>Example: an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that sums up all of its input.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let summer = accum (+) 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (sum1, summer')  = stepAuto' summer 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sum1
</code></strong>3
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (sum2, summer'') = stepAuto' summer' 10
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sum2
</code></strong>13
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto'  summer'' [1..10]
</code></strong>[14,16,19,23,28,34,41,49,58,68]
</pre><p>If your accumulator <code>b</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you
 should either write a meaningful one, or throw away serializability and
 use <code><a href="Control-Auto-Core.html#v:accum_">accum_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:accum_" class="def">accum_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>intial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of <code><a href="Control-Auto-Core.html#v:accum">accum</a></code>, where the internal accumulator isn't
 serialized. It can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the
 process.</p><p>See <code><a href="Control-Auto-Core.html#v:accum">accum</a></code> for more details.</p><p>Useful if your accumulator <code>b</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code>
 instance.</p></div></div><div class="top"><p class="src"><a name="v:accumM" class="def">accumM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> from a &quot;monadic&quot; &quot;folding&quot; function: <code>b -&gt; a -&gt;
 m b</code> yields an <code><code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> m a b</code>.  Basically acts like a <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:foldM">foldM</a></code> or <code>scanM</code>
 (if it existed).  here is an internal accumulator that is &quot;updated&quot; with
 an input <code>a</code> with the result of the executed <code>m b</code> at every step.  Must
 be given an initial accumulator.</p><p>See <code><a href="Control-Auto-Core.html#v:accum">accum</a></code> for more details.</p><p>If your accumulator <code>b</code> does not have a <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code> instance, then you
 should either write a meaningful one, or throw away serializability and
 use <code><a href="Control-Auto-Core.html#v:accumM_">accumM_</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:accumM_" class="def">accumM_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A version of 'accumM_, where the internal accumulator isn't
 serialized. It can be &quot;saved&quot; and &quot;loaded&quot;, but the state is lost in the
 process.</p><p>See <code><a href="Control-Auto-Core.html#v:accumM">accumM</a></code> for more details.</p><p>Useful if your accumulator <code>b</code> cannot have a meaningful <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a></code>
 instance.</p></div></div><h3 id="g:12">Initial accumulator-first</h3><div class="top"><p class="src"><a name="v:accumD" class="def">accumD</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A &quot;delayed&quot; version of <code><a href="Control-Auto-Core.html#v:accum">accum</a></code>, where the first output is the initial
 state of the accumulator, before applying the folding function. Useful
 in recursive bindings.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let summerD = accumD (+) 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (sum1, summerD')  = stepAuto' summerD 3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sum1
</code></strong>0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (sum2, summerD'') = stepAuto' summerD' 10
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sum2
</code></strong>3
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>streamAuto'  summerD'' [1..10]
</code></strong>[13,14,16,19,23,28,34,41,49,58]
</pre><p>(Compare with the example in <code><a href="Control-Auto-Core.html#v:accum">accum</a></code>)</p></div></div><div class="top"><p class="src"><a name="v:accumD_" class="def">accumD_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; a -&gt; b)</td><td class="doc"><p>accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>intial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto-Core.html#v:accumD">accumD</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:accumMD" class="def">accumMD</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize.html#t:Serialize">Serialize</a> b, <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A &quot;delayed&quot; version of <code><a href="Control-Auto-Core.html#v:accumM">accumM</a></code>, where the first output is the initial
 state of the accumulator, before applying the folding function. Useful
 in recursive bindings.</p></div></div><div class="top"><p class="src"><a name="v:accumMD_" class="def">accumMD_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b -&gt; a -&gt; m b)</td><td class="doc"><p>(monadic) accumulating function</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>initial accumulator</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The non-resuming/non-serializing version of <code><a href="Control-Auto-Core.html#v:accumMD">accumMD</a></code>.</p></div></div><h2 id="g:13">Arbitrary Autos</h2><div class="top"><p class="src"><a name="v:mkAuto" class="def">mkAuto</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>resuming/loading <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a></code></p></td></tr><tr><td class="src">-&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a></td><td class="doc"><p>saving <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a></code></p></td></tr><tr><td class="src">-&gt; (a -&gt; (b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b))</td><td class="doc"><p>step function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> by explicity giving its serialization,
 deserialization, and the function from <code>a</code> to a <code>b</code> and &quot;updated
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;.</p><p>Ideally, you wouldn't have to use this unless you are making your own
 framework.  Try your best to make what you want by assembling
 primtives together.  Working with serilization directly is hard.</p><p>See <code><a href="Control-Auto-Core.html#v:mkAutoM">mkAutoM</a></code> for more detailed instructions on doing this right.</p></div></div><div class="top"><p class="src"><a name="v:mkAuto_" class="def">mkAuto_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; (b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b))</td><td class="doc"><p>step function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto-Core.html#v:mkAuto">mkAuto</a></code>, but without any way of meaningful serializing or
 deserializing.</p><p>Be careful!  This <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> can still carry arbitrary internal state, but
 it cannot be meaningfully serialized or re-loaded/resumed.  You can
 still pretend to do so using
 'resumeAuto'/'saveAuto'/'encodeAuto'/'decodeAuto' (and the type system
 won't stop you), but when you try to &quot;resume&quot;/decode it, its state will
 be lost.</p></div></div><div class="top"><p class="src"><a name="v:mkAutoM" class="def">mkAutoM</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a> (<a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b)</td><td class="doc"><p>resuming/loading <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a></code></p></td></tr><tr><td class="src">-&gt; <a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a></td><td class="doc"><p>saving <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Put.html#t:Put">Put</a></code></p></td></tr><tr><td class="src">-&gt; (a -&gt; m (b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b))</td><td class="doc"><p>(monadic) step function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Construct an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> by explicitly giving its serializiation,
 deserialization, and the (monadic) function from <code>a</code> to a <code>b</code> and the
 &quot;updated <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>&quot;.</p><p>See the &quot;serialization&quot; section in the <a href="Control-Auto-Core.html">Control.Auto.Core</a> module for
 more information.</p><p>Ideally, you wouldn't have to use this unless you are making your own
 framework.  Try your best to make what you want by assembling
 primtives together.</p><p>But sometimes you have to write your own combinators, and you're going
 to have to use <code><a href="Control-Auto-Core.html#v:mkAutoM">mkAutoM</a></code> to make it work.</p><p>Sometimes, it's simple:</p><pre>fmap :: (a -&gt; b) -&gt; Auto r a -&gt; Auto r b
fmap f a0 = mkAutoM (do aResumed &lt;- resumeAuto a0
                        return (fmap f aResumed)  )
                    (saveAuto a0)
                    $ x -&gt; do
                        (y, a1) &lt;- stepAuto a0 x
                        return (f y, fmap f a1)
</pre><p>Serializing <code><code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:fmap">fmap</a></code> f a0</code> is just the same as serializing <code>a0</code>.  And to
 resume it, we resume <code>a0</code> to get a resumed version of <code>a0</code>, and then we
 apply <code><code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:fmap">fmap</a></code> f</code> to the <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that we resumed.</p><p>Also another nice &quot;simple&quot; example is:</p><pre>catchA :: Exception e
       =&gt; Auto IO a b
       -&gt; Auto IO a (Either e b)
catchA a = mkAutoM (do aResumed &lt;- resumeAuto a
                       return (catchA aResumed) )
                   (saveAuto a)
                 $ x -&gt; do
                     eya' &lt;- try $ stepAuto a x
                     case eya' of
                       Right (y, a') -&gt; return (Right y, catchA a')
                       Left e        -&gt; return (Left e , catchA a )
</pre><p>Which is basically the same principle, in terms of serializing and
 resuming strategies.</p><p>When you have &quot;switching&quot; --- things that behave like different <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s
 at different points in time --- then things get a little complicated,
 because you have to figure out which <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> to resume.</p><p>For example, let's look at the source of <code>-?&gt;</code>:</p><pre>(-?&gt;) :: Monad m
      =&gt; Interval m a b   -- ^ initial behavior
      -&gt; Interval m a b   -- ^ final behavior, when the initial
                          --   behavior turns off.
      -&gt; Interval m a b
a1 -?&gt; a2 = mkAutoM l s t
  where
    l = do
      flag &lt;- get
      if flag
        then resumeAuto (switched a2)
        else (-?&gt; a2) <a href="$">$</a> resumeAuto a1
    s = put False *&gt; saveAuto a1
    t x = do
      (y1, a1') &lt;- stepAuto a1 x
      case y1 of
        Just _  -&gt;
          return (y1, a1' -?&gt; a2)
        Nothing -&gt; do
          (y, a2') &lt;- stepAuto a2 x
          return (y, switched a2')
    switched a = mkAutoM (switched <a href="$">$</a> resumeAuto a)
                         (put True  *&gt; saveAuto a)
                       $ x -&gt; do
                           (y, a') &lt;- stepAuto a x
                           return (y, switched a')
</pre><p>We have to invent a serialization and reloading scheme, taking into
 account the two states that the resulting <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> can be in:</p><ol><li>Initially, it is behaving like <code>a1</code>.  So, to save it, we put
      a flag saying that we are still in stage 1 (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Bool.html#v:False">False</a></code>), and then
      put <code>a1</code>'s current serialization data.</li><li>After the switch, it is behaving like <code>a2</code>.  So, to save it, we put
      a flag saying that we are now in stage 2 (<code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Bool.html#v:True">True</a></code>), and then put
      <code>a2</code>'s current.</li></ol><p>Now, when we <em>resume</em> <code>a1 <code>-?&gt;</code> a2</code>, <code><a href="Control-Auto-Core.html#v:resumeAuto">resumeAuto</a></code> on <code>a1 <code>-?&gt;</code> a2</code> will
 give us <code>l</code>.  So the <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a></code> we use --- the process we use to resume the
 entire <code>a1 <code>-?&gt;</code> a2</code>, will <em>start</em> at the initial <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a></code>/loading
 function, <code>l</code> here.  We have to encode our branching and
 resuming/serialization scheme into the initial, front-facing <code>l</code>.  So
 <code>l</code> has to check for the flag, and if the flag is true, load in the data
 for the switched state; otherwise, load in the data for the pre-switched
 state.</p><p>Not all of them are this tricky.  Mostly &quot;switching&quot; combinators will be
 tricky, because switching means changing what you are serializing.</p><p>This one might be considerably easier, because of <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Traversable.html#v:mapM">mapM</a></code>:</p><pre>zipAuto :: Monad m
        =&gt; a                -- ^ default input value
        -&gt; [Auto m a b]     -- ^ <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s to zip up
        -&gt; Auto m [a] [b]
zipAuto x0 as = mkAutoM (zipAuto x0 <a href="$">$</a> mapM resumeAuto as)
                        (mapM_ saveAuto as)
                        $ xs -&gt; do
                            res &lt;- zipWithM stepAuto as (xs ++ repeat x0)
                            let (ys, as') = unzip res
                            return (ys, zipAuto x0 as')
</pre><p>To serialize, we basically sequence <code><a href="Control-Auto-Core.html#v:saveAuto">saveAuto</a></code> over all of the internal
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s --- serialize each of their serialization data one-by-one one
 after the other in our binary.</p><p>To load, we do the same thing; we go over every <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> in <code>as</code> and
 <code><a href="Control-Auto-Core.html#v:resumeAuto">resumeAuto</a></code> it, and then collect the results in a list --- a list of
 resumed <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s.  And then we apply <code><code>zipAuto</code> x0</code> to that list of
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s, to get our resumed <code><code>zipAuto</code> x0 as</code>.</p><p>So, it might be complicated.  In the end, it might be all worth it, too,
 to have implicit serialization compose like this.  Think about your
 serialization strategy first.  Step back and think about what you need
 to serialize at every step, and remember that it's _the initial_
 &quot;resuming&quot; function that has to &quot;resume everything&quot;...it's not the
 resuming function that exists when you finally save your <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, it's
 the resuming <code><a href="file:///home/justin/projects/haskell/auto/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.8.3/cereal-0.4.1.1/html/Data-Serialize-Get.html#t:Get">Get</a></code> that was there <em>at the beginning</em>.  For <code>-?&gt;</code>, the
 intial <code>l</code> had to know how to &quot;skip ahead&quot;.</p><p>And of course as always, test.</p><p>If you need to make your own combinator or transformer but are having
 trouble with the serializtion, feel free to contact me at
 <a href="justin@jle.im">justin@jle.im</a>, on freenode at <em>#haskell</em> or <em>#haskell-auto</em>, open
 a <a href="https://github.com/mstksg/auto/issues">github issue</a>, etc.  Just
 contact me somehow, I'll be happy to help!</p></div></div><div class="top"><p class="src"><a name="v:mkAutoM_" class="def">mkAutoM_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; m (b, <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b))</td><td class="doc"><p>(monadic) step function</p></td></tr><tr><td class="src">-&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Control-Auto-Core.html#v:mkAutoM">mkAutoM</a></code>, but without any way of meaningful serializing or
 deserializing.</p><p>Be careful!  This <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> can still carry arbitrary internal state, but
 it cannot be meaningfully serialized or re-loaded/resumed.  You can
 still pretend to do so using
 'resumeAuto'/'saveAuto'/'encodeAuto'/'decodeAuto' (and the type system
 won't stop you), but when you try to &quot;resume&quot;/decode it, its state will
 be reset.</p></div></div><h1 id="g:14">Strictness</h1><div class="top"><p class="src"><a name="v:forceSerial" class="def">forceSerial</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b -&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a b</p><div class="doc"><p>Force the serializing components of an <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>.</p><p>TODO: Test if this really works</p></div></div><div class="top"><p class="src"><a name="v:forcer" class="def">forcer</a> :: <a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/deepseq-1.3.0.2/Control-DeepSeq.html#t:NFData">NFData</a> a =&gt; <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a a</p><div class="doc"><p>A special <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that acts like the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#v:id">id</a></code> <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, but forces results as
 they come through to be fully evaluated, when composed with other
 <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s.</p><p>TODO: Test if this really works</p></div></div><div class="top"><p class="src"><a name="v:seqer" class="def">seqer</a> ::  <a href="Control-Auto-Core.html#t:Auto">Auto</a> m a a</p><div class="doc"><p>A special <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code> that acts like the <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Category.html#v:id">id</a></code> <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>, but forces results as
 they come through to be evaluated to Weak Head Normal Form, with <code><a href="file:///usr/local/ghc-7.8.3/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#v:seq">seq</a></code>,
 when composed with other <code><a href="Control-Auto-Core.html#t:Auto">Auto</a></code>s.</p><p>TODO: Test if this really works</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>